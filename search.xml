<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Clickhouse 数据副本与集群高可用</title>
    <url>/2021/03/11/Clickhouse-%E6%95%B0%E6%8D%AE%E5%89%AF%E6%9C%AC%E4%B8%8E%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<p>使用的 CH 版本：19.16.9.37</p>
<p>官方的文档看得晕头转向，可能还是自己英文功底不够，在读完官方的相关文档后，自己又做了大量测试，总结一下心得。</p>
<p>推荐阅读的官方文档：</p>
<ul>
<li><a href="https://clickhouse.tech/docs/en/engines/table-engines/mergetree-family/replication">https://clickhouse.tech/docs/en/engines/table-engines/mergetree-family/replication</a></li>
<li><a href="https://clickhouse.tech/docs/en/getting-started/tutorial/#cluster-deployment">https://clickhouse.tech/docs/en/getting-started/tutorial/#cluster-deployment</a></li>
<li><a href="https://clickhouse.tech/docs/en/engines/table-engines/special/distributed">https://clickhouse.tech/docs/en/engines/table-engines/special/distributed</a></li>
</ul>
<p>如果看完本文仍有疑惑的地方，建议阅读下官方文档。</p>
<p>在 CH 中单独提及“副本”涉及到两个概念，副本表和副本分片，顾名思义，一个是为表做副本，一个是为分片做副本。</p>
<p>为了避免混乱后面会分开说这两种副本。</p>
<h2 id="副本表（replicated-table）"><a href="#副本表（replicated-table）" class="headerlink" title="副本表（replicated table）"></a>副本表（replicated table）</h2><p>副本表比较容易理解，所有的副本表之间会相互同步数据，注意是相互同步。</p>
<p>副本表从使用角度来看并没有主副之分，任何一个副本表都可以拿来正常使用，<br>因此在创建副本表时，即便是第一个副本表也需要用 Replicated* 系列引擎创建。</p>
<p>副本表依赖 zookeeper，但并不依赖集群。</p>
<p>我想再解释一下“副本表并不依赖集群”这句话：</p>
<p>首先，在多个实例上创建副本表时，副本表并不要求这些实例们必须组成集群，也就是说即便是两个毫无关系的 CH 实例，<br>只要他们之间可以通过网络互相访问，就可以在这两个实例上创建副本表，当然如果组成集群也是可以的；<br>其次，多个副本表也可以在单个 CH 中也可以创建出来，但个人认为这其实没有太大的意义，<br>因为这种模式下，副本数据的安全性在发生硬盘物理损坏时得不到保障。</p>
<p>创建副本表时，引擎函数最少需要两个参数，其他参数可以继续在括号内顺序填写：</p>
<ul>
<li>zookeeper_path<br>  在 zookeeper 中创建的路径，用来标识一组副本表，同一组的副本表存储的都是相同的数据，它们之间互为副本，<br>  同一组副本表在不同实例上创建时要使用相同的路径，示例：<br>  <code>/clickhouse/tables/replications/database_name/table_name</code></li>
<li>replica_name<br>  在 zookeeper 中 zookeeper_path/replicas 路径下注册节点，用来识别同一组内的副本表，<br>  组内每个副本表应该使用不同的 replica_name，建议使用 CH 实例服务器主机名或域名。</li>
</ul>
<p>当 CH 实例比较多且实例间组成了集群时，可以使用 CH 的 DDL 特性，即 ON CLUSTER 语句，一次性在多个实例上创建副本表，<br>这种情况下，建表语句中的引擎函数就不能把 replica_name 参数写死了，官方推荐在配置文件中设置宏来进行自动替换。</p>
<p>此外，CH 服务的配置文件中有两个重要的配置项：</p>
<ul>
<li>interserver_http_host</li>
<li>interserver_http_port<br>这两个参数用来设置副本表所在 CH 实例之间的通讯地址和端口，<br>各 CH 实例会将自己的地址注册到 zookeeper_path/replicas/replica_name/host 中，这样其他实例就知道怎么访问了。</li>
</ul>
<p>如果 CH 实例是运行在 docker 容器内的，还需要注意以下两点：</p>
<ul>
<li>host 参数不能使用 0.0.0.0 或 127.0.0.1，需要使用明确的主机 IP，以确保其他实例可以正常访问</li>
<li>port 参数设置的值需要在创建容器时增加对应的端口映射</li>
</ul>
<h3 id="副本表示例"><a href="#副本表示例" class="headerlink" title="副本表示例"></a>副本表示例</h3><p>这里使用两个 CH 实例进行搭建，二者可以互通，主机名分别为：DBServerA 和 DBServerB。<br>在 DBServerA 上部署并启动一个 Zookeeper 服务，然后再分别在两台机器上部署并启动两个 CH 服务。<br>启动前注意修改服务配置文件，将 zookeeper 配置好。</p>
<p>分别连接到两个 CH 实例，命令行或图形化客户端均可，在 DBServerA 上执行如下 SQL 创建第一个副本表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE default.test</span><br><span class="line">(&#96;data&#96; Float64)</span><br><span class="line">ENGINE &#x3D; ReplicatedMergeTree(&#39;&#x2F;clickhouse&#x2F;tables&#x2F;replications&#x2F;default&#x2F;test&#39;, &#39;DBServerA&#39;) </span><br><span class="line">ORDER BY &#96;data&#96;</span><br><span class="line">SETTINGS index_granularity &#x3D; 8192</span><br></pre></td></tr></table></figure>

<p>在 DBServerB 上执行如下 SQL 创建第二个副本表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE default.test</span><br><span class="line">(&#96;data&#96; Float64)</span><br><span class="line">ENGINE &#x3D; ReplicatedMergeTree(&#39;&#x2F;clickhouse&#x2F;tables&#x2F;replications&#x2F;default&#x2F;test&#39;, &#39;DBServerB&#39;) </span><br><span class="line">ORDER BY &#96;data&#96;</span><br><span class="line">SETTINGS index_granularity &#x3D; 8192</span><br></pre></td></tr></table></figure>

<p>可以看到上面两个 SQL 分别在两个 CH 实例上创建了两个同名的表：<code>test</code>，<br>使用了 <code>ReplicatedMergeTree</code> 引擎，引擎函数的第一个参数是相同的，用来表示这两个副本表是同一组的，存储的是相同的数据。<br>引擎函数的第二个参数是不同的，用来表示这个组内共有两个副本表。</p>
<p>在 DBServerA 上执行如下 SQL 插入一条数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into default.test</span><br><span class="line">values</span><br><span class="line">(6)</span><br></pre></td></tr></table></figure>

<p>插入完成后可以在两个 CH 实例中执行 SELECT 语句查看，会发现 DBServerB 中也有了这一条值为 1 的数据。</p>
<p>也可以在 DBServerB 上继续执行插入语句，注意修改值 1 到其他值，会发现 DBServerA 也会自动同步过去。</p>
<p>关闭 DBServerA 的 CH 服务，继续在 DBServerB 上执行插入，修改，删除操作后，再启动 DBServerA 上的 CH 服务，<br>会发现 DBServerA 将自己同步到了与 DBServerB 相同的状态。</p>
<p>至此，同步表测试完成。</p>
<h2 id="副本分片"><a href="#副本分片" class="headerlink" title="副本分片"></a>副本分片</h2><p>副本分片（replica）依赖 zookeeper 和集群。</p>
<p>需要了解 CH 的集群知识才能理解副本分片，首先不考虑副本，我们先看看什么是分片？</p>
<p>先来看一段 CH 集群的最简配置，两台机器组成集群：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;remote_servers incl&#x3D;&quot;clickhouse_remote_servers&quot; &gt;</span><br><span class="line">    &lt;my_test_cluster&gt;</span><br><span class="line">         &lt;shard&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                 &lt;host&gt;192.168.1.101&lt;&#x2F;host&gt;</span><br><span class="line">                 &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">         &lt;&#x2F;shard&gt;</span><br><span class="line">         &lt;shard&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                 &lt;host&gt;192.168.1.102&lt;&#x2F;host&gt;</span><br><span class="line">                 &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">         &lt;&#x2F;shard&gt;</span><br><span class="line">     &lt;&#x2F;my_test_cluster&gt;</span><br><span class="line">&lt;&#x2F;remote_servers&gt;</span><br></pre></td></tr></table></figure>

<p>上述配置创建了一个名为：<code>my_test_cluster</code> 的集群，整个集群的数据被拆分为两个分片，每个分片有一个 CH 节点，<br>之所以称之为分片，是从集群数据角度来看的，每个分片只包含整个集群的一部分数据，当需要查询整个集群的数据时，<br>需要使用到 CH 的分布式表引擎。</p>
<p>再来看上述配置，每一个 <code>shard</code> 小节就是一个分片，而 <code>shard</code> 小节内部的 <code>replica</code> 即为副本分片。</p>
<p>在这里明确强调一下两个概念：</p>
<ul>
<li>shard：分片，集群完整数据的一部分</li>
<li>replica：副本分片，真正为分片存储数据的地方，当仅有一个 replica 时，shard 等价于 replica</li>
</ul>
<p>分片的概念不能与 CH 实例或节点划等号的，分片只与数据有关，分片更像是节点的上一层概念。<br>有多少分片就意味着数据被拆分成了多少份，倒是副本分片的存在方式与节点差不多。<br>**<font color=red><br>注意！一个分片下的 CH 实例是不可以在其他分片下再次出现的，否则在查询数据时就会出问题，<br>CH 有可能会重复查询出同一分片下的数据，我留意到国内有不少相关文档出现了此错误。<br></font>**</p>
<p>只配置一个副本分片时 CH 集群就已经可以正常工作了，在通过分布式表引擎查询整个集群的数据时，<br>就会使用到所有节点的硬件资源，但是这种形式的集群可称之为高性能集群，但没有丝毫高可用性的保障，<br>因为任何一个节点掉线时，都会导致查询报错。</p>
<p>设置多个副本分片（replica）的目的就是为了提高可用性，其配置方法也很简单，<br>就是在一个 <code>shard</code> 小节内部配置多个 <code>replica</code> 小节即可，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;remote_servers incl&#x3D;&quot;clickhouse_remote_servers&quot; &gt;</span><br><span class="line">    &lt;my_test_cluster&gt;</span><br><span class="line">         &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;false&lt;&#x2F;internal_replication&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                 &lt;host&gt;192.168.1.101&lt;&#x2F;host&gt;</span><br><span class="line">                 &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                 &lt;host&gt;192.168.1.103&lt;&#x2F;host&gt;</span><br><span class="line">                 &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">         &lt;&#x2F;shard&gt;</span><br><span class="line">         &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;false&lt;&#x2F;internal_replication&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                 &lt;host&gt;192.168.1.102&lt;&#x2F;host&gt;</span><br><span class="line">                 &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                 &lt;host&gt;192.168.1.104&lt;&#x2F;host&gt;</span><br><span class="line">                 &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">         &lt;&#x2F;shard&gt;</span><br><span class="line">     &lt;&#x2F;my_test_cluster&gt;</span><br><span class="line">&lt;&#x2F;remote_servers&gt;</span><br></pre></td></tr></table></figure>

<p>当一个分片拥有了多个副本分片时，就相当于有了备用军。<br>在某个副本出现问题导致掉线后，分布式表引擎在查询这一分片的数据时，会自动到可用的副本上去查找数据。</p>
<p>但如果一个分片的所有副本都掉线的话，那集群也是不能工作的，可以将分片的副本实例部署在多地区多机房来尽量避免这种问题。</p>
<h3 id="副本分片的数据同步"><a href="#副本分片的数据同步" class="headerlink" title="副本分片的数据同步"></a>副本分片的数据同步</h3><p>到这里看起来一切都很美好，我原以为设置完多个副本分片后，它们之间就会自动相互同步，<br>但其实副本分片与前面提到的副本表完全不同，它并不会自动将一个副本上的所有表同步到其他副本上。<br>副本分片只能保证明确指定的表之间的同步关系，其他表则不会同步。</p>
<p>要想保持副本分片中的指定表的数据是同步的，从操作方法来看有三种方法：</p>
<ul>
<li>普通表 + 分布式引擎表写入能力 + <code>internal_replication(false)</code></li>
<li>副本表 + 分布式引擎表写入能力 + <code>internal_replication(true)</code></li>
<li>副本表</li>
</ul>
<p>前两种方法都涉及到一个非常关键的配置项：<code>internal_replication</code>（上面多副本分片示例配置中有）。<br>要解释这个配置项需要先了解分布式引擎表，文章开头的链接中有官方文档，这里只笼统得提一下它的作用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分布式引擎表提供了 CH 集群模式下的跨分片读写能力。</span><br></pre></td></tr></table></figure>

<p>而这个配置项则控制了分布式引擎表的数据写入行为：</p>
<ul>
<li>设置为 <code>false</code> 时，分布式引擎表会把分到一个分片下的数据，写入到所有副本分片上，<code>false</code> 也是默认值。</li>
<li>设置为 <code>true</code> 时，分布式引擎表只把分到一个分片下的数据，写入到发现的第一个可用副本分片上。</li>
</ul>
<h4 id="同步方法-1（不推荐）"><a href="#同步方法-1（不推荐）" class="headerlink" title="同步方法 1（不推荐）"></a>同步方法 1（不推荐）</h4><p>首先需要说明的是，第一种方法官方不推荐使用，因为这种方法 CH 不能保证副本分片的数据一致性，<br>多个副本分片里的数据随着时间的推移会出现数据不一致的情况。</p>
<p>虽然此方法不被推荐，但为了文章内容完整性，还是简单说一下用法。</p>
<p>其实有了前面的知识积累，用法已经很明朗了，核心就是让分布式表引擎在写数据时主动写多份。</p>
<ol>
<li>确保 <code>internal_replication</code> 选项设置为 <code>false</code></li>
<li>创建一个包含两个分片的集群，每个分片包含两个副本分片</li>
<li>在四个节点上创建普通数据表：<code>test</code>，注意不能是副本表</li>
<li>在四个节点上创建分布式引擎表：<code>test_all</code>，其读写上面 <code>test</code> 表</li>
<li>在任一节点上往 <code>test_all</code> 表写入多次数据</li>
<li>在四个节点上分别查询 <code>test</code> 表内容，查看属于同一分片的表内容是否相同</li>
<li>不出意外应该是相同的，这表示这种方法已经走通了</li>
</ol>
<h4 id="同步方法-2"><a href="#同步方法-2" class="headerlink" title="同步方法 2"></a>同步方法 2</h4><p>这第二种方法的同步原理则是利用了副本表，CH 通过 zookeeper 可以保证数据的一致性。<br>上层应用将数据写入分布式引擎表，其根据配置将数据分为多个块，分别写入各个分片。<br>由于副本表已经提供了数据同步功能，因此需要将 <code>internal_replication</code> 设置为 <code>true</code>，<br>告诉分布式引擎一个分片的数据，只需要写完成一个分片副本即可。</p>
<h4 id="同步方法-3"><a href="#同步方法-3" class="headerlink" title="同步方法 3"></a>同步方法 3</h4><p>方法 3 与 方法 2 核心相同，但不使用分布式引擎表的写能力，故而也不需要配置 <code>internal_replication</code>。</p>
<p>这种方法使用的场景是：集群分为多个分片，每个分片上的数据有着明确的界限，虽然可以最终聚合在一起查询，但数据的写入和存储都需要分开，说起来有点类似于分库分表的概念。</p>
<p>由于不使用分布式表引擎写能力，因此上层应用需要分别与不同分片上的节点建立数据库连接，将数据分别写入，<br>个人更推荐的方法是将上层应用根据业务或者说数据界限拆分成多个模块，分别对应多个分片，各自写各自的数据，<br>最后上层应用提供给使用者的查询接口则是用分布式表引擎来查询所有分片的数据，即整个集群的数据。</p>
<h3 id="高可用集群示例"><a href="#高可用集群示例" class="headerlink" title="高可用集群示例"></a>高可用集群示例</h3><p>这里使用同步方法 2 举例高可用集群的搭建方法。<br>使用四个 CH 实例进行搭建，它们之间可以互通，它们的 IP 地址分别为：</p>
<ul>
<li>192.168.1.101</li>
<li>192.168.1.102</li>
<li>192.168.1.103</li>
<li>192.168.1.104</li>
</ul>
<p>后续使用 101 102 103 104 简称它们。</p>
<p>在 101 上部署并启动一个 Zookeeper 服务，然后再分别在四台机器上部署并启动 CH 服务。<br>启动前注意修改服务配置文件，有两点需要修改：</p>
<ul>
<li>zookeeper 配置项</li>
<li>cluster 配置项，四台机器配置相同，内容如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">方法 1 依赖 internal_replication 为 false</span><br><span class="line">方法 2 依赖 internal_replication 为 true</span><br><span class="line">方法 3 忽略 internal_replication 的配置</span><br><span class="line">且方法 1 不推荐使用，那么综上条件，无论使用方法 2 还是 3，</span><br><span class="line">都建议始终配置 internal_replication 为 true</span><br><span class="line">--&gt;</span><br><span class="line">&lt;remote_servers incl&#x3D;&quot;clickhouse_remote_servers&quot; &gt;</span><br><span class="line">    &lt;my_test_cluster&gt;</span><br><span class="line">         &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;true&lt;&#x2F;internal_replication&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                 &lt;host&gt;192.168.1.101&lt;&#x2F;host&gt;</span><br><span class="line">                 &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                 &lt;host&gt;192.168.1.103&lt;&#x2F;host&gt;</span><br><span class="line">                 &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">         &lt;&#x2F;shard&gt;</span><br><span class="line">         &lt;shard&gt;</span><br><span class="line">            &lt;internal_replication&gt;true&lt;&#x2F;internal_replication&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                 &lt;host&gt;192.168.1.102&lt;&#x2F;host&gt;</span><br><span class="line">                 &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                 &lt;host&gt;192.168.1.104&lt;&#x2F;host&gt;</span><br><span class="line">                 &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">         &lt;&#x2F;shard&gt;</span><br><span class="line">     &lt;&#x2F;my_test_cluster&gt;</span><br><span class="line">&lt;&#x2F;remote_servers&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上述配置设置了一个名为 <code>my_test_cluster</code> 的集群，整个集群中的数据被分为了两份，即共两个分片，每个分片内有两个副本分片。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                          -- 101</span><br><span class="line">                         &#x2F;</span><br><span class="line">            -- shard01 --</span><br><span class="line">           &#x2F;             \</span><br><span class="line">          &#x2F;               -- 103</span><br><span class="line">cluster --</span><br><span class="line">          \               -- 102</span><br><span class="line">           \             &#x2F;</span><br><span class="line">            -- shard02 --</span><br><span class="line">                         \</span><br><span class="line">                          -- 104</span><br></pre></td></tr></table></figure>

<p>我们计划让每组副本分片内部节点上数据完全相同，所以要确保所有新建的数据表（不包括分布式引擎表）都是用副本表，<br>在这里我们认为 101 和 103 属于一组，组名为 shard01，而 102 和 104 属于另一组，组名为 shard02。</p>
<p>需要在 101 和 103 上创建同组副本表，在 102 和 104 上创建另一组副本表，控制是否是同一组的方法是建表时的引擎参数。</p>
<p>分别连接到四个 CH 实例，命令行或图形化客户端均可，在 101 节点上执行如下 SQL 创建一个副本表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE default.test</span><br><span class="line">(&#96;data&#96; Float64)</span><br><span class="line">ENGINE &#x3D; ReplicatedMergeTree(&#39;&#x2F;clickhouse&#x2F;tables&#x2F;shard01&#x2F;default&#x2F;test&#39;, &#39;101&#39;) </span><br><span class="line">ORDER BY &#96;data&#96;</span><br><span class="line">SETTINGS index_granularity &#x3D; 8192</span><br></pre></td></tr></table></figure>

<p>在 103 节点上执行如下 SQL 创建一个副本表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE default.test</span><br><span class="line">(&#96;data&#96; Float64)</span><br><span class="line">ENGINE &#x3D; ReplicatedMergeTree(&#39;&#x2F;clickhouse&#x2F;tables&#x2F;shard01&#x2F;default&#x2F;test&#39;, &#39;103&#39;) </span><br><span class="line">ORDER BY &#96;data&#96;</span><br><span class="line">SETTINGS index_granularity &#x3D; 8192</span><br></pre></td></tr></table></figure>

<p>在 102 节点上执行如下 SQL 创建一个副本表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE default.test</span><br><span class="line">(&#96;data&#96; Float64)</span><br><span class="line">ENGINE &#x3D; ReplicatedMergeTree(&#39;&#x2F;clickhouse&#x2F;tables&#x2F;shard02&#x2F;default&#x2F;test&#39;, &#39;102&#39;) </span><br><span class="line">ORDER BY &#96;data&#96;</span><br><span class="line">SETTINGS index_granularity &#x3D; 8192</span><br></pre></td></tr></table></figure>

<p>在 104 节点上执行如下 SQL 创建一个副本表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE default.test</span><br><span class="line">(&#96;data&#96; Float64)</span><br><span class="line">ENGINE &#x3D; ReplicatedMergeTree(&#39;&#x2F;clickhouse&#x2F;tables&#x2F;shard02&#x2F;default&#x2F;test&#39;, &#39;104&#39;) </span><br><span class="line">ORDER BY &#96;data&#96;</span><br><span class="line">SETTINGS index_granularity &#x3D; 8192</span><br></pre></td></tr></table></figure>

<p>可以看到上面 4 个 SQL 分别在 4 个节点上创建了 4 个同名的表：<code>test</code>，使用了 <code>ReplicatedMergeTree</code> 引擎，<br>其中 101 和 102 一组所以引擎函数的第一个参数是相同的，103 和 104 同理，引擎函数的第二个参数是不同的，用来标识出每一个副本表。</p>
<p>接着创建分布式引擎表用来查询整个集群的完整数据，在 4 个节点上都执行如下 SQL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE default.test_all AS default.test</span><br><span class="line">ENGINE &#x3D; Distributed(my_test_cluster, default, test, rand())</span><br></pre></td></tr></table></figure>

<p>接着开始验证集群内同步和高可用能力，在 101 节点上执行如下 SQL 插入一条数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into default.test</span><br><span class="line">values</span><br><span class="line">(1)</span><br></pre></td></tr></table></figure>

<p>在 102 节点上执行如下 SQL 插入一条数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into default.test</span><br><span class="line">values</span><br><span class="line">(2)</span><br></pre></td></tr></table></figure>

<p>执行完成后可以在 4 个节点上查询 <code>test</code> 表，会发现除了 101 节点，103 中也有了这一条值为 1 的数据，但没有值为 2 的数据；而 102 和 104 上只有值为 2 的数据，这说明分片内副本表同步工作正常。</p>
<p>接着在任一节点上查询 <code>test_all</code> 表，会发现可以查出 1 和 2 两条数据，这说明集群跨分片读取功能正常。</p>
<p>然后执行如下 SQL 直接往 <code>test_all</code> 表插入数据，建议调整 SQL 中的值多次执行插入操作，因为一两次的插入操作可能都为分配到同一个分片上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into default.test_all</span><br><span class="line">values</span><br><span class="line">(2)</span><br></pre></td></tr></table></figure>

<p>每执行一次插入操作，就分别查询一次所有节点上的 <code>test</code> 表和 <code>test_all</code> 表来观察集群行为，会发现数据会被随即分配到两个分片上，分片内部的副本分片（副本表）则会始终保持同步。</p>
<p>关闭掉 101 节点，在剩余节点上查询 <code>test_all</code> 表发现集群工作正常，数据也没有缺失，接着关闭 103 节点，然后在剩余节点上查询 <code>test_all</code> 表发现会报错，说明如果一个分片上的所有分片副本都掉线的话，则集群瘫痪。</p>
<p>接着恢复 101 节点，然后再查询 <code>test_all</code> 表发现集群工作正常，说明集群可以自动重连掉线节点；在 101 节点上插入、删除、修改一些数据，再启动 103 节点，再查询 103 节点上的 <code>test</code> 表，发现在 103 掉线时组内 101 节点的操作都已经同步到了 103 上。</p>
<p>至此，高可用集群测试完成。</p>
<h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><p>上述方案仔细分析的话会发现只做到了集群内部的高可用，这对于上层应用来说还不够。</p>
<p>比如沿用上述高可用配置的例子，上层应用使用了 104 节点作为整个集群的外部出入口，只与 104 建立了连接，如果 104 节点掉线了的话，即便集群内部高可用优化的再好，上层应用也无法使用集群。</p>
<p>这种情况下如果不想改动上层应用，或者说想对上层应用屏蔽高可用实现细节，可以使用 <code>keepalived</code> 技术，为整个集群所有节点创建一个虚拟 IP，上层应用只与这个虚拟 IP 连接就可以了。关于 <code>keepalived</code> 的具体使用方法就不在这篇文章里展开了。</p>
]]></content>
      <categories>
        <category>clickhouse</category>
      </categories>
      <tags>
        <tag>cluster</tag>
        <tag>replica</tag>
        <tag>集群</tag>
        <tag>高可用</tag>
        <tag>副本</tag>
      </tags>
  </entry>
  <entry>
    <title>ImageSwitcher和TextSwitcher使用笔记</title>
    <url>/2016/05/04/ImageSwitcher%E5%92%8CTextSwitcher%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>只有步骤，记录，备忘<br>只举ImageSwitcher的例子，TextSwitcher基本一样</p>
<p>1、布局文件中添加ImageSwitcher控件<br>2、activity中findViewById()获取到ImageSwitcher对象<br>3、需要一个工厂来制造需要显示的ImageView，需要实现ViewFactory接口，并重写接口的makeView()方法，这里使用隐式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">imageSwitcher.setFactory(<span class="keyword">new</span> ViewFactory()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">makeView</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//1、new一个ImageView</span></span><br><span class="line">            <span class="comment">//2、为ImageView设置一系列属性</span></span><br><span class="line">            <span class="comment">//3、return加工好的ImageView对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>4、使用ImageSwitcher对象的setInAnimation()和setOutAnimation()设置动画效果(可选)<br>5、使用ImageSwitcher对象setImageResource()切换要显示的图片</p>
<p>结束</p>
<blockquote>
<p>TextSwitcher的方法和上面一样，都需要实现ViewFactory接口并重写makeView()方法，<br>在其中new出TextView对象并设置属性然后返回，最后切换视图的方法是setText()</p>
</blockquote>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>ImageSwitcher</tag>
        <tag>TextSwitcher</tag>
      </tags>
  </entry>
  <entry>
    <title>ListView的Iterm无法点击</title>
    <url>/2016/05/04/ListView%E7%9A%84Iterm%E6%97%A0%E6%B3%95%E7%82%B9%E5%87%BB/</url>
    <content><![CDATA[<p>当listview中同时出现Button或者ImageButton时，只有item中的Button或ImageButton能够获取焦点(能点击)，<br>而整个item无法获取焦点(无法点击)</p>
<p>原因：<br>因为ImageButton在初始化时把自己设置成setFocusable(true),这样，listView就获取不到焦点。<br>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageButton</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">        setFocusable(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还要强调一下：当xml中注册多个 View的时候，当我们点击按键之后，<br>Android会先判定哪个View setFocusable(true)设置焦点了,如果都设置了，<br>那么Android 会默认响应在xml中第一个注册的view ,而不是两个都会响应。</p>
<p>所以在item中使用Button或ImageButton时需要留意这个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setFocusable(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
<p>方法、如果item无法响应点击，可以尝试给Button或ImageButton设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setFocusable(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>listview</tag>
        <tag>iterm</tag>
        <tag>无法点击</tag>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro Linux 识别不到声音设备</title>
    <url>/2020/08/31/Manjaro-Linux-%E8%AF%86%E5%88%AB%E4%B8%8D%E5%88%B0%E5%A3%B0%E9%9F%B3%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<p>前段时间给两台机器装了 Manjaro，公司台式主机和 Redmi G 笔记本，使用的桌面环境是 KDE 发现两台机器都不能正常识别声音设备，笔记本是因为直接识别不到声卡，这个问题下一篇文章说一下解决方法，这里先说台式主机的问题。</p>
<p>使用的扬声器其实就是个 3.5 毫米的耳机，在给这台机器重装之前使用的是 deepin 系统，这个耳机是可以正常工作的（虽然不常用，但印象里是可以工作的），但是在 Manjaro 里 KDE 提示找不到声音设备，经过测试当把耳机插入主机后面的插口时是可以工作的，这也说明系统是可以识别到声卡的，谷歌了一圈发现可以给声卡驱动添加启动参数针对一些设备的兼容。这台机器的声卡是 <code>ALC887</code>，可以通过执行一下命令查看开机日志，并搜索 <code>audio</code> 来找出声卡型号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo journalctl -xb</span><br></pre></td></tr></table></figure>

<p>然后执行以下命令可以查看内核为这个声卡加载的驱动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># lspci -v</span><br><span class="line">00:1b.0 Audio device: Intel Corporation 8 Series&#x2F;C220 Series Chipset High Definition Audio Controller (rev 05)</span><br><span class="line">        Subsystem: Gigabyte Technology Co., Ltd Device a182 </span><br><span class="line">        Flags: bus master, fast devsel, latency 0, IRQ 31</span><br><span class="line">        Memory at f7d10000 (64-bit, non-prefetchable) [size&#x3D;16K]</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver in use: snd_hda_intel                                                                                                                                                                                                 </span><br><span class="line">        Kernel modules: snd_hda_intel</span><br></pre></td></tr></table></figure>

<p>可以发现使用的驱动是 snd_hda_intel，在内核 alsa 相关文档中可以找到有哪些选项：</p>
<p><a href="https://www.kernel.org/doc/html/v5.7/sound/hd-audio/models.html">https://www.kernel.org/doc/html/v5.7/sound/hd-audio/models.html</a></p>
<p>按照声卡型号搜索，找到对应的选项：</p>
<p><a href="https://www.kernel.org/doc/html/v5.7/sound/hd-audio/models.html#alc88x-898-1150-1220">https://www.kernel.org/doc/html/v5.7/sound/hd-audio/models.html#alc88x-898-1150-1220</a></p>
<p>之后编辑 <code>/etc/modprobe.d/alsa-base.conf</code> 文件（没有则创建），添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options snd-hda-intel model&#x3D;acer-aspire-4930g</span><br></pre></td></tr></table></figure>

<p>注意替换 <code>model</code> 选项的值到对应声卡驱动的可选值。修改完成之后保存退出并重启系统，如果仍然识别不到声音设备可以继续修改选项的值。</p>
<p>当终于找到一个合适的值让 alsa 可以识别播放设备了，但发现没有声音，可以执行命令 <code>sudo alsamixer</code> 命令手动取消对应设备的静音状态，处于静音状态的设备会标记为 <code>MM</code>，使用左右键切换到对应设备，按一下 <code>m</code> 键即可取消静音，取消静音之后 <code>MM</code> 会变成 <code>00</code></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>QPropertyAnimation不生效</title>
    <url>/2019/02/02/QPropertyAnimation%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<p>在 Qt 中实现动画的一种方便的做法就是使用 QPropertyAnimation 类, 构造 QPropertyAnimation 时设置目标 widget 和 property, 然后设置一下初始和结束的 property 值剩下的 Qt 就会帮我们做了.</p>
<p>常用的一个动画属性就是 “geometry”, 这个属性包含了 widget 的位置以及形状(矩形), 所以通过设置这个属性可以实现 widget 的位置和大小动画.</p>
<p>只是使用这个属性实现大小动画时要留意, widget 不能被设置固定的大小, 即下面这类函数不能调用, 否则 QPropertyAnimation 将无法调整目标 widget 的大小, 其中缘由细细想一下便可知道:</p>
<ul>
<li>setFixedSize</li>
<li>setFixedWidth</li>
<li>setFixedHeight</li>
</ul>
<p>但如果目的 widget 不得不设置一个初始大小的话可以调用如下这些函数:</p>
<ul>
<li>setMinimumSize</li>
<li>setMaxmumSize</li>
<li>setGeometry</li>
</ul>
]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>QPropertyAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title>QThread 的两种用法</title>
    <url>/2019/03/16/QThread-%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>QThread 官方文档中介绍了的两种用法：</p>
<ul>
<li>worker-object</li>
<li>subclass</li>
</ul>
<h1 id="worker-object"><a href="#worker-object" class="headerlink" title="worker-object"></a>worker-object</h1><p>引用官方文档中的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// worker 类</span></span><br><span class="line"><span class="comment">// 声明了一个信号，一个槽</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">const</span> QString &amp;parameter)</span> </span>&#123;</span><br><span class="line">        QString result;</span><br><span class="line">        <span class="comment">/* ... here is the expensive or blocking operation ... */</span></span><br><span class="line">        <span class="function">emit <span class="title">resultReady</span><span class="params">(result)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resultReady</span><span class="params">(<span class="keyword">const</span> QString &amp;result)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制器类</span></span><br><span class="line"><span class="comment">// 运行中主线程，用于管理 worker 对象和 QThread 对象</span></span><br><span class="line"><span class="comment">// 也声明了一个信号，一个槽</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    QThread workerThread;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Controller() &#123;</span><br><span class="line">        Worker *worker = <span class="keyword">new</span> Worker;</span><br><span class="line">        worker-&gt;moveToThread(&amp;workerThread);</span><br><span class="line">        <span class="built_in">connect</span>(&amp;workerThread, &amp;QThread::finished, worker, &amp;QObject::deleteLater);</span><br><span class="line">        <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;Controller::operate, worker, &amp;Worker::doWork);</span><br><span class="line">        <span class="built_in">connect</span>(worker, &amp;Worker::resultReady, <span class="keyword">this</span>, &amp;Controller::handleResults);</span><br><span class="line">        workerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    ~Controller() &#123;</span><br><span class="line">        workerThread.quit();</span><br><span class="line">        workerThread.wait();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleResults</span><span class="params">(<span class="keyword">const</span> QString &amp;)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operate</span><span class="params">(<span class="keyword">const</span> QString &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 worker 类中的槽函数是真正在子线程中工作的内容，而 worker 那个信号被发出时则表示工作完成，控制器中与之连接的槽函数的作用就是处理 worker 对象在完成工作之后使用其信号发出来的数据，控制器中的那个信号被发出时则是命令 worker 对象开始工作。因此需要使用下面的代码让 worker 对象在线程中开始工作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Note: 不要在主线程中以调用 worker-&gt;doWork() 函数的方式让 worker 开始工作</span></span><br><span class="line"><span class="comment">// 否则将会导致主线程阻塞在这个调用上，只能使用信号-槽的方式：</span></span><br><span class="line"></span><br><span class="line">Controller *controller = <span class="keyword">new</span> Controller;</span><br><span class="line">emit controller-&gt;operate(<span class="string">&quot;some string&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>看起来 worker 对象和 QThread 的对象并没有什么关系，那么 worker 对象是怎么在后台工作的呢？关键的一句代码是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">worker-&gt;moveToThread(&amp;workerThread);</span><br></pre></td></tr></table></figure>

<p>其中<code>moveToThread</code>方法是在 QObject 类中定义的，这意味着所有继承了 QObject 类的对象都可以调用这个方法来改变与自身关联的线程，使用下面的代码可以将 worker 对象再转移回主线程中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">worker-&gt;moveToThread(QApplication::instance()-&gt;thread());</span><br></pre></td></tr></table></figure>

<h1 id="subclass"><a href="#subclass" class="headerlink" title="subclass"></a>subclass</h1><p>引用官方文档中的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承 QThread 并重写其 run 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> :</span> <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        QString result;</span><br><span class="line">        <span class="comment">/* ... here is the expensive or blocking operation ... */</span></span><br><span class="line">        <span class="function">emit <span class="title">resultReady</span><span class="params">(result)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resultReady</span><span class="params">(<span class="keyword">const</span> QString &amp;s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动子线程的方法</span></span><br><span class="line"><span class="comment">// 一般位于主线程中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyObject::startWorkInAThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WorkerThread *workerThread = <span class="keyword">new</span> WorkerThread(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(workerThread, &amp;WorkerThread::resultReady, <span class="keyword">this</span>, &amp;MyObject::handleResults);</span><br><span class="line">    <span class="built_in">connect</span>(workerThread, &amp;WorkerThread::finished, workerThread, &amp;QObject::deleteLater);</span><br><span class="line">    workerThread-&gt;start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 subclass 方式是很不同的异步/多线程实现方法，当启动 WorkerThread 这个线程对象时，run 方法将在子线程中调用并执行，直到完成后发出 resultReady 信号将结果交给主线程处理，这没有什么需要解释的细节。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这两种用法的区别还是很大的，总的来说 worker-object 方式更为灵活，应用到的场景也较为广泛，如果需要在线程运行过程中不断地与之交互、通讯，则应该使用这种方式；subclass 在实现起来简单，但限制比较大在线程运行期间无法调整其资源状态（或者说不安全）。另外对 QThread 还有一些事情需要牢记，下面是官方的一些描述：</p>
<blockquote>
<p>It is important to remember that a QThread instance lives in the old thread that instantiated it, not in the new thread that calls run(). This means that all of QThread’s queued slots will execute in the old thread. Thus, a developer who wishes to invoke slots in the new thread must use the worker-object approach; new slots should not be implemented directly into a subclassed QThread.<br>When subclassing QThread, keep in mind that the constructor executes in the old thread while run() executes in the new thread. If a member variable is accessed from both functions, then the variable is accessed from two different threads. Check that it is safe to do so.</p>
</blockquote>
<p>大概意思是说，QThread 对象是始终位于初始化它的那个线程中的（一般是指主线程），这意味着 QThread 对象中的成员和方法是不能（最好不要）直接在主线程中访问的，这也是上面说道 subclass 方式限制比较大的原因。</p>
]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>QThread</tag>
      </tags>
  </entry>
  <entry>
    <title>Qtcreator Fakevim 映射 + 寄存器不生效</title>
    <url>/2021/09/10/Qtcreator-Fakevim-%E6%98%A0%E5%B0%84-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<p>在 QtCreator 使用 Fakevim 可以指定读取配置文件，在配置文件中映射按键，我发现当映射 <code>+</code> 寄存器时（也就是系统剪切板）不生效，比如下面这行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map &lt;Space&gt;yy &quot;+yy</span><br></pre></td></tr></table></figure>

<p>尝试了很多方法，比如转义：<code>\&quot;+yy</code> 等都不行，网上也搜不到相关问题，下载了 QtCreator 的源码后，分析 Fakevim 插件解析配置文件的部分，发现是一个 Bug，相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; qt-creator&#x2F;src&#x2F;plugins&#x2F;fakevim&#x2F;fakevimhandler.cpp</span><br><span class="line">&#x2F;&#x2F; bool FakeVimHandler::Private::handleExSourceCommand(const ExCommand &amp;cmd)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  remove comment</span><br><span class="line">int i &#x3D; nextline.lastIndexOf(&#39;&quot;&#39;);</span><br><span class="line">if (i !&#x3D; -1)</span><br><span class="line">    nextline &#x3D; nextline.remove(i, nextline.size() - i);</span><br></pre></td></tr></table></figure>

<p>原来是判断 <code>&quot;</code> 号是配置文件注释，将 <code>&quot;</code> 号开始到结尾的部分给删除了，已经给 QtCreator 官方提了 Issue，说实话我也没想到修复这个问题的好方法。</p>
<p>另辟蹊径，既然要判断 <code>&quot;</code> 号，而且代码里是判断最后一个 <code>&quot;</code> 号的位置，那就给它加上个行内注释，让它不删除命令内容就行，比如还是上面的命令，修改后如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map &lt;Space&gt;yy &quot;+yy &quot; placehoder commend for a Fakevim parse bug</span><br></pre></td></tr></table></figure>

<p>这样源码删除后面的注释后，剩下的就是原本想要执行的命令了，搞定 :)</p>
]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>qtcreator</tag>
        <tag>fakevim</tag>
        <tag>clipboard</tag>
        <tag>register</tag>
      </tags>
  </entry>
  <entry>
    <title>Redmi G manjaro 不能识别声卡</title>
    <url>/2020/09/20/Redmi-G-manjaro-%E4%B8%8D%E8%83%BD%E8%AF%86%E5%88%AB%E5%A3%B0%E5%8D%A1/</url>
    <content><![CDATA[<p>如题，解决方法：</p>
<ol>
<li>安装 <code>sof-firmware</code>：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S sof-firmware</span><br></pre></td></tr></table></figure></li>
<li>创建两个文件：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo touch &#x2F;etc&#x2F;alsa&#x2F;state-daemon.conf</span><br><span class="line">sudo touch &#x2F;var&#x2F;lib&#x2F;alsa&#x2F;asound.state</span><br></pre></td></tr></table></figure></li>
<li>重启之后应该就能识别到声卡了</li>
<li>如果没有声音，执行 <code>alsamixer</code>，将声卡取消静音，具体方法可以看： <a href="https://wiki.archlinux.org/index.php/Advanced_Linux_Sound_Architecture#Unmuting_the_channels">https://wiki.archlinux.org/index.php/Advanced_Linux_Sound_Architecture#Unmuting_the_channels</a></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redmi</tag>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>U盘+GRUB2引导PE或linux镜像</title>
    <url>/2016/05/04/U%E7%9B%98-GRUB2%E5%BC%95%E5%AF%BCPE%E6%88%96linux%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>详细看原文：<a href="http://blog.chinaunix.net/uid-14735472-id-4210990.html">链接</a></p>
<h1 id="安装grub2到u盘："><a href="#安装grub2到u盘：" class="headerlink" title="安装grub2到u盘："></a>安装grub2到u盘：</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo grub-install -v --target=i386-pc --boot-directory=/run/media/root/EXT4 /dev/sdb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意上面的参数:<br>–target,根据需要替换,参数值可以到/usr/lib/grub/下查看,每一个目录都可以作为参数值<br>–boot-directory,此参数的含义自行查看grub-install的help<br>具体看man grub-install使用方法</p>
</blockquote>
<h1 id="grub2间接引导WinPE"><a href="#grub2间接引导WinPE" class="headerlink" title="grub2间接引导WinPE"></a>grub2间接引导WinPE</h1><h2 id="U盘上建立WXPE目录，将WinPE文件放置入内："><a href="#U盘上建立WXPE目录，将WinPE文件放置入内：" class="headerlink" title="U盘上建立WXPE目录，将WinPE文件放置入内："></a>U盘上建立WXPE目录，将WinPE文件放置入内：</h2><p>目前网络上的WinPE到处都是，各种版本其实都差不多，主要需要如下5个文件：<br>LDRXPE  NTCOM  PE  SETUPLDR.BIN  WINPE.IS_</p>
<p>大致过程是：LDRXPE调用NTCOM和SETUPLDR.BIN读取PE找到WINPE.IS_镜像，加载WinPE。</p>
<h2 id="修改grub-cfg，加入winpe引导项："><a href="#修改grub-cfg，加入winpe引导项：" class="headerlink" title="修改grub.cfg，加入winpe引导项："></a>修改grub.cfg，加入winpe引导项：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;LDRXPE for WinCE (on /usb/fairy)&#x27;</span>&#123;</span><br><span class="line">insmod part_msdos</span><br><span class="line">insmod fat</span><br><span class="line"><span class="built_in">set</span> root=<span class="string">&#x27;hd0,msdos1&#x27;</span></span><br><span class="line">search --no-floppy --fs-uuid --<span class="built_in">set</span>=root 696C-0B1C</span><br><span class="line">ntldr /WXPE/LDRXPE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：此处的696C-0B1C为U盘分区uuid，其实这一句也可以不要，因为上面已经set root了，主要为了双保险。</p>
<p>这里的关键是：ntldr /WXPE/LDRXPE，而不是chainloader或者linux，我用后者尝试了一周都不得成功，最后才发现了可以直接用ntldr命令，强大啊！！ </p>
<h1 id="grub2直接引导WinPE"><a href="#grub2直接引导WinPE" class="headerlink" title="grub2直接引导WinPE"></a>grub2直接引导WinPE</h1><p><strong>转自：<a href="http://www.librehat.com/grub2-boot-windows-pe-and-otheriso-file/">Librehat’s Blog</a></strong></p>
<p>GRUB2不支持GRUB4DOS那样的map操作来引导ISO文件，是长期困扰我的一个问题，在今天之前，我都很傻地用grub2引导grub4dos然后引导Windows PE……直到我膝盖中了一箭，看到这个帖子。下面好好整理了一下，希望本文也能帮助你彻底从GRUB4DOS升级换代到GRUB2！</p>
<p>关于在U盘上安装GRUB2引导器的教程请自行Google，太多这类文章和Wiki了。下面开始GRUB2引导ISO文件（特别是Windows PE和Windows安装光盘这种）的正题。</p>
<p>首先下载最新版的：<a href="https://www.kernel.org/pub/linux/utils/boot/syslinux/">Syslinux</a>，解开压缩包，memdisk文件夹下面有一个memdisk文件（没有任何扩展名），把memdisk文件复制到U盘boot文件夹下（随便你放在哪，这里我是放倒boot这个文件夹下）。</p>
<p>编辑你U盘GRUB2的配置文件（一般是U盘/grub2/grub.cfg），在启动项那个区域添加以下几行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;Boot Windows 8 PE ISO&#x27;</span>&#123;</span><br><span class="line">        <span class="built_in">set</span> root=<span class="string">&#x27;(hd0,msdos1)&#x27;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&#x27;Loading Memdisk...&#x27;</span></span><br><span class="line">        <span class="comment">#insmod memdisk</span></span><br><span class="line">        linux16 /boot/memdisk iso raw</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&#x27;Loading ISO...&#x27;</span></span><br><span class="line">        initrd16 /boot/Win8PE.iso</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，其实关键就是memdisk后面的raw参数！感兴趣的自己看Syslinux的Wiki，我这段代码引导的是U盘boot文件夹下的Win8PE.iso，请修改成你自己的具体情况。</p>
<p>借助MEMDISK（几十KB的文件），GRUB2就能加载几乎任意的镜像文件（ISO、IMG等）了，相当于是「虚拟光驱」的作用？不过引导速度比GRUB4DOS稍微慢一点。</p>
<blockquote>
<p>不需要insmod memdisk这一句，因为用的是Syslinux的MEMDISK而不是GRUB2的memdisk模块。<br>为了规范，syslinux的MEMDISK全部大写，以便和GRUB2的memdisk模块区分开来。<br>两者重名了，刚查了一下，GRUB2的memdisk是用来读取core.img的。和syslinux的MEMDISK完全不同……<br>详见<a href="http://wiki.xtronics.com/index.php/Grub2_howto">http://wiki.xtronics.com/index.php/Grub2_howto</a></p>
</blockquote>
<h1 id="grub2间接引导Archlinux镜像"><a href="#grub2间接引导Archlinux镜像" class="headerlink" title="grub2间接引导Archlinux镜像"></a>grub2间接引导Archlinux镜像</h1><h2 id="解压Archlinux"><a href="#解压Archlinux" class="headerlink" title="解压Archlinux"></a>解压Archlinux</h2><p>最新安装镜像：archlinux-2012.11.01-dual.iso，复制其中的arch目录到U盘。</p>
<p>EFI  isolinux  loader这三个目录不需要。</p>
<h2 id="精简arch目录："><a href="#精简arch目录：" class="headerlink" title="精简arch目录："></a>精简arch目录：</h2><p>因为我要用的是32位的，而不用64位的所以删掉64位的相关目录和文件，包括：</p>
<p>删除arch/x86_64目录；<br>删除arch/boot目录下的：memtest  memtest.COPYING  syslinux  x86_64<br>修改arch/aitab，注释掉x86_64的两行。</p>
<p>当然你的空间足够大，这些都可以不做。</p>
<h2 id="修改grub-cfg，加入arch引导项："><a href="#修改grub-cfg，加入arch引导项：" class="headerlink" title="修改grub.cfg，加入arch引导项："></a>修改grub.cfg，加入arch引导项：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;archlinux-2012.11.01-setup (on /usb/fairy)&#x27;</span>&#123;</span><br><span class="line">insmod part_msdos</span><br><span class="line">insmod fat</span><br><span class="line"><span class="built_in">set</span> root=<span class="string">&#x27;hd0,msdos1&#x27;</span></span><br><span class="line">search --no-floppy --fs-uuid --<span class="built_in">set</span>=root 696C-0B1C</span><br><span class="line">linux/arch/boot/i686/vmlinuz archisobasedir=arch archisolabel=fairy</span><br><span class="line">initrd/arch/boot/i686/archiso.img</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：同上此处的696C-0B1C为U盘分区uuid，其实这一句也可以不要，因为上面已经set root了，主要为了双保险。</p>
<p>这里的关键是：archisobasedir=arch archisolabel=fairy ，这里的fairy是U盘的卷标，少了这句是不得成功的。 </p>
<h1 id="grub2直接引导Archlinux镜像"><a href="#grub2直接引导Archlinux镜像" class="headerlink" title="grub2直接引导Archlinux镜像"></a>grub2直接引导Archlinux镜像</h1><h2 id="x86-64："><a href="#x86-64：" class="headerlink" title="x86_64："></a>x86_64：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menuentry <span class="string">&quot;Archlinux-2013.05.01-dual.iso&quot;</span> --class iso &#123;</span><br><span class="line">  <span class="built_in">set</span> isofile=<span class="string">&quot;/archives/archlinux-2013.05.01-dual.iso&quot;</span></span><br><span class="line">  <span class="built_in">set</span> partition=<span class="string">&quot;6&quot;</span></span><br><span class="line">  loopback loop (hd0,<span class="variable">$partition</span>)/<span class="variable">$isofile</span></span><br><span class="line">  linux (loop)/arch/boot/x86_64/vmlinuz archisolabel=ARCH_201305 img_dev=/dev/sda<span class="variable">$partition</span> img_loop=<span class="variable">$isofile</span> earlymodules=loop</span><br><span class="line">  initrd (loop)/arch/boot/x86_64/archiso.img</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="i686"><a href="#i686" class="headerlink" title="i686"></a>i686</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menuentry <span class="string">&quot;Archlinux-2013.05.01-dual.iso&quot;</span> --class iso &#123;</span><br><span class="line">  <span class="built_in">set</span> isofile=<span class="string">&quot;/archives/archlinux-2013.05.01-dual.iso&quot;</span></span><br><span class="line">  <span class="built_in">set</span> partition=<span class="string">&quot;6&quot;</span></span><br><span class="line">  loopback loop (hd0,<span class="variable">$partition</span>)/<span class="variable">$isofile</span></span><br><span class="line">  linux (loop)/arch/boot/i686/vmlinuz archisolabel=ARCH_201305 img_dev=/dev/sda<span class="variable">$partition</span> img_loop=<span class="variable">$isofile</span> earlymodules=loop</span><br><span class="line">  initrd (loop)/arch/boot/i686/archiso.img</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="grub2引导Ubuntu-liveCD"><a href="#grub2引导Ubuntu-liveCD" class="headerlink" title="grub2引导Ubuntu liveCD"></a>grub2引导Ubuntu liveCD</h1><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>ubuntu-12.04-desktop-i386.iso到U盘根目录，当然为了根目录干净放到iso或者其他目录也可以，以下做对应修改。</p>
<h2 id="修改grub-cfg，加入ubuntu引导项："><a href="#修改grub-cfg，加入ubuntu引导项：" class="headerlink" title="修改grub.cfg，加入ubuntu引导项："></a>修改grub.cfg，加入ubuntu引导项：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;ubuntu-12.04-desktop-i386.iso&#x27;</span> &#123;</span><br><span class="line">insmod fat</span><br><span class="line">insmod loopback</span><br><span class="line">insmod iso9660</span><br><span class="line">loopback loop (hd0,1)/ubuntu-12.04-desktop-i386.iso</span><br><span class="line"><span class="built_in">set</span> root=(loop)</span><br><span class="line">linux /casper/vmlinuz boot=casper iso-scan/filename=/ubuntu-12.04-desktop-i386.iso noprompt noeject locale=zh_CN.UTF-8 --</span><br><span class="line">initrd /casper/initrd.lz</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>hd0,1 指得是U盘第一分区，我这里只有一个分区。</p>
<p>iso-scan/filename=/ubuntu-12.04-desktop-i386.iso这里要注意ubuntu前面的“/”，如果找不到文件会出现can’t open /dev/sr0错误。</p>
<p>locale=zh_CN.UTF-8 是设置中文环境，很多人引导成功却是英文环境的，加上这条就可以了。 </p>
<h2 id="安装ubuntu时需要卸载"><a href="#安装ubuntu时需要卸载" class="headerlink" title="安装ubuntu时需要卸载"></a>安装ubuntu时需要卸载</h2><p>ubuntu的iso镜像顺利引导,进入 ubuntu的live cd桌面,桌面上有 install ubuntu的字样,和光盘启动时的样子一模一样，不过与光盘安装有一点不同，也很重要，就是之前我们挂载了iso设备，现在要卸载它，不然会出现分区表问题。在终端里输入： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo umount -l /isodevice</span><br></pre></td></tr></table></figure>

<h1 id="grub直接启动xiaopanOS"><a href="#grub直接启动xiaopanOS" class="headerlink" title="grub直接启动xiaopanOS"></a>grub直接启动xiaopanOS</h1><p>假如xiaopanOS.iso 在C盘根目录，那就是sda1，根据自己实际更改<br>把xiaopanOS.iso 里的tce文件夹解压到C盘根目录,也就是C:\tce</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> iso=<span class="string">&#x27;(hd0,msdos1)/xiaopanOS-0.3.2.iso&#x27;</span></span><br><span class="line">loopback loop <span class="variable">$iso</span></span><br><span class="line">linux (loop)/boot/vmlinuz quiet waitusb=5 tce=sda1/tce</span><br><span class="line">initrd (loop)/boot/tinycore.gz</span><br><span class="line">boot</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>grub</tag>
        <tag>u盘</tag>
        <tag>iso</tag>
        <tag>镜像</tag>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewPager相关笔记</title>
    <url>/2016/05/04/ViewPager%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>只有步骤，备用</p>
<h1 id="ViewPager-PagerAdapter"><a href="#ViewPager-PagerAdapter" class="headerlink" title="ViewPager-PagerAdapter"></a>ViewPager-PagerAdapter</h1><h2 id="布局控件"><a href="#布局控件" class="headerlink" title="布局控件"></a>布局控件</h2><p>在activity的布局文件中添加控件，控件标记名称为：<br>android.support.v4.view.ViewPager<br>有两个子控件：<br>android.support.v4.view.PagerTitleStrip（会在tab标题的上面，但是不知道怎么随着页面的左右滚动切换，所以暂时不知道如何使用这个控件）<br>android.support.v4.view.PagerTabStrip（每个tab页面的标题，会随着页面的左右滚动切换）</p>
<p>另外还有各个页面的布局文件，和平时的页面写法一样，不说了</p>
<h2 id="获取控件对象并操作"><a href="#获取控件对象并操作" class="headerlink" title="获取控件对象并操作"></a>获取控件对象并操作</h2><p>在activity中使用findViewById()获取到控件的对象<br>上面说了因为不知道PagerTitleStrip如何自动切换，所以暂时不使用这个控件，并且PagerTabStrip也足够了<br>获取到PagerTabStrip的对象，使用其方法可以设置tab标题指示器的样式<br>获取到ViewPager的对象，主要使用其setAdapter()方法</p>
<h2 id="生成各个页面"><a href="#生成各个页面" class="headerlink" title="生成各个页面"></a>生成各个页面</h2><p>使用LayoutInflater对象的inflate()方法，加载各个页面的布局文件，获取到各个页面View类型的对象<br>然后把这些获取到的页面对象放到一个<code>ArrayList&lt;View&gt;</code>里面去，等下提供数据给适配器<br>另外，把每个页面的tab标题，放到一个<code>ArrayList&lt;String&gt;</code>里面去，也提供给适配器</p>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>写一个类继承PagerAdapter，主要重写PagerAdapter的以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取页面数量</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> myListViews.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个不清楚作用，但也必须重写，重写内容如下</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewFromObject</span><span class="params">(View arg0, Object arg1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">return</span> arg0==arg1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化的作用吧，在这里添加页面到页面容器</span></span><br><span class="line"><span class="comment">//父类还有另一个重载的方法(参数不同)，重写任意一个应该都可以</span></span><br><span class="line"><span class="comment">//myListViews是上面提到的ArrayList&lt;View&gt;，里面存放View类型的页面的对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    container.addView(myListViews.get(position));</span><br><span class="line">    <span class="keyword">return</span> myListViews.get(position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁、去掉页面</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    container.removeView(myListViews.get(position));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这里添加标题数据到标题容器</span></span><br><span class="line"><span class="comment">//myListPagerTabs是上面提到的ArrayList&lt;String&gt;，里面存放的是String类型的页面标题</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharSequence <span class="title">getPageTitle</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">return</span> myListPagerTabs.get(position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好适配器类之后就可以使用ViewPager对象的setAdapter()方法绑定上去了</p>
<h1 id="ViewPager-FragmentPagerAdapter"><a href="#ViewPager-FragmentPagerAdapter" class="headerlink" title="ViewPager-FragmentPagerAdapter"></a>ViewPager-FragmentPagerAdapter</h1><p><strong>基本和ViewPager+PagerAdapter一样，只是需要写几个fragment类和对应的页面的布局文件，每一个页面都是一个fragment，这些学习过fragment相关的知识就会了</strong></p>
<p><strong>不一样的地方：</strong><br>1、上面的<code>ArrayList&lt;Fragment&gt;</code>，里面存放的东西也就是你写的fragment的对象了<br>2、重写父类FragmentPagerAdapter的具体方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只需要重写下面三个就行了</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> arg0)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">return</span> myListViews.get(arg0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">return</span> myListViews.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharSequence <span class="title">getPageTitle</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">return</span> myListTabs.get(position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>ViewPager</tag>
        <tag>PagerAdapter</tag>
        <tag>FragmentPagerAdapter</tag>
      </tags>
  </entry>
  <entry>
    <title>adt-sdk-tools-eclipse-java版本关系</title>
    <url>/2016/04/22/adt-sdk-tools-eclipse-java%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>图片、反正这东西只是查看、不需要复制粘贴<br><img src="version.png" alt="version"></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>sdk</tag>
        <tag>adt</tag>
      </tags>
  </entry>
  <entry>
    <title>android中使用intent来实现Activity带数据跳转</title>
    <url>/2016/04/22/android%E4%B8%AD%E4%BD%BF%E7%94%A8intent%E6%9D%A5%E5%AE%9E%E7%8E%B0Activity%E5%B8%A6%E6%95%B0%E6%8D%AE%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="为什么要使用startActivityForResult"><a href="#为什么要使用startActivityForResult" class="headerlink" title="为什么要使用startActivityForResult"></a>为什么要使用startActivityForResult</h2><p>大家都知道startActivity()是用来切换跳转Activity的,如果想要在另个Activity中出书数据的话,只需要在源activity中使用intent.putExtra()方法传出数据,在对应activity中使用intent.get**Extra()方法接收数据就行了</p>
<p>那么startActivityForResult()方法呢,它也是用来带数据跳转activity的,可是这两个方法具体有什么区别呢？<br>这就要说说带数据跳转的方向了,</p>
<p>第一个方法只能把数据发送过去,可是如果子activity需要再传送回一些数据呢？<br>你可能会说,在子activity中使用intent.putExtra()方法把数据写入,在父activity中写入get*方法就行了嘛,</p>
<p>可是,这个父activity中的get方法要写在哪儿呢？写在onCreate方法中?</p>
<p>那么问题就来了,如果你在父activity中的onCreate方法中写入了get*方法来读取(获得)数据,</p>
<p>那么就意味着你一启动父activity就会执行get*方法(因为第一个执行的方法就是onCreate),而父activity是主方法,它必定是程序第一个执行的activity,</p>
<p>也就是说,此时还没有执行子activity,也就没有数据通过intent传过来,所以在执行onCreate时,执行到get*方法时就会读不到任何数据,</p>
<p>而且还会在每次启动activity时,不管需不需要从子activity接受数据都多此一举的执行一遍get*方法,来获取数据,</p>
<p>这样虽然可以实现从子activity中得到返回的数据,但却是不理想的,不正确的</p>
<h2 id="startActivityForResult"><a href="#startActivityForResult" class="headerlink" title="startActivityForResult"></a>startActivityForResult</h2><p>那么到底该怎么让父activity获取到从子activity传回的数据呢？</p>
<p>这就是第二个方法：startActivityFoResult()方法的作用了</p>
<p>下面具体说说这个方法是怎么实现把子activity传回的数据读取过来的</p>
<p>先看看这个方法的参数：startActivityForResult(Intent intent,int requestCode)</p>
<p>发现第一个参数是Intent类型,这个就不必多说了,看看第二个int型的,看字义是“请求码”,其实作用也就是请求码,这个具体在下面说,</p>
<p>只要你使用了startActivityForResult(),那么就要在这个类中添加一个onActivityResult(int requestCode ,int resultCode ,Intent intent)这个方法,也就是让这个类重写Activity.onActivityResult(int requestCode, int resultCode, Intent data){}方法，</p>
<p><font color=red>这里要注意，不要和PreferenceManager.OnActivityResultListener这个接口弄混了！实现这个接口也要重写这个接口的onActivityResult()方法，而且这个接口的方法和Activity.onActivityResult()参数是一样的，但返回不同！</font></p>
<p>你可以称它为：回调方法(子activity回调父activity的方法),</p>
<p>当然你也可以不添加(或方法体为空),那也就代表你不需要对子activity传回的数据进行操作,</p>
<p>反之如果你要想对子activity传回的数据进行操作,那么把方法体写在这个方法中即可,</p>
<p>这个方法如同onCreate()一样是这个类的成员方法,也就是说这个方法不在onCreate方法中(这样就避免了一启动这个activity就执行get*方法),</p>
<p>这个方法有什么用呢,你可以理解为它是用来监视子activity的方法,只要子activity一结束(调用了finish()方法),它就会被执行,这样就实现了“回调”这一功能</p>
<p>下面看看这个方法的参数：</p>
<ul>
<li><p>int requestCode：与startActivityForResult(Intent intent,int requestCode)方法中的int requestCode参数对应,可以理解为请求码</p>
</li>
<li><p>int resultCode：见名知意,结果码,这个是在子activity中设置的</p>
</li>
<li><p>Intent intent：这个就不必多说了</p>
</li>
</ul>
<h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><p>接着我们来看看这几个参数的具体作用,</p>
<ul>
<li>int requestCode,请求码,它与父activity中的startActivityForResult(Intent intent,int requestCode)方法中的int requestCode参数对应,</li>
</ul>
<p>用它来判断是从父activity中哪个组件请求进入子activity的,因为父activity中可能有多个按钮或其他组件都可以发出进入新的子activity的请求,</p>
<p>而onActivityResult()方法在父activity中只有一个,所以就可以(需要)来标记清楚</p>
<ul>
<li>int resultCode,结果码,它也是起到标记的作用,它与子activity中使用setResult(int resultCode,Intent intent)方法来设置的resultCode参数对应,</li>
</ul>
<p>那么它的作用也就和子activity有关,用它可以来判断是哪个子activity在结束后来回调这个回调方法的,因为父activity可能需要跳转到多个不同的子activity</p>
<p>而onActivityResult()方法在父activity中只有一个,所以就可以(需要)来标记清楚</p>
<ul>
<li>Intent intent,请求执行回调方法的intent</li>
</ul>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>大体都说完了,下面给出一个java代码来直观的看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父activity核心代码：</span></span><br><span class="line">　Button button1=(Button)findViewById(R.id.button1);</span><br><span class="line">　Button button2=(Button)findViewById(R.id.button2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//onCreate核心代码：</span></span><br><span class="line">  onCreate()&#123;</span><br><span class="line">      <span class="comment">//为按钮1设置监听，放入名为data1的数据100，设置请求吗为1</span></span><br><span class="line">      button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            onClick()&#123;</span><br><span class="line">                  Intent intent1=<span class="keyword">new</span> Intent();</span><br><span class="line">                  intent.setClass(<span class="keyword">this</span>, one.class);</span><br><span class="line">                  intent.putExtra(<span class="string">&quot;data1&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line">                  startActivityForResult(intent , <span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//为按钮2设置监听，放入名为data2的数据200，设置请求吗为2</span></span><br><span class="line">       button2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            onClick()&#123;</span><br><span class="line">                  Intent intent2=<span class="keyword">new</span> Intent();</span><br><span class="line">                  intent.setClass(<span class="keyword">this</span>, two.class);</span><br><span class="line">                  intent.putExtra(<span class="string">&quot;data2&quot;</span>, <span class="string">&quot;200&quot;</span>);</span><br><span class="line">                  startActivityForResult(intent , <span class="number">2</span>);</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//回调方法</span></span><br><span class="line">  onActivityResult(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent intent)&#123;</span><br><span class="line">      <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, intent);</span><br><span class="line">      <span class="keyword">switch</span>(requestCode)&#123;<span class="comment">//判断父activity中的哪个按钮</span></span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//如果是按钮1</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//如果是按钮2</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span>(resultCode)&#123;<span class="comment">//判断是哪个子activity</span></span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//如果是子activity1</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//如果是子activity2</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子activity1:one.java核心代码</span></span><br><span class="line"></span><br><span class="line">Button button1=(Button)findViewById(R.id.button1);</span><br><span class="line"></span><br><span class="line">    onCreate()&#123;</span><br><span class="line">        <span class="comment">//为按钮1设置监听，设置结果吗为1</span></span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">              onClick()&#123;</span><br><span class="line">                    setResult(<span class="number">1</span>,intent);</span><br><span class="line">                    finish();</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************************************************************</span></span><br><span class="line"><span class="comment">//子activity2:two.java核心代码</span></span><br><span class="line"></span><br><span class="line">Button button1=(Button)findViewById(R.id.button1);</span><br><span class="line"></span><br><span class="line">    onCreate()&#123;</span><br><span class="line">        <span class="comment">//为按钮1设置监听，设置结果吗为2</span></span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">              onClick()&#123;</span><br><span class="line">                    setResult(<span class="number">2</span>,intent);</span><br><span class="line">                    finish();</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>intent</tag>
      </tags>
  </entry>
  <entry>
    <title>android关闭手机实体按键开启虚拟按键</title>
    <url>/2016/04/23/android%E5%85%B3%E9%97%AD%E6%89%8B%E6%9C%BA%E5%AE%9E%E4%BD%93%E6%8C%89%E9%94%AE%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE/</url>
    <content><![CDATA[<p>注意实体按键和虚拟按键的区别<br>使用的是android4.2版本，硬件：mt6589<br><font color=red><strong>以下操作都需要root权限！</strong></font></p>
<h1 id="关闭实体按键功能"><a href="#关闭实体按键功能" class="headerlink" title="关闭实体按键功能"></a>关闭实体按键功能</h1><p>包括:菜单,返回,home,最近</p>
<p>使用root文件管理器，如RE文件管理器<br>在<code>/system/usr/keylayout/Generic.kl</code>文件中搜索menu，<br>注意搜索结果应该是只有menu这一个单词，而不是包含menu的单词</p>
<p>搜索到后在这一行的开头，添加上一个英文的符号：‘#’<br>也就是把这一行注释掉的意思！</p>
<p>返回键：back<br>同理、同上</p>
<p>我的手机菜单，home，返回键所对应的键值为(仅供参考)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">139</span>    MENU</span><br><span class="line"><span class="number">158</span>    BACK</span><br><span class="line"><span class="number">172</span>    HOME</span><br></pre></td></tr></table></figure>
<p>修改之后保存重启手机、被你注释掉的对应的实体功能键就失效了，点击没有任何反应<br>如果不成功可以尝试注释掉其他的行</p>
<p>这只是关掉功能、但背光灯还是会亮的</p>
<h1 id="关闭背光灯"><a href="#关闭背光灯" class="headerlink" title="关闭背光灯"></a>关闭背光灯</h1><p>还是RE文件管理器<br>在<code>/sys/class/leds/button-backlight/brightness</code>文件中、<br>把其中的数字改为0、背光灯就不亮了</p>
<p>如果没有对应的路径、可以尝试在类似的其他路径中搜索</p>
<p>这种方法在关机重启之后会失效、也就是说在手机重启之后背光灯就又亮了<br>上面关闭功能的方法是永久生效的</p>
<p>如果不想每次重新开机后都来这个路径下修改文件、可以手动写一个shell脚本、<br>将下面的代码复制保存为<code>brightnessOFF.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/system/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> 0&gt;/sys/class/leds/button-backlight/brightness</span><br><span class="line">chown root:root /sys/class/leds/button-backlight/brightness</span><br><span class="line">chmod 777 /sys/class/leds/button-backlight/brightness</span><br></pre></td></tr></table></figure>
<p>用RE文件管理器点击这个brightnessOFF.sh、弹出提示框、点击执行即可、立即生效<br>如果嫌这样还麻烦、那就需要点专业知识了<br>需要把上面的代码追加到安卓系统开机时自动执行的脚本文件中、<br>如：<code>/etc/install-recovery.sh或/etc/inti.goldfish.sh</code><br>或者自己修改内核以支持init.d、然后把这个脚本文件放在/etc/init.d目录中<br>注意可执行权限、也可以实现开机自动执行</p>
<h1 id="开启虚拟按键"><a href="#开启虚拟按键" class="headerlink" title="开启虚拟按键"></a>开启虚拟按键</h1><p>RE文件管理器, <code>/system/build.prop</code>文件</p>
<p>先在文件中搜索： <code>qemu.hw.mainkeys</code></p>
<p>如果已存在，将其修改为：<code>qemu.hw.mainkeys=0</code><br>如果不存在，则手动添加：<code>qemu.hw.mainkeys=0</code>添加位置随意</p>
<p>注意行首不能有`#‘符号！这个注释掉这一行的意思！</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>实体按键</tag>
        <tag>虚拟按键</tag>
      </tags>
  </entry>
  <entry>
    <title>android获取屏幕像素和密度</title>
    <url>/2016/05/04/android%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E5%83%8F%E7%B4%A0%E5%92%8C%E5%AF%86%E5%BA%A6/</url>
    <content><![CDATA[<blockquote>
<p>用来测试的虚拟机是320*480像素mdpi的<br>总结了以下三种方法</p>
</blockquote>
<p>(一)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point point =<span class="keyword">new</span> Point();</span><br><span class="line">getWindowManager().getDefaultDisplay().getSize(point);</span><br><span class="line">point.x;<span class="comment">//(320)</span></span><br><span class="line">point.y;<span class="comment">//(480)</span></span><br></pre></td></tr></table></figure>
<p>(二)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DisplayMetrics metrics=<span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">getWindowManager().getDefaultDisplay().getMetrics(metrics);</span><br><span class="line">metrics.widthPixels;<span class="comment">//(320)</span></span><br><span class="line">metrics.heightPixels;<span class="comment">//(480)</span></span><br><span class="line">metrics.xdpi;<span class="comment">//(160.0)</span></span><br><span class="line">metrics.ydpi;<span class="comment">//(160.0)</span></span><br><span class="line">metrics.density;<span class="comment">//(1.0)</span></span><br><span class="line">metrics.densityDpi;<span class="comment">//(160)</span></span><br></pre></td></tr></table></figure>
<p>(三)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DisplayMetrics metrics2=getResources().getDisplayMetrics();</span><br><span class="line">metrics2.widthPixels;<span class="comment">//(320)</span></span><br><span class="line">metrics2.heightPixels;<span class="comment">//(480)</span></span><br><span class="line">metrics2.xdpi;<span class="comment">//(160.0)</span></span><br><span class="line">metrics2.ydpi;<span class="comment">//(160.0)</span></span><br><span class="line">metrics2.density;<span class="comment">//(1.0)</span></span><br><span class="line">metrics2.densityDpi;<span class="comment">//(160)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当不是在activity中时，就不能直接用getWindowManager()等方法了，这时可以用Context.getSystemService(Context.WINDOW_SERVICE)方法，其他的类似</p>
</blockquote>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>像素</tag>
        <tag>密度</tag>
      </tags>
  </entry>
  <entry>
    <title>archlinux+xfce4+lightdm+uefi个人安装记录</title>
    <url>/2016/05/04/archlinux-xfce4-lightdm-uefi%E4%B8%AA%E4%BA%BA%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p><strong><font color=red>本文篇幅较长，最好通过文章内容上面的目录进行查看，否则很容易迷失在一个又一个的步骤中</font></strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>前言：</strong><br>在中文+英文arch-wiki的指导下，大概经过了将近十次的格式化+重装，终于满意了，这个过程中也了解了linux新的系统服务管理机制:systemd(systemclt)，<br>不说废话了，开始安装步骤<br><font color=red>折腾日期为:2015-4-28到2015-5-??</font><br>arch更新迅速，如果要参考本文，自行留意日期，也可以自己去arch-wiki去看官方教程：<a href="https://wiki.archlinux.org/index.php/Beginners%27_guide_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#.E9.85.8D.E7.BD.AE.E7.BD.91.E7.BB.9C">arch-wiki-Beginners’guide</a></p>
</blockquote>
<blockquote>
<p><font color=red>本文将简略的说一下步骤，主要说我在安装过程中出现的问题！<br>所以如果你是对大概的linux命令都不熟悉的新手，本文也许不适合你，<br>你应该先去看arch-wiki，然后再来这里看</font></p>
</blockquote>
<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><blockquote>
<p>安装arch，是不能没有网络的，毕竟官方提供的是最小化安装镜像，只有核心linux和官方修改配置的脚本，其他的都要靠联网下载安装<br>网络配置这一步骤<strong>需要进行两次！</strong><br><strong>第一次</strong>是刚刚启动安装镜像时，这一次的网络配置生效区域是安装镜像所在的系统，而非你安装到硬盘上的系统，这个配置将会随着安装镜像系统的退出而清除！<br><strong>第二次</strong>是使用arch-chroot命令后切换到到真实的，安装在了硬盘上的系统！这第二次的网络配置，将会写到你将来要用的系统所在的硬盘分区上的配置文件中，所以只要你以后不再修改，那么它的生效区域是永久的！<br><strong>自行理解上文所提到的安装镜像所在的系统和真实系统的区别！这个不好说，说不清</strong></p>
</blockquote>
<p>arch官方推荐使用他们自己的netctl来作为网络管理工具,但是经过使用后我还是<strong>推荐使用networkmanager</strong>来作为管理工具,因为networkmanager不论在命令行还是图形界面都有简单的使用方法！</p>
<h2 id="使用netctl"><a href="#使用netctl" class="headerlink" title="使用netctl"></a>使用netctl</h2><p>如果你使用netctl那么将会有无线和有线两种大的联网方式，其中又各自细分出了几种不同的联网方式，**<font color=red>第一次配置安装镜像所在的系统时你只需要选择其中一种，让电脑能正常联网就行了！第二次为真实系统配置时再自行选择配置几种</font>**。具体配置方法看<a href="https://wiki.archlinux.org/index.php/Beginners%27_guide_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#.E9.85.8D.E7.BD.AE.E7.BD.91.E7.BB.9C">arch-wiki-Beginners’guide</a>这里不多说！<br>按照官方教程会启用dhcpcd守护进程、这会导致系统系统的DNS每次开机都被dhcpcd替换为自动获取的DNS配置文件：/etc/resolv.conf<br>如果按照官方教程配置netctl后，出现了能ping通域名(如：ping t.cn)，但使用pacman -Syy却无法联网时那么你就需要修改/etc/resolv.conf文件中的DNS：</p>
<figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tr><td class="code"><pre><span class="line">nameserver 8.8.4.4</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>
<h2 id="使用networkmanager"><a href="#使用networkmanager" class="headerlink" title="使用networkmanager"></a>使用networkmanager</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S networkmanager <span class="comment">#主程序</span></span><br><span class="line">pacman -S networkmanager-openconnect <span class="comment">#支持VPN（也可选networkmanager-openvpn/networkmanager-pptp/networkmanager-vpnc任意一个）</span></span><br><span class="line">pacman -S rp-pppoe <span class="comment">#支持 PPPoE/DSL 连接</span></span><br><span class="line">pacman -S network-manager-applet xfce4-notifyd <span class="comment">#图形前端</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：这些包是在xfce4下工作的，其他桌面环境看<a href="https://wiki.archlinux.org/index.php/NetworkManager_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#.E5.AE.89.E8.A3.85">arch-wiki-NetWorkManager</a></strong><br>在第一次配置的时候不需要安装图形前端！等arch-chroot切换到真实系统后，第二次配置网络时才安装所有！</p>
<h3 id="查看是否有多个网络管理-systemctl简单使用"><a href="#查看是否有多个网络管理-systemctl简单使用" class="headerlink" title="查看是否有多个网络管理(systemctl简单使用)"></a>查看是否有多个网络管理(systemctl简单使用)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看所有已启动的service</span></span><br><span class="line">systemctl --<span class="built_in">type</span> service</span><br></pre></td></tr></table></figure>
<p>查看是否有**<font color=red>netctl相关的</font>**守护进程存在，如果有则关闭并禁止自动启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop 进程名</span><br><span class="line">systemctl <span class="built_in">disable</span> 进程名</span><br><span class="line"><span class="comment">#比如：</span></span><br><span class="line">systemctl stop netctl.service</span><br><span class="line">systemctl <span class="built_in">disable</span> netctl.service</span><br><span class="line"><span class="comment">#查看所有已安装的service(未必已启动)</span></span><br><span class="line">systemctl list-unit-files</span><br><span class="line"><span class="comment">#查看进程状态</span></span><br><span class="line">systemctl status 进程名</span><br><span class="line"><span class="comment">#显示详细进程信息</span></span><br><span class="line">systemctl show 进程名</span><br><span class="line"><span class="comment">#查看某进程是否允许开机自启</span></span><br><span class="line">systemctl is-enabled 进程名</span><br></pre></td></tr></table></figure>

<h3 id="启动NetworkManager："><a href="#启动NetworkManager：" class="headerlink" title="启动NetworkManager："></a>启动NetworkManager：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start NetworkManager.service <span class="comment">#立即启动 NetworkManager</span></span><br><span class="line">systemctl <span class="built_in">enable</span> NetworkManager.service <span class="comment">#开机自动启用 NetworkManager</span></span><br><span class="line"><span class="comment">#配置安装镜像系统时只需要执行立即启动的命令</span></span><br><span class="line"><span class="comment">#真实系统最好都执行</span></span><br></pre></td></tr></table></figure>
<h3 id="同步源："><a href="#同步源：" class="headerlink" title="同步源："></a>同步源：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -Syy</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><font color=red>启动NetworkManager之后才可以执行命令来连接网络！！</font></strong></p>
</blockquote>
<h3 id="命令行的使用方法："><a href="#命令行的使用方法：" class="headerlink" title="命令行的使用方法："></a>命令行的使用方法：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wifi操作举例：</span></span><br><span class="line">nmcli dev wifi connect &lt;name&gt; password &lt;password&gt; <span class="comment">#连接到 WiFi 网络</span></span><br><span class="line">nmcli dev wifi connect &lt;name&gt; password &lt;password&gt; iface wlan1 [profile name] <span class="comment">#通过接口 wlan1 连接到 WiFi 网络:</span></span><br><span class="line">nmcli dev disconnect iface eth0 <span class="comment">#断开 WiFi 连接:</span></span><br><span class="line">nmcli con up uuid &lt;uuid&gt; <span class="comment">#通过一个已断开连接的接口重新连接:</span></span><br><span class="line">nmcli con show <span class="comment">#获得一份 UUID 列表:</span></span><br><span class="line">nmcli dev <span class="comment">#查看网络设备及其状态:</span></span><br><span class="line">nmcli r wifi off <span class="comment">#关闭 WiFi:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他操作如有线网可以使用帮助命令查看：</span></span><br><span class="line">nmcli <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#OBJECT和COMMAND可以用全称也可以用简称，最少可以只用一个字母，建议用头三个字母。</span></span><br><span class="line"><span class="comment">#OBJECT里面我们平时用的最多的就是connection和device，这里需要简单区分一下connection和device。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#device叫网络接口，是物理设备</span></span><br><span class="line"><span class="comment">#connection是连接，偏重于逻辑设置</span></span><br></pre></td></tr></table></figure>
<h3 id="图形界面使用方法："><a href="#图形界面使用方法：" class="headerlink" title="图形界面使用方法："></a>图形界面使用方法：</h3><p>这个就没必要说了，等安装好xfce桌面环境后菜单和面板项目里都有</p>
<h1 id="具体的安装步骤"><a href="#具体的安装步骤" class="headerlink" title="具体的安装步骤"></a>具体的安装步骤</h1><h2 id="u盘启动"><a href="#u盘启动" class="headerlink" title="u盘启动"></a>u盘启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#linux下</span></span><br><span class="line"><span class="comment">#首先确定好u盘的设备名(不是分区)，我的是/dev/sdb</span></span><br><span class="line">lsblk <span class="comment">#查看所有连接到系统的设备和分区状况</span></span><br><span class="line">dd <span class="keyword">if</span>=你arch镜像的绝对路径 of=/dev/sdb <span class="comment">#将镜像写入u盘</span></span><br><span class="line"><span class="comment">#windows下自己百度吧</span></span><br></pre></td></tr></table></figure>
<p>做好启动盘后以UEFI方式启动u盘即可</p>
<h2 id="对硬盘分区"><a href="#对硬盘分区" class="headerlink" title="对硬盘分区"></a>对硬盘分区</h2><p>使用parted工具，我的硬盘的/dev/sda</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">parted /dev/sda <span class="built_in">print</span> <span class="comment">#查看sda磁盘的分区表类型</span></span><br><span class="line">parted /dev/sda <span class="comment">#开始分区</span></span><br><span class="line"><span class="comment">#具体分区步骤不再赘述</span></span><br></pre></td></tr></table></figure>
<h2 id="格式化分区为linux可用分区"><a href="#格式化分区为linux可用分区" class="headerlink" title="格式化分区为linux可用分区"></a>格式化分区为linux可用分区</h2><p>我的硬盘分区情况：<br>sda1：efi(esp)分区<br>sda11：/根分区<br>sda8：/boot<br>sda10：/home<br>sda9：/swap</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.vfat -F32 /dev/sda1 <span class="comment">#格式化efi分区为fat32（如果是linux+windows双系统则不格式化此分区）</span></span><br><span class="line">mkfs.ext4 /dev/sda11 <span class="comment">#格式化根分区，下同</span></span><br><span class="line">mkfs.ext4 /dev/sda8</span><br><span class="line">mkfs.ext4 /dev/sda10</span><br><span class="line">mkswap /dev/sda9 <span class="comment">#格式化swap分区</span></span><br><span class="line">swapon /dev/sda9 <span class="comment">#启用swap分区</span></span><br></pre></td></tr></table></figure>
<h2 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h2><blockquote>
<p>注意: 不要在这里挂载 swap</p>
</blockquote>
<p>必须先挂载 / (root) 分区，其它目录都要在 / 分区中创建然后再挂载。<font color=red>在安装环境中用 /mnt 目录挂载根分区：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/sda11 /mnt</span><br></pre></td></tr></table></figure>
<p>接着挂载其他分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/home</span><br><span class="line">mount /dev/sda10 /mnt/home</span><br><span class="line">mkdir /mnt/boot</span><br><span class="line">mount /dev/sda8 /mnt/boot</span><br><span class="line"><span class="comment">#在挂载好的/boot分区中创建efi文件夹并挂载efi分区</span></span><br><span class="line">mkdir /mnt/boot/efi</span><br><span class="line">mount /dev/sda1 /mnt/boot/efi</span><br></pre></td></tr></table></figure>
<h2 id="选择镜像源"><a href="#选择镜像源" class="headerlink" title="选择镜像源"></a>选择镜像源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>
<p>将我国的镜像源(速度快的放前面,可以有多个)反注释：<br>Server = <a href="http://mirrors.163.com/archlinux/$repo/os/$arch">http://mirrors.163.com/archlinux/$repo/os/$arch</a><br>Server = <a href="http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch">http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</a></p>
<h2 id="安装基本系统"><a href="#安装基本系统" class="headerlink" title="安装基本系统"></a>安装基本系统</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacstrap -i /mnt base base-devel </span><br><span class="line"><span class="comment">#“-i”选项是是否选择包的意思，去掉则自动全部安装</span></span><br></pre></td></tr></table></figure>
<h2 id="生成-fstab"><a href="#生成-fstab" class="headerlink" title="生成 fstab"></a>生成 fstab</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab #可以用 -L 代替 -U，及lable和uuid</span><br><span class="line">nano /mnt/etc/fstab #查看是否正确</span><br></pre></td></tr></table></figure>
<h2 id="Chroot-并开始配置新系统"><a href="#Chroot-并开始配置新系统" class="headerlink" title="Chroot 并开始配置新系统"></a>Chroot 并开始配置新系统</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arch-chroot /mnt /bin/bash</span><br></pre></td></tr></table></figure>
<p>执行上面的命令后就会从安装镜像所在的系统切换到硬盘中的新系统（真实系统）</p>
<h2 id="Locale本地"><a href="#Locale本地" class="headerlink" title="Locale本地"></a>Locale本地</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nano /etc/locale.gen #反注释需要的本地化类型</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例如：<br>en_US.UTF-8 UTF-8 #英文<br>zh_CN.UTF-8 UTF-8 #中文</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">接着执行locale-gen以生成locale讯息</span></span><br><span class="line">locale-gen </span><br><span class="line"></span><br><span class="line">echo LANG=en_US.UTF-8 &gt; /etc/locale.conf #创建 locale.conf 并提交您的本地化选项</span><br></pre></td></tr></table></figure>
<blockquote>
<p>locale.gen文件中反注释的本地化选项为本系统所有的可选选项<br>执行locale-gen命令是提交并初始化<br>而locale.conf文件中的配置才是你真正为系统选中的选项</p>
</blockquote>
<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime #中国时区</span><br></pre></td></tr></table></figure>
<h2 id="硬件时间"><a href="#硬件时间" class="headerlink" title="硬件时间"></a>硬件时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hwclock --systohc --utc #将硬件时间设置为 UTC </span><br><span class="line">hwclock --systohc --localtime #将硬件时间设置为 localtime</span><br><span class="line"><span class="meta">#</span><span class="bash">命令自动生成 /etc/adjtime</span></span><br></pre></td></tr></table></figure>
<h2 id="Hostname主机名"><a href="#Hostname主机名" class="headerlink" title="Hostname主机名"></a>Hostname主机名</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo myhostname &gt; /etc/hostname</span><br><span class="line">nano /etc/hosts #修改hosts添加你的主机名</span><br></pre></td></tr></table></figure>
<h2 id="为硬盘中的系统配置网络"><a href="#为硬盘中的系统配置网络" class="headerlink" title="为硬盘中的系统配置网络"></a>为硬盘中的系统配置网络</h2><p>这次的配置将会永久生效不会因为关机重启而失效<br>具体步骤看文章开始位置：networkmanager的安装和使用</p>
<h2 id="设置-Root-密码"><a href="#设置-Root-密码" class="headerlink" title="设置 Root 密码"></a>设置 Root 密码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>

<h2 id="安装并配置-GRUB"><a href="#安装并配置-GRUB" class="headerlink" title="安装并配置 GRUB"></a>安装并配置 GRUB</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S dosfstools efibootmgr grub os-prober #安装需要的包</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=arch_grub --recheck </span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash">这一步：grub-mkconfig,可能会出错，不过不用管</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你想手动编辑grub.cfg或了解更多的关于grub安装和配置的方法<br>可以去看：<a href="https://wiki.archlinux.org/index.php/GRUB_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#UEFI.E7.B3.BB.E7.BB.9F">arch-wiki-GRUB</a></p>
</blockquote>
<h2 id="卸载分区并重启系统"><a href="#卸载分区并重启系统" class="headerlink" title="卸载分区并重启系统"></a>卸载分区并重启系统</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">umont -R /mnt</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>你应该重启到你安装的arch系统中，而不是u盘里的系统！</p>
<h1 id="进一步配置硬盘中的新系统"><a href="#进一步配置硬盘中的新系统" class="headerlink" title="进一步配置硬盘中的新系统"></a>进一步配置硬盘中的新系统</h1><h2 id="再次安装GRUB"><a href="#再次安装GRUB" class="headerlink" title="再次安装GRUB"></a>再次安装GRUB</h2><p>如果你在安装系统时，在执行grub-mkconfig自动生成grub.conf文件时出现了错误<br>或者你的多系统，但第一次安装GRUB时只有arch系统的启动项<br>那么就在这里从新安装一边grub就行了<br>具体方法同上面第一次安装GRUB</p>
<h2 id="新增日常使用的账户"><a href="#新增日常使用的账户" class="headerlink" title="新增日常使用的账户"></a>新增日常使用的账户</h2><p>添加一个名为：zhangsan的用户，并设置用户密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -m -g users -G audio,video,floppy,network,rfkill,scanner,storage,optical,power,wheel,uucp -s /bin/bash zhangsan</span><br><span class="line">passwd zhangsan</span><br></pre></td></tr></table></figure>
<p>选项含义：<br>-m：创建用户目录，本例中会创建/home/zhangsan文件夹<br>-g：设置用户的主组为users，也就是将用户添加到users组中，你可以先为自己创建一个组：<br>groupadd zhangsan<br>然后再执行添加用户的命令，users是默认已存在的组，如果你直接把users修改为zhangsan，而不新建zhangsan组，会提示组zhangsan不存在<br>-G：设置用户的附属组，也就是将用户添加到其他组，但这些组是附属组，如果不添加用户到相应的附属组，则用户没有附属组相应的权限<br>-s：设置用户的登录shell</p>
<blockquote>
<p><font color=red>注意：设置登录shell时，官方教程是这样的：<br>-s /usr/bin/bash<br>但是经过测试，设置为/usr/bin/bash是无法登录的！<br>害我搞了很久。。</font></p>
</blockquote>
<h2 id="安装xorg图形框架"><a href="#安装xorg图形框架" class="headerlink" title="安装xorg图形框架"></a>安装xorg图形框架</h2><p>详细看<a href="https://wiki.archlinux.org/index.php/Xorg_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#.E5.AE.89.E8.A3.85">arch-wiki-Xorg</a><br><strong>安装基本框架：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S xorg-server xorg-twm xorg-xclock xterm xorg-xinit</span><br></pre></td></tr></table></figure>
<p>xorg-xinit包提供了startx和xinti命令，startx和xinti命令的配置文件为：<br>**/etc/X11/xinit/xinitrc**<br>可以在此配置文件的末尾加上启动桌面环境或窗口管理器的命令，比如启动xfce4桌面环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exec startxfce4</span><br></pre></td></tr></table></figure>
<p>不过本文并没有采用startx的方式直接启动桌面环境，而是通过显示管理器(登录管理器)来启动桌面环境xfce4，具体后文再说。</p>
<p>具体的Xorg图形界面可以通过 /etc/X11/xorg.conf 或 /etc/xorg.conf 和位于 /etc/X11/xorg.conf.d/ 的配置文件进行配置。<br>Arch 在 /etc/X11/xorg.conf.d 提供了默认的配置文件。<br>大部分系统不需要任何配置就能正常使用。<br>用户可以创建自己的配置文件，需要以 XX- 开头(XX 是数字)并以.conf 结尾(例如 10 在 20 之前读取)。 </p>
<h2 id="笔记本安装触摸板驱动"><a href="#笔记本安装触摸板驱动" class="headerlink" title="笔记本安装触摸板驱动"></a>笔记本安装触摸板驱动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S xf86-input-synaptics</span><br></pre></td></tr></table></figure>
<p>其配置文件为：/etc/X11/xorg.conf.d 目录下 10-synaptics.conf 文件</p>
<h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><p>可以使用命令查看你的电脑的显卡信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lspci | grep VGA</span><br></pre></td></tr></table></figure>
<p>然后查看官方源中有哪些**<font color=red>开源驱动：</font>**</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -Ss xf86-video</span><br></pre></td></tr></table></figure>
<p>这样是查看官方元中有哪些nvidia驱动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -Ss nvidia</span><br></pre></td></tr></table></figure>
<p><strong>我的笔记本是双显卡：intel+nvidia</strong></p>
<h3 id="安装intel显卡开源驱动"><a href="#安装intel显卡开源驱动" class="headerlink" title="安装intel显卡开源驱动"></a>安装intel显卡开源驱动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S xf86-video-intel libva-intel-driver</span><br></pre></td></tr></table></figure>
<p>这样就行了，intel挺简单，但也意味着不如nvidia强大</p>
<p><strong><font color=red>开源和闭源驱动只能选择其中一个安装！！！</font></strong></p>
<h3 id="安装nvidia显卡开源驱动"><a href="#安装nvidia显卡开源驱动" class="headerlink" title="安装nvidia显卡开源驱动"></a>安装nvidia显卡开源驱动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S xf86-video-nouveau</span><br></pre></td></tr></table></figure>
<h3 id="安装nvidia显卡闭源驱动"><a href="#安装nvidia显卡闭源驱动" class="headerlink" title="安装nvidia显卡闭源驱动"></a>安装nvidia显卡闭源驱动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S nvidia</span><br></pre></td></tr></table></figure>
<h3 id="双显卡切换"><a href="#双显卡切换" class="headerlink" title="双显卡切换"></a>双显卡切换</h3><blockquote>
<p><strong><font color=red>最好等安装完X框架和桌面环境后再来配置这个！</font></strong></p>
</blockquote>
<h4 id="安装bumblebee-bbswtich等："><a href="#安装bumblebee-bbswtich等：" class="headerlink" title="安装bumblebee,bbswtich等："></a>安装bumblebee,bbswtich等：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S bumblebee bbswitch mesa xf86-video-intel nvidia ib32-nvidia-utils lib32-mesa-libgl</span><br></pre></td></tr></table></figure>
<h4 id="添加相关用户到-bumblebee-组："><a href="#添加相关用户到-bumblebee-组：" class="headerlink" title="添加相关用户到 bumblebee 组："></a>添加相关用户到 bumblebee 组：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpasswd -a user bumblebee</span><br><span class="line"><span class="meta">#</span><span class="bash">其中 user 是要添加的用户登录名</span></span><br></pre></td></tr></table></figure>
<h4 id="启动bumblebee服务-守护进程"><a href="#启动bumblebee服务-守护进程" class="headerlink" title="启动bumblebee服务(守护进程)"></a>启动bumblebee服务(守护进程)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> bumblebeed.service</span><br></pre></td></tr></table></figure>
<p>重启，以使组变更生效</p>
<h4 id="测试-Bumblebee-是否支持你的-Optimus-系统"><a href="#测试-Bumblebee-是否支持你的-Optimus-系统" class="headerlink" title="测试 Bumblebee 是否支持你的 Optimus 系统"></a>测试 Bumblebee 是否支持你的 Optimus 系统</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">optirun glxgears -info</span><br><span class="line"><span class="meta">#</span><span class="bash">或者：</span></span><br><span class="line">optirun glxspheres64</span><br><span class="line"><span class="meta">#</span><span class="bash">或者</span></span><br><span class="line">optirun glxspheres32</span><br><span class="line"><span class="meta">#</span><span class="bash">这三个只要任意一个能成功运行无报错中断即可证明bumblebee已经可以正常运行了</span></span><br></pre></td></tr></table></figure>
<h4 id="Bumblebee用法："><a href="#Bumblebee用法：" class="headerlink" title="Bumblebee用法："></a>Bumblebee用法：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">optirun [options] application [application-parameters]</span><br><span class="line"><span class="comment">#例如，用 Optimus 启动Windows程序:</span></span><br><span class="line">optirun wine application.exe</span><br><span class="line"><span class="comment">#另外，用 Optimus 打开NVIDIA设置面板:</span></span><br><span class="line">optirun -b none nvidia-settings -c :8</span><br></pre></td></tr></table></figure>
<h4 id="Bumblebee和optirun的关系"><a href="#Bumblebee和optirun的关系" class="headerlink" title="Bumblebee和optirun的关系"></a>Bumblebee和optirun的关系</h4><p>Bumblebee是管理独显的服务并不是命令，所以你不能直接执行“Bumblebee”来启动，并且上一步中它已经以服务方式启动了！<br>Bumblebee包中提供了optirun命令，optirun可以看作是Bumblebee这个服务对用户放出的接口！<br>用户通过<code>optirun 程序</code>来启动程序时可以让Bumblebee使用独显为启动的程序进行3D渲染！<br>其他不是通过optirum启动的程序则不使用独显！</p>
<h4 id="Bumblebee和bbswtich的关系和使用"><a href="#Bumblebee和bbswtich的关系和使用" class="headerlink" title="Bumblebee和bbswtich的关系和使用"></a>Bumblebee和bbswtich的关系和使用</h4><p>Bumblebee它的作用只是试图模拟 Optimus 技术的行为：<font color=red>当需要的时候，使用独立显卡进行渲染，不使用的时候让独显空闲，但不会禁用独显</font></p>
<p>这时就需要bbswtich了，bbswitch相当与是一种的电源管理，其目的是为了当bumblebee不再使用NVIDIA显卡时自动关闭NVIDIA显卡<br>如果已安装 bbswitch ，Bumblebee 守护进程启动时会自动检测到，不需要特别设置。<br>也可以这样做来确保系统加载bbswtich<br>在/etc/modules-load.d下新建bbswitch.conf，并修改为如下内容,这样每次启动都会加载bbswitch模块了:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bbswitch</span><br></pre></td></tr></table></figure>
<p>但是仅仅是加载是不够的，因为bbswitch的默认行为是保持显卡的开启状态， bumblebeed 启动时又并不禁用显卡，这就会导致开机后独显是开启状态，所以，在/etc/modprobe.d/下新建bbswitch.conf，并修改为如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这是bbswitch加载的参数，我们让其默认关闭独显</span></span><br><span class="line">options bbswitch load_state=0 unload_state=1</span><br></pre></td></tr></table></figure>
<p>另外，有时候有时候即便加载了我们配置如上的bbswitch，但是bbswitch却不能自动关闭显卡，是因为有些模块正在占用着独显，因此要禁掉一些模块<br>再在/etc/modprobe.d/下新建nouveau_blacklist.conf，并修改为如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br></pre></td></tr></table></figure>
<p>还有，bbswitch(系统)会在关机时关闭NVIDIA显卡，这可能可能会在下一次启动时初始化DVIDIA显卡异常或是在双系统的windows下识别不到nvidia显卡<br>有两种方法可以实现NVIDIA显卡总是在关机时被设置为启用状态：<br><strong>个人建议arch最好使用第一种</strong><br>第一种：添加如下systemd 服务: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先在系统服务库中创建nvidia-enable.service服务</span></span><br><span class="line">nano /usr/lib/systemd/system/nvidia-enable.service</span><br><span class="line"><span class="comment">#内容如下：</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Enable NVIDIA card</span><br><span class="line">DefaultDependencies=no</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/bin/sh -c <span class="string">&#x27;echo ON &gt; /proc/acpi/bbswitch&#x27;</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=shutdown.target</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后将服务设置为自动启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> nvidia-enable.service</span><br></pre></td></tr></table></figure>
<p>第二种：使用关机脚本<br>在/usr/lib/systemd/system-shutdown/下新建nvidia_card_enable.sh，<br>并修改为以下内容，记得加运行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span>  </span><br><span class="line">    reboot)  </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Enabling NVIDIA GPU&quot;</span>  </span><br><span class="line">        <span class="built_in">echo</span> ON &gt; /proc/acpi/bbswitch  </span><br><span class="line">    ;;  </span><br><span class="line">    *)  </span><br><span class="line"><span class="keyword">esac</span>  </span><br></pre></td></tr></table></figure>


<h3 id="禁用独显nvidia"><a href="#禁用独显nvidia" class="headerlink" title="禁用独显nvidia"></a>禁用独显nvidia</h3><p>从上一步中可以了解到bumblebe的作用的控制独显的何时、给哪个应用渲染的功能，它并不控制独显的关闭和激活<br>而负责独显的关闭和激活的是：bbswtich<br>所以，如果你不需要使用独显的3D功能，那么你可以单独只安装一个bbswtich来控制独显即可，不要安装bumblebe等其他包<br>具体如何配置bbswitch，你可以从上一步中提取关于bbswtich的配置步骤，照着做就行了</p>
<blockquote>
<p>你也可以看我的另一片文章<a href="http://blog.csdn.net/listener_ri/article/details/45290331">linux关闭nvidia独显的方法</a></p>
</blockquote>
<h2 id="测试Xorg是否正常启动"><a href="#测试Xorg是否正常启动" class="headerlink" title="测试Xorg是否正常启动"></a>测试Xorg是否正常启动</h2><p>安装玩xorg框架和显卡驱动后可以使用startx命令来测试图形框架是否可以正常启动<br><strong>只有图形框架正常后才能正常启动桌面环境xfce4和登录管理器lightdm</strong><br>首先重启，然后登录到tty命令行模式<br>执行startx命令<br>如果出现了画面：几个x终端还有x时钟和鼠标，那么就是安装成功了，可以接着安装桌面环境xfce4和登录管理器lightdm</p>
<h2 id="安装xfce4桌面环境"><a href="#安装xfce4桌面环境" class="headerlink" title="安装xfce4桌面环境"></a>安装xfce4桌面环境</h2><p>详细安装和配置看：<a href="https://wiki.archlinux.org/index.php/Xfce_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">arch-wiki-xfce4</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S xfce4 xfce4-goodies</span><br></pre></td></tr></table></figure>
<h2 id="安装LightDM登录管理器-显示管理器"><a href="#安装LightDM登录管理器-显示管理器" class="headerlink" title="安装LightDM登录管理器(显示管理器)"></a>安装LightDM登录管理器(显示管理器)</h2><p>详细安装和配置看<a href="https://wiki.archlinux.org/index.php/LightDM_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#.E5.90.AF.E7.94.A8_LightDM">arch-wiki-lighdm</a><br>我没有通过startx的方式启动桌面环境，而是使用了登录管理器lightdm<br>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S lightdm lightdm-gtk-greeter</span><br></pre></td></tr></table></figure>
<p>其配置文件为：<br>/etc/lightdm/lightdm.conf<br>安装好之后测试启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start lightdm.service</span><br></pre></td></tr></table></figure>
<p>如果正常就会看到熟悉的登录界面了，不过不要登录，现在只是测试lightdm是否可以正常启动<br>点击画面上的关机小图标，弹出关机对话，选择**<font color=red>注销!</font>**<br>注销之后就回到之前的tty命令行模式了，可以看到相关的启动信息<br>一切正常，所以设置lightdm为开机自动启动，这样以后开机就不会出现tty命令行界面了，而是直接进入登录界面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable lightdm.service</span><br></pre></td></tr></table></figure>
<p>之后你可以重启进入xfce4图形界面，然后在图形界面中使用终端来继续以下配置步骤，也可以不重启，直接继续</p>
<h2 id="安装alsa-utils配置声音"><a href="#安装alsa-utils配置声音" class="headerlink" title="安装alsa-utils配置声音"></a>安装alsa-utils配置声音</h2><p>arch系统默认已经安装了alsa-libs支持库，可以支持xfce4中的混音器来控制系统的音量或者静音<br>但是系统每次关机重启之后，默认的都是静音，你之前调的音量全部消失，解决方法：<br>安装alsa-utils:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S alsa-utils</span><br></pre></td></tr></table></figure>
<p>编辑下alsa的服务(服务脚本有问题，不能由systemctl管理)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nano /lib/systemd/system/alsa-state.service</span><br></pre></td></tr></table></figure>
<p>查看是否有”[Install]”(包含此字段)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>有的话就不用继续编辑了，没有的话在末尾加上上述字段，保存<br>然后启动服务，并允许其开机自启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start alsa-state.service</span><br><span class="line">systemctl enable alsa-state.service</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20150504150348283" alt="这里写图片描述"></p>
<blockquote>
<p>上图是我的设置，Internal Mic最好设置为静音</p>
</blockquote>
<h2 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S wqy-microhei ttf-dejavu</span><br></pre></td></tr></table></figure>
<h2 id="让系统使用中文"><a href="#让系统使用中文" class="headerlink" title="让系统使用中文"></a>让系统使用中文</h2><h3 id="全局性的汉化"><a href="#全局性的汉化" class="headerlink" title="全局性的汉化"></a>全局性的汉化</h3><p>不推荐全局汉化，这样可能会导致tty中无法汉化而出现乱码口口口<br>但我使用的是这种方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo LANG=zh_CN.UTF-8&gt;/etc/locale.conf</span><br></pre></td></tr></table></figure>
<h3 id="单独在图形界面启用中文locale"><a href="#单独在图形界面启用中文locale" class="headerlink" title="单独在图形界面启用中文locale"></a>单独在图形界面启用中文locale</h3><p>在用户各自的家目录下的<del>/.bashrc、</del>/.profile、<del>/.xinitrc或</del>/.xprofile中设置自己的用户环境，若文件不存在可以新建</p>
<blockquote>
<p>.bashrc: 每次终端时读取并运用里面的设置<br>.profile：每次启动系统的读取并运用里面的配置<br>.xinitrc: 每次startx启动X界面时读取并运用里面的设置<br>.xprofile: 每次使用lightdm等图形登录管理器时读取并运用里面的设置</p>
</blockquote>
<p>从上面所说的文件中你认为合适的文件，然后将下面的命令添加到文件末尾即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LANG=zh_CN.UTF-8</span><br><span class="line">export LANGUAGE=zh_CN:en_US</span><br></pre></td></tr></table></figure>
<p>结合本文，如果你不用全局性的汉化，而用这第二种方式的话，我个人推荐你在~/.xprofile文件中添加</p>
<h2 id="安装fcitx输入法"><a href="#安装fcitx输入法" class="headerlink" title="安装fcitx输入法"></a>安装fcitx输入法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S fcitx fcitx-im fcitx-cloudpinyin fcitx-configtool fcitx-googlepinyin fcitx-qt5</span><br></pre></td></tr></table></figure>
<p>安装之后配置变量以确保系统使用fcitx、或者自行禁用其他输入法自动启动、如：ibus</p>
<p>将下面的命令复制到下面说的三种情况中的文件的末尾：<br><font color=red><br>1：如果你使用显示管理器(如lightdm，gdm)进入桌面环境则使用家目录下的.xprofile文件，即：<del>/.xprofile<br>2：如果你使用startx命令进入桌面环境则使用家目录下的.xinitrc文件，即：</del>/.xinitrc<br>3：这种方法不推荐：使用/etc/profile文件，添加到此文件即意味着是系统级变量(上面两种情况是用户变量，不会影响到其他用户)，但这种方法可能会失败，导致部分应用无法启动fcitx，如gnome3.18中的gnome-terminal等<br>这三种情况任选其一，也可全部都配置上<br></font></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure>
<p>重启后就可以使用fcitx+谷歌输入法了，不过你也可以不现在重启接着往下配置</p>
<h2 id="如果启动xfce4桌面环境后显示不正常"><a href="#如果启动xfce4桌面环境后显示不正常" class="headerlink" title="如果启动xfce4桌面环境后显示不正常"></a>如果启动xfce4桌面环境后显示不正常</h2><p>具体表现为：<br>窗口没有关闭按钮什么的框架<br>窗口无法移动<br>没有桌面背景（一片黑色）<br>在桌面上点击右键鼠标无反映<br>那么，解决方法是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xfwm4 --daemon</span><br><span class="line">xfwm4 --replace</span><br></pre></td></tr></table></figure>
<h2 id="安装视频播放器mplayer-gnomeMplayer前端"><a href="#安装视频播放器mplayer-gnomeMplayer前端" class="headerlink" title="安装视频播放器mplayer+gnomeMplayer前端"></a>安装视频播放器mplayer+gnomeMplayer前端</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S mplayer #主程序</span><br><span class="line">pacman -S gnome-mplayer #gnome图形前端</span><br><span class="line">pacman -S gecko-mediaplayer #控制firefox和chromium的影音播放(依赖gnome-mplayer)</span><br></pre></td></tr></table></figure>
<p>全局配置：<br>/etc/mplayer/example.conf 配置模板<br>/etc/mplayer/input.conf 按键配置<br>/etc/mplayer/mplayer.conf 配置文件（没有的话自己新建）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /etc/mplayer/mplayer.conf全局配置通用范例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 应用于所有文件类型的默认设置</span></span><br><span class="line">[default]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用X11输出影像</span></span><br><span class="line">vo=xv</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用alsa输出音频</span></span><br><span class="line">ao=alsa</span><br><span class="line"><span class="meta">#</span><span class="bash"> ao=oss <span class="comment"># 使用OSS</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用6声道</span></span><br><span class="line">channels = 6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 字幕占据3%屏幕空间</span></span><br><span class="line">subfont-text-scale = 3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从不使用字体配置</span></span><br><span class="line">nofontconfig = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当图像不适合屏幕长宽比时添加黑边</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 宽屏用户</span></span><br><span class="line">vf-add=expand=::::1:16/9:16</span><br><span class="line"><span class="meta">#</span><span class="bash"> 非宽屏用户</span></span><br><span class="line"><span class="meta">#</span><span class="bash">vf-add=expand=::::1:4/3:16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">profile <span class="keyword">for</span> up-mixing two channels audio to six channels</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> use -profile 2chto6ch to activate</span></span><br><span class="line">[2chto6ch]</span><br><span class="line">af-add=pan=6:1:0:.4:0:.6:2:0:1:0:.4:.6:2</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">profile to down-mixing six channels audio to two channels</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> use -profile 6chto2ch to activate</span></span><br><span class="line">[6chto2ch]</span><br><span class="line">af-add=pan=2:0.7:0:0:0.7:0.5:0:0:0.5:0.6:0.6:0:0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 播放mp4和flv可能出现无图像</span></span><br><span class="line">[extension.mp4]</span><br><span class="line"> demuxer=mov</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 播放时禁用屏保</span></span><br><span class="line">heartbeat-cmd=&quot;xscreensaver-command -deactivate &amp;&quot; # stop xscreensaver</span><br><span class="line">stop-xscreensaver=&quot;yes&quot; # stop gnome-screensaver</span><br></pre></td></tr></table></figure>
<p>用户配置：<br>~/.mplayer/config<br>其实gnome-mplayer前端也有配置</p>
<h2 id="启用回收站和自动挂载"><a href="#启用回收站和自动挂载" class="headerlink" title="启用回收站和自动挂载"></a>启用回收站和自动挂载</h2><p>arch默认没有回收站机制，u盘也不会自动挂载，windows盘也不会自动挂载，都需要手动mount，解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S gvfs</span><br></pre></td></tr></table></figure>
<p>会自动安装所需依赖，安装好之后，注销重启生效</p>
<h2 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h2><p>按照arch官方的wiki安装好系统后时间不对<br>官方不提倡使用软件同步系统时间，但是没办法，只有同步时间最方便，方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S ntp</span><br><span class="line">systemctl start ntpd.service</span><br><span class="line">systemctl enable ntpd.service</span><br></pre></td></tr></table></figure>
<p>等待几分钟之后系统时间就同步正确了</p>
<p>然后将本机硬件时间设置为同步好的系统时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hwclock --systohc --localtime</span><br></pre></td></tr></table></figure>
<h2 id="安装pidgin-lwqq"><a href="#安装pidgin-lwqq" class="headerlink" title="安装pidgin-lwqq"></a>安装pidgin-lwqq</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S pidgin pidgin-lwqq</span><br></pre></td></tr></table></figure>
<p>装好之后直接就能用了，不过里面有很多设置项，有些功能需要自己调整才能正常使用，具体看：<a href="https://github.com/xiehuc/pidgin-lwqq/wiki/simple-user-guide">github-pidgin-lwqq简单教程</a><br>上面的链接是使用教程，不用按着上面的安装方法自己下载源码同步什么的，只需要用这个章节的命令从官方源安装就行了</p>
<h2 id="bash命令补全"><a href="#bash命令补全" class="headerlink" title="bash命令补全"></a>bash命令补全</h2><h3 id="更快的命令补全操作"><a href="#更快的命令补全操作" class="headerlink" title="更快的命令补全操作"></a>更快的命令补全操作</h3><p>加入下面这句话到readline默认的初始化文件(~/.inputrc或者/etc/inputrc中): </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set show-all-if-ambiguous on</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在终端正常的补全是按两下tab键才会发生，上面的命令是将其改成按一次tab键就激活补全</p>
</blockquote>
<h3 id="高级的自动命令补全-方法一"><a href="#高级的自动命令补全-方法一" class="headerlink" title="高级的自动命令补全(方法一)"></a>高级的自动命令补全(方法一)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S bash-completion</span><br></pre></td></tr></table></figure>

<h3 id="高级的自动命令补全-方法二"><a href="#高级的自动命令补全-方法二" class="headerlink" title="高级的自动命令补全(方法二)"></a>高级的自动命令补全(方法二)</h3><p>你可以加入以下内容到~/.bashrc文件中以实现补全功能:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">complete -cf your_command</span><br><span class="line"><span class="meta">#</span><span class="bash">比如:</span></span><br><span class="line">complete -cf sudo</span><br><span class="line">complete -cf man</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正常的sudo后的命令不会自动补全<br>我用的是方法一，简单，方便</p>
</blockquote>
<h2 id="安装压缩文件管理器"><a href="#安装压缩文件管理器" class="headerlink" title="安装压缩文件管理器"></a>安装压缩文件管理器</h2><p>也就是归档管理器：可以用file-roller</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S file-roller</span><br></pre></td></tr></table></figure>
<p>或者用xarchiver</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S xarchiver</span><br></pre></td></tr></table></figure>
<blockquote>
<p>个人推荐file-roller，不少发行办都内置了这个管理器</p>
</blockquote>
<h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp:"></a>ftp:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S filezilla</span><br></pre></td></tr></table></figure>
<h2 id="安装办公软件libreoffice"><a href="#安装办公软件libreoffice" class="headerlink" title="安装办公软件libreoffice:"></a>安装办公软件libreoffice:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S libreoffice-still libreoffice-still-zh-CN libreoffice-still-en-GB</span><br></pre></td></tr></table></figure>
<h2 id="安装音乐播放器rhythmbox"><a href="#安装音乐播放器rhythmbox" class="headerlink" title="安装音乐播放器rhythmbox"></a>安装音乐播放器rhythmbox</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S rhythmbox</span><br></pre></td></tr></table></figure>
<h2 id="安装wine-QQ"><a href="#安装wine-QQ" class="headerlink" title="安装wine+QQ"></a>安装wine+QQ</h2><h3 id="安装主程序包，q4wine是图形菜单"><a href="#安装主程序包，q4wine是图形菜单" class="headerlink" title="安装主程序包，q4wine是图形菜单"></a>安装主程序包，q4wine是图形菜单</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S wine winetricks wine-mono wine_gecko q4wine</span><br></pre></td></tr></table></figure>
<h3 id="安装缺少的32位包"><a href="#安装缺少的32位包" class="headerlink" title="安装缺少的32位包"></a>安装缺少的32位包</h3><p>使用regedit可能报错，则安装这个:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S lib32-ncurses</span><br></pre></td></tr></table></figure>
<p>安装flash可能报错，则安装这个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S lib32-mpg123 lib32-lcms2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>archlinux</tag>
        <tag>xfce4</tag>
        <tag>uefi</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>bash parameter expansion 参数扩展</title>
    <url>/2021/08/15/bash-parameter-expansion-%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>摘自 bash man 手册</p>
<p>字符 <code>$</code> 引入了参数扩展，命令替换和算术扩展。要扩展的参数名或符号可能包含在花括号中，花括号可选的，但是可以使得要扩展的变量不会与紧随其后的字符合并，成为新的名称。</p>
<p>使用花括号的时候，匹配的右括号是第一个  <code>&#125;</code>，并且它没有被反斜杠引用或包含在一个引用的字符串中，也没有包含在一个嵌入的算术扩展，命令替换或是参数扩展中。</p>
<ul>
<li><p><code>$&#123;parameter&#125;</code></p>
<p>  被替换为 parameter 的值。</p>
<ul>
<li>如果 parameter 是一个位置参数，并且数字多于一位时；或者当紧随 parameter 之后有不属于名称一部分的字符时，都必须加上花括号。</li>
<li>如果 parameter 的第一个字符是一个感叹号，将引进一层间接变量。bash 使用以 parameter 的其余部分为名的变量的值作为变量的名称；接下来新的变量被扩展，它的值用在随后的替换当中，而不是使用 parameter 自身的值。这也称为 indirect expansion(间接扩展). 例外情况是下面讲到的 <code>$&#123;!prefix*&#125;</code>。</li>
</ul>
</li>
</ul>
<p>下面的每种情况中，word 都要经过波浪线扩展，参数扩展，命令替换和算术扩展。如果不进行子字符串扩展，bash 测试一个没有定义或值为空的参数；忽略冒号的结果是只测试未定义的参数。</p>
<ul>
<li><p><code>$&#123;parameter:-word&#125;</code></p>
<p>  Use Default Values(使用默认值)。如果 parameter 未定义或值为空，将替换为 word 的扩展。否则，将替换为 parameter 的值。</p>
</li>
<li><p><code>$&#123;parameter:=word&#125;</code></p>
<p>  Assign Default Values(赋默认值)。如果 parameter 未定义或值为空， word 的扩展将赋予 parameter. parameter 的值将被替换。位置参数和特殊参数不能用这种方式赋值。</p>
</li>
<li><p><code>$&#123;parameter:?word&#125;</code></p>
<p>  Display Error if Null or Unset(显示错误，如果未定义或值为空)。如果 parameter 未定义或值为空，word (或一条信息，如果 word 不存在) 的扩展将写入到标准错误；shell 如果不是交互的，则将退出。否则，parameter 的值将被替换。</p>
</li>
<li><p><code>$&#123;parameter:+word&#125;</code><br>  Use Alternate Value(使用可选值)。如果 parameter 未定义或值为空，不会进行替换；否则将替换为 word 扩展后的值。</p>
</li>
<li><p><code>$&#123;parameter:offset&#125;</code> 和 <code>$&#123;parameter:offset:length&#125;</code></p>
<p>  Substring Expansion(子字符串扩展)。扩展为 parameter 的最多 length 个字符，从 offset 指定的字符开始。</p>
<ul>
<li>如果忽略了 length，扩展为 parameter 的子字符串，从 offset 指定的字符串开始。length 和 offset 是算术表达式 (参见下面的 ARITHMETICEVALUATION 算术求值 段落)。length 必须是一个大于等于 0 的数值。</li>
<li>如果 offset 求值结果小于 0，值将当作从 parameter 的值的末尾算起的偏移量。</li>
<li>如果 parameter 是 @，结果是 length 个位置参数，从 offset 开始。</li>
<li>如果 parameter 是一个数组名，以 @ 或 * 索引，结果是数组的 length 个成员，从 <code>$&#123;parameter[offset]&#125;</code> 开始。子字符串的下标是从 0 开始的，除非使用位置参数时，下标从 1 开始。</li>
</ul>
</li>
<li><p><code>$&#123;!prefix*&#125;</code></p>
<p>  扩展为名称以 prefix 开始的变量名，以特殊变量 IFS 的第一个字符分隔。</p>
</li>
<li><p><code>$&#123;#parameter&#125;</code></p>
<p>  替换为 parameter 的值的长度 (字符数目)。</p>
<ul>
<li>如果 parameter 是 * 或者是 @, 替换的值是位置参数的个数。</li>
<li>如果 parameter 是一个数组名，下标是 * 或者是 @, 替换的值是数组中元素的个数。</li>
</ul>
</li>
<li><p><code>$&#123;parameter#word&#125;</code> 和 <code>$&#123;parameter##word&#125;</code></p>
<p>  word  被扩展为一个模式，就像路径扩展中一样。</p>
<ul>
<li>如果这个模式匹配 parameter 的值的起始，那么扩展的结果是将 parameter 扩展后的值中，最短的匹配 (``#’’ 的情况) 或者最长的匹配 (``##’’的情况) 删除的结果。</li>
<li>如果 parameter 是 @ 或者是 *, 则模式删除操作将依次施用于每个位置参数，最后扩展为结果的列表。</li>
<li>如果 parameter 是一个数组变量，下标是 @ 或者是 *, 模式删除将依次施用于数组中的每个成员，最后扩展为结果的列表。</li>
</ul>
</li>
<li><p><code>$&#123;parameter%word&#125;</code> 和 <code>$&#123;parameter%%word&#125;</code></p>
<p>  word 被扩展为一个模式，就像路径扩展中一样。</p>
<ul>
<li>如果这个模式匹配 parameter 扩展后的值的尾部，那么扩展的结果是将 parameter 扩展后的值中，最短的匹配 (``%’’ 的情况) 或者最长的匹配 (``%%’’的情况) 删除的结果。</li>
<li>如果 parameter 是 @ 或者是 *, 则模式删除操作将依次施用于每个位置参数，最后扩展为结果的列表。</li>
<li>如果 parameter 是一个数组变量，下标是 @ 或者是 *, 模式删除将依次施用于数组中的每个成员，最后扩展为结果的列表。</li>
</ul>
</li>
<li><p><code>$&#123;parameter/pattern/string&#125;</code> 和 <code>$&#123;parameter//pattern/string&#125;</code></p>
<p>  pattern 被扩展为一个模式，就像路径扩展中一样。parameter 被扩展，其值中最长的匹配 pattern 的内容被替换为 string。在第一种形式中，只有第一个匹配被替换。第二种形式使得 pattern 中所有匹配都被替换为 string。</p>
<ul>
<li>如果 pattern 以 #  开始，它必须匹配 parameter 扩展后值的首部。</li>
<li>如果 pattern 以 % 开始，它必须匹配 parameter 扩展后值的尾部。</li>
<li>如果 string 是空值，pattern 的匹配都将被删除， pattern 之后的 / 将被忽略。</li>
<li>如果 parameter 是 @ 或者是 *, 则替换操作将依次施用于每个位置参数，最后扩展为结果的列表。</li>
<li>如果 parameter 是一个数组变量，下标是 @ 或者是 *, 模式删除将依次施用于数组中的每个成员，最后扩展为结果的列表。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>bash</category>
      </categories>
      <tags>
        <tag>parameter expansion</tag>
        <tag>表达式扩展</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>bat批处理编译执行java</title>
    <url>/2016/04/22/bat%E6%89%B9%E5%A4%84%E7%90%86%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8Cjava/</url>
    <content><![CDATA[<p>虽然有eclipse等强大的IDE工具、但有时不可避免的需要用命令行来手动编译和执行java程序、<br>最近我就碰到的这样的问题、突然感觉编译和执行时都要敲一遍java或class文件的名字、这样好麻烦、</p>
<p>碰巧刚刚学习了下dos系统和批处理、所以就想自己写一个批处理.bat、来省事点、<br>虽然不复杂、但初次写批处理还是被某些问题难住了、不过黄天不负有心人、最终还是写出来了：</p>
<p>把下面的两段代码<font color=red>分别</font>复制、打开记事本、粘贴进去、保存为后缀为：”.bat”的文件、</p>
<p>然后把这两个.bat文件随意放在电脑上的任何地方、比如桌面上(建议放在桌面上)、<br>以后需要手动编译和执行 java时、先把选中的java文件拖到MyJavac.bat文件上、</p>
<p>这里假设我将第一段代码保存为了MyJavac.bat文件,下同MyJava.bat、<br>就会自动编译生成class文件到java文件所在目录了、</p>
<p>然后再选中需要执行的class文件将其拖到MyJava.bat文件上、就会批量执行了、</p>
<p>这两个小程序都是最多支持9个java或class文件同时编译和执行、</p>
<p>本来打算将编译和执行和在一起呢、但是想了想、还是这样分开比较好、</p>
<p>下面是代码：</p>
<p>批量编译MyJavac：</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%i</span> <span class="keyword">in</span> (%<span class="number">1</span> %<span class="number">2</span> %<span class="number">3</span> %<span class="number">4</span> %<span class="number">5</span> %<span class="number">6</span> %<span class="number">7</span> %<span class="number">8</span> %<span class="number">9</span>) <span class="keyword">do</span> (<span class="variable">%%~</span>di &amp;&amp; <span class="built_in">cd</span> <span class="variable">%%~</span>dpi &amp;&amp; javac <span class="variable">%%i</span> &amp;&amp; <span class="keyword">if</span> <span class="variable">%errorlevel%</span>==<span class="number">0</span> <span class="built_in">echo</span> <span class="variable">%%~</span>nxi编译完成 )</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<p>批量执行MyJava:</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%i</span> <span class="keyword">in</span> (%<span class="number">1</span> %<span class="number">2</span> %<span class="number">3</span> %<span class="number">4</span> %<span class="number">5</span> %<span class="number">6</span> %<span class="number">7</span> %<span class="number">8</span> %<span class="number">9</span>) <span class="keyword">do</span> (<span class="variable">%%~</span>di &amp;&amp; <span class="built_in">cd</span> <span class="variable">%%~</span>dpi &amp;&amp; <span class="built_in">start</span> <span class="keyword">call</span> java <span class="variable">%%~</span>ni )</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>批处理</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title>byte 字节 与 二进制 与 编码</title>
    <url>/2020/11/05/byte-%E5%AD%97%E8%8A%82-%E4%B8%8E-%E4%BA%8C%E8%BF%9B%E5%88%B6-%E4%B8%8E-%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>先扯一堆：byte（字节），bytes（字节流），二进制，十六进制，编码<br>今天跟同事讨论起了上面一堆名词之间的定义和关系到底是什么，不啦不啦个把小时之后得出了以下结论。</p>
<h1 id="byte-与-二进制"><a href="#byte-与-二进制" class="headerlink" title="byte 与 二进制"></a>byte 与 二进制</h1><p><strong>byte 是二进制的长度单位</strong>（位数，为了便于理解后面使用长度一词），一个 byte 表示长度为 8 的二进制，即通常所说的：一个 byte 是 八个 bit（位）</p>
<p>既然 byte 是二进制的长度单位，那么编程语言里的其他类型呢？</p>
<p>它们其实也是二进制的长度单位，但是表示的长度不同，比如 int 表示 4 个字节（通常）也就是说 int 其实表示长度为 4 * 8 = 32 的二进制，其他类型以此类推，注意，char 类型表示一个 byte，也表示长度为 8 的二进制。</p>
<p><strong>byte 是长度单位为什么能表示数值大小？</strong></p>
<p>一个二进制数既然确定了其长度，那么也就确定了其能表示的数值范围，因此一个 byte 也就能表示出长度为 8 的二进制数所能表示的任何数值。</p>
<p>要注意，byte 是先确定了二进制长度，然后才确定了数值大小，具体的数值大小要看这固定长度的二进制每一位都是什么内容。</p>
<h1 id="编码又是什么？"><a href="#编码又是什么？" class="headerlink" title="编码又是什么？"></a>编码又是什么？</h1><p>我们将编码分为狭义和广义两种。</p>
<p>狭义上来说是数值到字符的一种转换方法，这种也叫字符编码，比如 ASCII，UTF-8，GB-2312，GBK，UNICODE 等都属于这种。</p>
<p>如果从广义上来看，编码是一种动作：<strong>依照一定规则将一个东西转换成另一个东西，且还能转换回来。</strong><br>那么此时再来看编码，是不是应该包含 十六进制？十进制？和八进制？这几个进制都可以理解为是从二进制转换而来的，是二进制的另一种表示方式，所以网上也有很多人将十六进制转换叫做十六进制编码。</p>
<h1 id="延伸一下"><a href="#延伸一下" class="headerlink" title="延伸一下"></a>延伸一下</h1><p>二进制，十六进制这些都是一种数值的表示方法，大家都知道硬盘上的文件其实是以一堆二进制的数存储在硬盘上的，那么这一堆二进制数自然也可以由十六进制表示出来，无非就是一个很大的十六进制数，所以也就有了以十六进制方式打开一个文件的说法。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>byte</tag>
        <tag>binary</tag>
        <tag>hex</tag>
        <tag>encodings</tag>
      </tags>
  </entry>
  <entry>
    <title>caida tools</title>
    <url>/2019/11/27/caida-tools/</url>
    <content><![CDATA[<blockquote>
<p>翻译自：<a href="http://www.caida.org/tools/">http://www.caida.org/tools/</a></p>
</blockquote>
<p>主要翻译了工具列表中的“介绍”部分。</p>
<a id="more"></a>

<h1 id="支持中的工具"><a href="#支持中的工具" class="headerlink" title="支持中的工具"></a>支持中的工具</h1><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">主要作者</th>
<th align="center">英文描述</th>
<th align="center">中文描述</th>
<th align="center">发布日期</th>
<th align="center">最近更新</th>
<th align="center">分类</th>
<th align="center">输入</th>
<th align="center">输出</th>
<th align="center">许可证</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="http://www.caida.org/tools/utilities/arkutil/">arkutil</a></td>
<td align="center">Young Hyun</td>
<td align="center">RubyGem containing utility classes used by the Archipelago measurement infrastructure and the MIDAR alias-resolution system.</td>
<td align="center">一个被 Archipelago 测量基础框架和 MIDAR 别名分析系统使用的 RubyGem 工具</td>
<td align="center">2012</td>
<td align="center">2013</td>
<td align="center">库:拓扑</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">GNU GPL v2+</td>
</tr>
<tr>
<td align="center"><a href="http://www.inspire.edu.gr/artemis/">ARTEMIS</a></td>
<td align="center">Vasileios Kotronis</td>
<td align="center">Defense approach versus BGP prefix hijacking attacks</td>
<td align="center">BGP前缀劫持攻击与防御方法</td>
<td align="center">2018</td>
<td align="center">2018</td>
<td align="center">安全</td>
<td align="center">包含 AS 通告的 BGP 前缀的配置文件</td>
<td align="center">警报和 web 接口</td>
<td align="center">BSD 3-Clause</td>
</tr>
<tr>
<td align="center">AStraceroute (正在开发中)</td>
<td align="center">Chiara Orsini</td>
<td align="center">A Python tool that translates traceroutes into AS paths</td>
<td align="center">一个将 traceroute 结果转换到 aspath 的 python 工具</td>
<td align="center">2016</td>
<td align="center">2016</td>
<td align="center">拓扑</td>
<td align="center">JSON 编码的 traceroute 数据</td>
<td align="center">JSON(aspath)</td>
<td align="center">GNU GPL v3</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/autofocus/">Autofocus</a></td>
<td align="center">Cristian Estan</td>
<td align="center">Internet traffic reports and time-series graphs</td>
<td align="center">网络流量报告和时序图</td>
<td align="center">2003</td>
<td align="center">2003</td>
<td align="center">工作量:可视化</td>
<td align="center">NetFlow data, pcap</td>
<td align="center">文字报告和时序图</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/beluga/">Beluga</a></td>
<td align="center">Ryan Koga</td>
<td align="center">Interactive frontend to traceroute data</td>
<td align="center">traceroute 数据的交互式前端</td>
<td align="center">2002</td>
<td align="center">2006</td>
<td align="center">性能:可视化</td>
<td align="center">IP 地址</td>
<td align="center">交互式 traceroute</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="http://bgpstream.caida.org/">BGPstream</a></td>
<td align="center">Alistair King</td>
<td align="center">Open-source software framework for live and historical BGP data analysis, supporting scientific research, operational monitoring, and post-event analysis.</td>
<td align="center">用于实时和历史 BGP 数据分析的开源软件框架 支持科学研究 运营监控和事件后分析</td>
<td align="center">2015</td>
<td align="center">2018</td>
<td align="center">拓扑:数据分析</td>
<td align="center">BGP 数据(如 MRT)</td>
<td align="center">ASCII, C API, Python API</td>
<td align="center">GNU GPL v2</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/utilities/graphing/">Chart:Graph</a></td>
<td align="center">David Moore</td>
<td align="center">Perl front-end to GNU plot and Xmgrace</td>
<td align="center">GNU plot 和 Xmgrace 的 perl 前端</td>
<td align="center">2006</td>
<td align="center">2013</td>
<td align="center">库:绘图</td>
<td align="center">无</td>
<td align="center">2D 图</td>
<td align="center">GNU GPL v2</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/coralreef/">CoralReef</a></td>
<td align="center">Ken Keys</td>
<td align="center">Measures and analyzes passive Internet traffic monitor data</td>
<td align="center">测量和分析被动网络流量监控器数据</td>
<td align="center">2000</td>
<td align="center">2014</td>
<td align="center">工作量:测量与分析</td>
<td align="center">网络接口; DAG 采集卡; DAG, libpcap, 和 CoralReef 数据包</td>
<td align="center">文字报告, 流量报告, CoralReef 数据文件</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/corsaro/">Corsaro</a></td>
<td align="center">Alistair King</td>
<td align="center">Extensible framework for large-scale analysis of passive trace data</td>
<td align="center">大规模分析被动跟踪数据的可扩展框架</td>
<td align="center">2012</td>
<td align="center">2014</td>
<td align="center">工作量:测量与分析</td>
<td align="center">被动追踪数据(pcap, 接口, 等)</td>
<td align="center">机器可解析文本, Corsaro 二进制数据文件</td>
<td align="center">GNU GPL v3+</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/visualization/cuttlefish/">Cuttlefish</a></td>
<td align="center">Bradley Huffaker</td>
<td align="center">Produces animated graphs showing diurnal and geographical patterns</td>
<td align="center">生成显示日间和地理模式的动画图形</td>
<td align="center">2006</td>
<td align="center">2006</td>
<td align="center">地理:可视化</td>
<td align="center">Cuttlefish 输入文件时序图 (GIF)</td>
<td align="center">GNU GPL v2</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/utilities/dbats/">DBATS</a></td>
<td align="center">Ken Keys</td>
<td align="center">High performance time series database engine optimized for inserting/updating values for many series simultaneously</td>
<td align="center">高性能时间序列数据库引擎针对同时插入/更新多个序列的值进行了优化</td>
<td align="center">2016</td>
<td align="center">2016</td>
<td align="center">库:数据库</td>
<td align="center">时序数据</td>
<td align="center">时序数据</td>
<td align="center">GNU GPL v2+</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/utilities/dnsstat/">dnsstat</a></td>
<td align="center">Ken Keys</td>
<td align="center">DNS traffic measurement utility</td>
<td align="center">DNS 流量测量工具</td>
<td align="center">1999</td>
<td align="center">2006</td>
<td align="center">工作量:DNS 分析</td>
<td align="center">pcap, 监控在 UDP 端口 53 上的 DNS 查询数据</td>
<td align="center">文字报告</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/utilities/henya/">Henya</a></td>
<td align="center">Young Hyun</td>
<td align="center">Large-scale Internet topology query system which provides remote search of traceroute data without requiring data downloads</td>
<td align="center">大规模互联网拓扑查询系统，无需下载数据即可远程搜索 traceroute 数据</td>
<td align="center">2016</td>
<td align="center">2016</td>
<td align="center">拓扑</td>
<td align="center">IP</td>
<td align="center">web 界面, JSON 数据</td>
<td align="center">GNU GPL v3</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/utilities/hyperbolic-graph-generator/">Hyperbolic Graph Generator</a></td>
<td align="center">Chiara Orsini</td>
<td align="center">A set of tools to generate synthetic graphs embedded into a hyperbolic space and to test the greedy routing</td>
<td align="center">一组工具，用于生成嵌入双曲线空间的合成图并测试贪婪路由</td>
<td align="center">2014</td>
<td align="center">2014</td>
<td align="center">拓扑和性能测量</td>
<td align="center">双曲图参数</td>
<td align="center">hyperbolic in a text file</td>
<td align="center">GNU GPL v3</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/iatmon/">iatmon</a></td>
<td align="center">Nevil Brownlee</td>
<td align="center">Ruby+C+libtrace analysis module that separates one-way traffic into clearly-defined subsets</td>
<td align="center">Ruby + C + libtrace分析模块，可将单向流量分为明确定义的子集</td>
<td align="center">2012</td>
<td align="center">2014</td>
<td align="center">工作量:测量与分析</td>
<td align="center">Network trace files, or a live network interface</td>
<td align="center">text report (matrices, distributions and vectors as statistics of the one-way traffic)</td>
<td align="center">GNU GPL v3</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/iffinder/">iffinder</a></td>
<td align="center">Ken Keys</td>
<td align="center">Discovers IPv4 addresses belonging to the same router (aliases) using the common source technique</td>
<td align="center">使用通用源技术发现属于同一路由器（别名）的IPv4地址</td>
<td align="center">2001</td>
<td align="center">2012</td>
<td align="center">拓扑:别名分析</td>
<td align="center">IP</td>
<td align="center">文本文件</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/kapar/">kapar</a></td>
<td align="center">Ken Keys</td>
<td align="center">Graph-based IP alias resolution</td>
<td align="center">基于图的 IP 别名解析</td>
<td align="center">2011</td>
<td align="center">2018</td>
<td align="center">拓扑:别名分析</td>
<td align="center">scamper “warts” traces, iPlane traces, text files</td>
<td align="center">alias and link text files</td>
<td align="center">GNU GPL v2+</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/visualization/libsea/">LibSea</a></td>
<td align="center">Young Hyun</td>
<td align="center">Scalable graph file format and graph library</td>
<td align="center">可扩展的图形文件格式和图形库</td>
<td align="center">2000</td>
<td align="center">2002</td>
<td align="center">库:拓扑</td>
<td align="center">LibSea graph format files</td>
<td align="center">N/A</td>
<td align="center">GNU Lesser GPL</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/utilities/libtimeseries/">libtimeseries</a></td>
<td align="center">Alistair King</td>
<td align="center">C library that provides a high-performance abstraction layer for efficiently writing to time series databases</td>
<td align="center">提供高性能抽象层的C库，可有效地写入时间序列数据库</td>
<td align="center">2016</td>
<td align="center">2019</td>
<td align="center">库:数据库</td>
<td align="center">time series data</td>
<td align="center">time series data</td>
<td align="center">BSD 2-Clause</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/utilities/marinda/">Marinda</a></td>
<td align="center">Young Hyun</td>
<td align="center">A distributed tuple space implementation</td>
<td align="center">分布式元组空间实现</td>
<td align="center">2015</td>
<td align="center">2015</td>
<td align="center">Library: Middleware</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
<td align="center">GNU GPL v3</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/midar/">MIDAR</a></td>
<td align="center">Ken Keys and Young Hyun</td>
<td align="center">Identifies IPv4 addresses belonging to the same router (aliases) using shared monotonic IP ID counters</td>
<td align="center">使用共享的单调 IP ID 计数器标识属于同一路由器（别名）的 IPv4 地址</td>
<td align="center">2011</td>
<td align="center">2018</td>
<td align="center">Topology: Alias Resolution</td>
<td align="center">traceroute data or list of addresses</td>
<td align="center">alias sets (router addresses)</td>
<td align="center">GNU GPL v2+</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/motu/">Motu</a></td>
<td align="center">Alistair King</td>
<td align="center">Dealiases pairs of IPv4 addresses</td>
<td align="center">Dealiases pairs of IPv4 addresses</td>
<td align="center">2011</td>
<td align="center">2011</td>
<td align="center">Topology: Alias Resolution</td>
<td align="center">text input (candidate alias pairs)</td>
<td align="center">text report and machine-parseable results</td>
<td align="center">GNU GPL v2+</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/mper/">mper</a></td>
<td align="center">Young Hyun</td>
<td align="center">Probing engine for conducting network measurements with ICMP, UDP, and TCP probes</td>
<td align="center">使用 ICMP，UDP 和 TCP 探针进行网络测量的探测引擎</td>
<td align="center">2011</td>
<td align="center">2012</td>
<td align="center">Topology and Performance Measurement</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
<td align="center">GNU GPL v2+</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/visualization/otter/">Otter</a></td>
<td align="center">Bradley Huffaker</td>
<td align="center">Visualizes arbitrary network data</td>
<td align="center">可视化任意网络数据</td>
<td align="center">1998</td>
<td align="center">2003</td>
<td align="center">Topology: Visualization</td>
<td align="center">Otter data file</td>
<td align="center">interactive 2D graph, PDF</td>
<td align="center">GNU GPL v2</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/utilities/looking-glass-api/">Periscope Looking Glass API</a></td>
<td align="center">Vasileios Giotsas</td>
<td align="center">API to unify Looking Glass server queries and standardize output</td>
<td align="center">统一 Looking Glass 服务器查询并标准化输出的 API</td>
<td align="center">2015</td>
<td align="center">2016</td>
<td align="center">库:中间件</td>
<td align="center">JSON-encoded API request</td>
<td align="center">JSON, iplane format, raw text format</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/visualization/plot-latlong/">plot-latlong</a></td>
<td align="center">Young Hyun</td>
<td align="center">Plots points on geographic maps</td>
<td align="center">在地理地图上绘制点</td>
<td align="center">2003</td>
<td align="center">2005</td>
<td align="center">Geographic</td>
<td align="center">text input (latitude/longitude pair)</td>
<td align="center">geographical plot</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/visualization/plotpaths/">PlotPaths</a></td>
<td align="center">Bradley Huffaker</td>
<td align="center">Displays forward traceroute path data</td>
<td align="center">显示正向跟踪路由路径数据</td>
<td align="center">2001</td>
<td align="center">2002</td>
<td align="center">Topology: Visualization</td>
<td align="center">text input files (paths file, nodes file)</td>
<td align="center">Otter data file</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/rb-mperio/">rb-mperio</a></td>
<td align="center">Young Hyun</td>
<td align="center">RubyGem for writing network measurement scripts in Ruby that use the mper probing engine</td>
<td align="center">用Ruby编写使用mper探测引擎的网络测量脚本</td>
<td align="center">2011</td>
<td align="center">2013</td>
<td align="center">Library: Topology Measurement</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
<td align="center">GNU GPL v2+</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/utilities/router-to-as-assignment/">RouterToAsAssignment</a></td>
<td align="center">Ken Keys</td>
<td align="center">Assigns each router from a router-level graph of the Internet to its Autonomous System (AS)</td>
<td align="center">将每个路由器从 Internet 的路由器级别图分配给其自治系统（AS）</td>
<td align="center">2010</td>
<td align="center">2010</td>
<td align="center">Topology</td>
<td align="center">output from ITDK</td>
<td align="center">text report (router to AS report)</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/measurement/scamper/">scamper</a></td>
<td align="center">Matthew Luckie</td>
<td align="center">IPv6 and IPv4 active traceroute probing and ping</td>
<td align="center">IPv6 和 IPv4 主动 traceroute 探测 和 ping</td>
<td align="center">2004</td>
<td align="center">2018</td>
<td align="center">Topology and Performance Measurement</td>
<td align="center">IP destinations</td>
<td align="center">text reports, “warts” binary file</td>
<td align="center">GNU GPL v2</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/projects/spoofer/">Spoofer</a></td>
<td align="center">Ken Keys, Ryan Koga, and Robert Beverly</td>
<td align="center">Source address validation measurement program that measures susceptibility to spoofed source address IP packets</td>
<td align="center">源地址验证测量程序，用于测量对欺骗性源地址 IP 数据包的敏感性</td>
<td align="center">2005</td>
<td align="center">2018</td>
<td align="center">Security</td>
<td align="center">N/A</td>
<td align="center">text report, HTML report</td>
<td align="center">GNU GPL v3+</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/funding/atomized_routing/download/">straightenRV</a></td>
<td align="center">Patrick Verkaik</td>
<td align="center">Parses and processes Route Views tables for ease of analysis</td>
<td align="center">解析并处理 Route Views 表以简化分析</td>
<td align="center">2002</td>
<td align="center">2009</td>
<td align="center">Topology: Data Analysis</td>
<td align="center">statistics</td>
<td align="center">text report (e.g., prefix to AS maps, AS paths, etc), machine-parseable data file</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/utilities/topostats/">topostats</a></td>
<td align="center">Young Hyun</td>
<td align="center">Computes various statistics on network topologies</td>
<td align="center">计算有关网络拓扑的各种统计信息</td>
<td align="center">2010</td>
<td align="center">2010</td>
<td align="center">Topology</td>
<td align="center">text input (e.g., AS link pairs)</td>
<td align="center">text report, no graphs</td>
<td align="center">GNU GPL v3</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/projects/ark/vela/">Vela</a></td>
<td align="center">Young Hyun</td>
<td align="center">On-demand topology measurement service of CAIDA’s Archipelago Measurement Infrastructure</td>
<td align="center">CAIDA Archipelago Measurement Infrastructure 的拓扑测量服务</td>
<td align="center">2012</td>
<td align="center">2017</td>
<td align="center">Topology</td>
<td align="center">web interface</td>
<td align="center">HTML and graph reports</td>
<td align="center">GNU GPL v3+</td>
</tr>
<tr>
<td align="center"><a href="http://www.caida.org/tools/visualization/walrus/">Walrus</a></td>
<td align="center">Young Hyun</td>
<td align="center">Visualizes large graphs in three-dimensional space</td>
<td align="center">在三维空间中可视化大型图形</td>
<td align="center">2001</td>
<td align="center">2005</td>
<td align="center">Topology: Visualization</td>
<td align="center">LibSea graph format files</td>
<td align="center">interactive 3D graph</td>
<td align="center">GNU GPL v2</td>
</tr>
</tbody></table>
<h1 id="不受支持的工具"><a href="#不受支持的工具" class="headerlink" title="不受支持的工具"></a>不受支持的工具</h1><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">主要作者</th>
<th align="center">英文描述</th>
<th align="center">中文描述</th>
<th align="center">状态</th>
<th align="center">发布日期</th>
<th align="center">最近更新</th>
<th align="center">分类</th>
<th align="center">输入</th>
<th align="center">输出</th>
<th align="center">许可证</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://www.caida.org/tools/measurement/skitter/">skitter</a></td>
<td align="center">Daniel McRobb</td>
<td align="center">Reads in destinations and outputs traceroute paths</td>
<td align="center">读入目的地并输出traceroute路径</td>
<td align="center">Deprecated by Archipelago</td>
<td align="center">1998</td>
<td align="center">2008</td>
<td align="center">Topology: Measurement</td>
<td align="center">skitter data files</td>
<td align="center">geographical plot, graph</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/measurement/rtg/">RTG</a></td>
<td align="center">Robert Beverly</td>
<td align="center">SNMP statistics monitoring system</td>
<td align="center">SNMP统计监控系统</td>
<td align="center">In use but not supported by CAIDA</td>
<td align="center">2005</td>
<td align="center">2009</td>
<td align="center">Workload: Visualization</td>
<td align="center">SNMP data</td>
<td align="center">time series graphs, text traffic reports</td>
<td align="center">GNU GPL v2</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/utilities/rrdtool/">RRDtool</a></td>
<td align="center">Tobi Oetiker</td>
<td align="center">Stores and displays time-series data, configurable graphs</td>
<td align="center">存储和显示时间序列数据，可配置图形</td>
<td align="center">In use but not supported by CAIDA</td>
<td align="center">1999</td>
<td align="center">2006</td>
<td align="center">Plotting and Data Curation</td>
<td align="center">time series data</td>
<td align="center">time series graphs</td>
<td align="center">GNU GPL v2</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/visualization/plankton/">Plankton</a></td>
<td align="center">Bradley Huffaker</td>
<td align="center">Historical visualization of international cache topology</td>
<td align="center">国际缓存拓扑的历史可视化</td>
<td align="center">Deprecated</td>
<td align="center">1998</td>
<td align="center">1998</td>
<td align="center">Topology: Visualization</td>
<td align="center">text input</td>
<td align="center">graph</td>
<td align="center">GNU GPL v2</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/measurement/netramet/">NeTraMet</a></td>
<td align="center">Nevil Brownlee</td>
<td align="center">Realtime traffic flow measurement.</td>
<td align="center">实时流量监测</td>
<td align="center">Deprecated</td>
<td align="center">2003</td>
<td align="center">2007</td>
<td align="center">Workload: Measurement Analysis</td>
<td align="center">pcap</td>
<td align="center">time series graphs</td>
<td align="center">GNU GPL v2</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/utilities/netgeo/">NetGeo</a></td>
<td align="center">Bradley Huffaker</td>
<td align="center">Maps IPs and AS numbers to geographical locations</td>
<td align="center">将IP和AS号映射到地理位置</td>
<td align="center">Deprecated</td>
<td align="center">1999</td>
<td align="center">1999</td>
<td align="center">Geographic: Data</td>
<td align="center">IP address / URL</td>
<td align="center">text report</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/visualization/mapnet/">MapNet</a></td>
<td align="center">Bradley Huffaker</td>
<td align="center">Historical visualization of international backbone providers</td>
<td align="center">国际骨干提供商的历史可视化</td>
<td align="center">Deprecated</td>
<td align="center">1997</td>
<td align="center">2002</td>
<td align="center">Topology: Visualization</td>
<td align="center">N/A</td>
<td align="center">geographical plot</td>
<td align="center">GNU GPL v2</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/visualization/gtrace/">GTrace</a></td>
<td align="center">Ram Periakaruppan</td>
<td align="center">Geographical front-end to traceroute</td>
<td align="center">地理前端到 Traceroute</td>
<td align="center">Deprecated</td>
<td align="center">1999</td>
<td align="center">1999</td>
<td align="center">Topology: Visualization</td>
<td align="center">URL to trace</td>
<td align="center">geographical plot</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/visualization/geoplot/">GeoPlot</a></td>
<td align="center">Ram Periakaruppan</td>
<td align="center">Geographically plots nodes and links</td>
<td align="center">地理绘制节点和链接</td>
<td align="center">Deprecated</td>
<td align="center">1999</td>
<td align="center">1999</td>
<td align="center">Topology: Visualization</td>
<td align="center">text input (latitude/longitude pair)</td>
<td align="center">geographical plot</td>
<td align="center">Research-use License</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/utilities/flowscan/">FlowScan</a></td>
<td align="center">Dave Plonka</td>
<td align="center">Graphs IP flow data for a view of network border traffic</td>
<td align="center">绘制 IP 流数据以查看网络边界流量</td>
<td align="center">In use but not supported by CAIDA</td>
<td align="center">2001</td>
<td align="center">2004</td>
<td align="center">Workload: Analysis   Visualization</td>
<td align="center">NetFlow data</td>
<td align="center">graph (example available)</td>
<td align="center">GNU GPL v2</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/utilities/dsc/">dsc</a></td>
<td align="center">Duane Wessels</td>
<td align="center">Collects and displays statistics from DNS servers</td>
<td align="center">从 DNS 服务器收集并显示统计信息</td>
<td align="center">In use but not supported by CAIDA</td>
<td align="center">2007</td>
<td align="center">2010</td>
<td align="center">Workload: DNS Statistics</td>
<td align="center">pcap, monitors DNS queries on UDP Port 53</td>
<td align="center">XML intermediate file, graph report (example available)</td>
<td align="center">New BSD License</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/utilities/dnstop/">dnstop</a></td>
<td align="center">Duane Wessels</td>
<td align="center">Measures and displays tables of DNS network traffic</td>
<td align="center">测量并显示 DNS 网络流量表</td>
<td align="center">In use but not supported by CAIDA</td>
<td align="center">2002</td>
<td align="center">2002</td>
<td align="center">Workload: DNS Statistics</td>
<td align="center">pcap, monitors DNS queries on UDP Port 53</td>
<td align="center">text report (example available)</td>
<td align="center">New BSD License</td>
</tr>
<tr>
<td align="center"><a href="https://www.caida.org/tools/measurement/cflowd/">cflowd</a></td>
<td align="center">Daniel McRobb</td>
<td align="center">Former NetFlow analysis tool</td>
<td align="center">前 NetFlow 分析工具</td>
<td align="center">Deprecated</td>
<td align="center">1998</td>
<td align="center">2000</td>
<td align="center">Topology and Performance Measurement</td>
<td align="center">Netflow data in arts format</td>
<td align="center">text reports</td>
<td align="center">GNU GPL v2</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>caida</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome adobe flash不是最新版本</title>
    <url>/2016/11/02/chrome-adobe-flash%E4%B8%8D%E6%98%AF%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>google-chrome最近更新后flash不能正常运行了, 好象是不再包含flash player了,<br>在看视频或者需要用到flash player的时候就会提示:<br><code>adobe flash player 不是最新版本</code></p>
<p>解决方法也简单, 只是需要梯(fan)子(qiang), 如何找梯子本文就不提及了.<br>有了梯子之后, 设置好代理启动chrome, 在地址栏输入: <code>chrome://components/</code>, 回车,<br>然后找到flash player那一项, 点击更新就行了. </p>
<p>下面详细说说linux下和windows下怎么设置代理:</p>
<p>linux下在<code>终端</code>中设置好代理变量, 然后接着在同一个终端下以命令的方式启动chrome就行了,下面是具体命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export http_proxy&#x3D;127.0.0.1:8787</span><br><span class="line">export https_proxy&#x3D;127.0.0.1:8787</span><br><span class="line">google-chrome</span><br></pre></td></tr></table></figure>

<p>命令解释, 前两行主要是指定代理地址和端口, 因为我是在本机运行的代理软件, 所以地址是127.0.0.1<br>而8787则是代理软件监听的端口, 第三行则是启动chrome</p>
<p>windows下就十分简单了, 启动代理软件, 一般代理软件都有系统代理的选项, 选择启动系统代理,<br>然后运行chrome就行了. </p>
<p>下面附上linux下的过程:<br><img src="update-flash.png" alt="update-flash"></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>flash</tag>
        <tag>版本</tag>
      </tags>
  </entry>
  <entry>
    <title>clickhouse materialized view 踩坑记录</title>
    <url>/2019/12/23/clickhouse-materialized-view-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>最近在使用 clickhouse（下面简称 CH） 的 materialized view（下面简称为 MV）功能，类似其他数据库的物化视图，触发器之类的功能，不过遇到了几点坑，有的通过升级 CH 版本解决了，有的可以在写 sql 的时候小心避免。</p>
<p>先列一下我个人总结出来的使用要点，不想继续看的可以尝试依据这些要点看能否解决自己的问题：</p>
<ol>
<li>在创建 MV 表时，一定要使用 <code>TO</code> 关键字为 MV 表指定存储位置</li>
<li>在创建 MV 表时如果用到了多表联查，不能为连接表指定别名，如果多个连接表中存在同名字段，在连接表的查询语句中使用 AS 将字段名区分开</li>
<li>在创建 MV 表时如果用到了多表联查，只有当第一个查询的表有数据插入时，这个 MV 才会被触发</li>
<li>在创建 MV 表时如果用到了子查询，且子查询会回查 SRC 表，那么这个子查询会回查整个 SRC 表，并不是只有新插入的那部分数据</li>
<li>在创建 MV 表时不要使用 <code>POPULATE</code> 关键字，而是在 MV 表建好之后将数据手动导入 MV 表</li>
</ol>
<hr>
<p>先看看官方的创建 MV 的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [TO[db.]name] [ENGINE &#x3D; engine] [POPULATE] AS SELECT ...</span><br></pre></td></tr></table></figure>

<p>具体的介绍可以阅读官方文档：<a href="https://clickhouse.yandex/docs/en/query_language/create/#create-view">https://clickhouse.yandex/docs/en/query_language/create/#create-view</a></p>
<p>值得一提的虽然官方提供了中文文档，但中文文档内容更新不及时，较英文文档有缺失的部分，还是建议阅读英文的。</p>
<p>我使用 MV 的场景是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SRC -&gt; MV1 -&gt; MV2</span><br></pre></td></tr></table></figure>

<p>MV1 基于 SRC 表，MV2 基于 MV1 表，且 MV2 中包含多表联查，即 MV2 中的查询语句使用了多个 JOIN 语句，来连接从 MV1 中查询出来的多个子表。</p>
<p>遇到的的第一个坑是：</p>
<p>MV2 中的多表联查语句（建表语句中 SELECT 之后的语句）可以手动执行，并使用 <code>INSERT INTO MV2 SELECT ...</code> 语句将结果插入 MV2，但是当通过 MV 功能自动执行这一过程时会报部分列名找不到的错误，自动执行这一过程是指往 SRC 表插入数据，数据会送往 MV1，进而送往 MV2。</p>
<p>起初我使用的 CH 版本是 <code>19.6.2.11</code>，这个版本的 CH 不支持上述问题中的 MV 复杂查询，升级到目前的最新版：<code>19.16.9.37</code> 可以解决，确切的说 MV 的复杂查询是从 <code>19.11.12.69</code> 版本开始支持的，新版本虽然支持了 MV 复杂查询，但是 sql 语法上需要小心：不能为连接表指定别名，如果多个子查询（连接表）中包含同名字段，可以在子查询（连接表）的 SELECT 中使用 <code>AS</code> 为字段名起个别名，然后在 <code>最终选择字段</code> 中使用子表字段的别名。总之就是不能使用表的别名，但可以使用字段的别名。</p>
<p>说起来糊涂，举个例子，假设下面的 SELECT 是 MV2 的建表语句中的 SELECT 部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT A.user_id, A.user_name, B.user_age, C.user_gender</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">    SELECT user_id, user_name</span><br><span class="line">    FROM MV1</span><br><span class="line">) AS A</span><br><span class="line">ALL LEFT JOIN</span><br><span class="line">(</span><br><span class="line">    SELECT user_id, user_age</span><br><span class="line">    FROM MV1</span><br><span class="line">) AS B</span><br><span class="line">ON A.user_id &#x3D; B.user_id</span><br><span class="line">ALL LEFT JOIN</span><br><span class="line">(</span><br><span class="line">    SELECT user_id, user_gender</span><br><span class="line">    FROM MV1</span><br><span class="line">) AS C</span><br><span class="line">ON A.user_id &#x3D; c.user_id</span><br></pre></td></tr></table></figure>

<p>由于 MV2 是基于 MV1 的，上述 sql 在手动往 MV1 插入数据时，就会发生报错，但是数据依旧可以插入 MV1，正确的 sql 写法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT user_id, user_name, user_age, user_gender</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">    SELECT user_id, user_name</span><br><span class="line">    FROM MV1</span><br><span class="line">)</span><br><span class="line">ALL LEFT JOIN</span><br><span class="line">(</span><br><span class="line">    SELECT user_id AS user_id_a, user_age</span><br><span class="line">    FROM MV1</span><br><span class="line">)</span><br><span class="line">ON user_id &#x3D; user_id_a</span><br><span class="line">ALL LEFT JOIN</span><br><span class="line">(</span><br><span class="line">    SELECT user_id AS user_id_b, user_gender</span><br><span class="line">    FROM MV1</span><br><span class="line">)</span><br><span class="line">ON user_id &#x3D; user_id_b</span><br></pre></td></tr></table></figure>

<p>新版本虽然支持了 MV 复杂查询，但是引入了一个新的问题：第二层 MV 获取不到数据，在本例中即当数据插入 SRC 时，数据也可以插入到 MV1，但却无法插入到 MV2，也没有任何提示，看起来像是 MV2 完全不知道 MV1 通过 SRC 插入了新数据。这个功能在我使用的旧版 CH 时是支持的，只是那时候不支持 MV 复杂查询，这个问题相关的 issue 是：<a href="https://github.com/ClickHouse/ClickHouse/issues/7195">https://github.com/ClickHouse/ClickHouse/issues/7195</a>，解决方案我已经在这个 issue 中回复了，在这里再说一下。</p>
<p>说到解决方案就得提一下创建 MV 的两种不同的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法一</span><br><span class="line">CREATE MATERIALIZED VIEW IF NOT EXISTS test_view ENGINE &#x3D; Memory AS SELECT ...</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法二</span><br><span class="line">CREATE TABLE test (定义列) ENGINE Memory;</span><br><span class="line">CREATE MATERIALIZED VIEW IF NOT EXISTS test_view TO test AS SELECT ...</span><br></pre></td></tr></table></figure>

<p>方法一会自动生成一个 CH 内部表，表名以 <code>.inner.</code> 开头，用来存储 MV 的数据。方法二是先创建一个用来存储 MV 数据的表，这个表跟普通的表一样，然后再创建 MV，但使用 <code>TO</code> 关键字为其指定数据存储的位置。</p>
<p>在目前最新版的 CH <code>19.16.9.37</code> 中，方法一在只有一层 MV 时可以正常工作，当有两层乃至多层 MV 时，只有第一层 MV 会收到插入 SRC 中的数据，后面的 MV 不知道有新数据插入，方法二可以避免这个问题。</p>
<p>所以在开头我提到的我的使用场景下，可以正常工作的 MV 建表 sql 大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE src (定义列) ENGINE Memory;</span><br><span class="line">CREATE TABLE foo (定义列) ENGINE Memory;</span><br><span class="line">CREATE MATERIALIZED VIEW IF NOT EXISTS MV1 TO foo AS SELECT ... FROM src WHERE ...</span><br><span class="line">CREATE MATERIALIZED VIEW IF NOT EXISTS MV2 AS SELECT ... FROM foo WHERE ...</span><br></pre></td></tr></table></figure>

<p>但考虑到后期可能会基于 MV2 创建 MV3，所以最好为 MV2 也指定数据存储位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE src (定义列) ENGINE Memory;</span><br><span class="line">CREATE TABLE foo (定义列) ENGINE Memory;</span><br><span class="line">CREATE MATERIALIZED VIEW IF NOT EXISTS MV1 TO foo AS SELECT ... FROM src WHERE ...</span><br><span class="line">CREATE TABLE bar (定义列) ENGINE Memory;</span><br><span class="line">CREATE MATERIALIZED VIEW IF NOT EXISTS MV2 TO bar AS SELECT ... FROM foo WHERE ...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>clickhouse</category>
      </categories>
      <tags>
        <tag>clickhouse</tag>
        <tag>materialized-view</tag>
      </tags>
  </entry>
  <entry>
    <title>clickhouse 部署集群</title>
    <url>/2019/10/25/clickhouse-%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<blockquote>
<p>翻译自 clickhouse 官方入门教程第二节：<a href="https://clickhouse.yandex/tutorial.html">https://clickhouse.yandex/tutorial.html</a></p>
</blockquote>
<h1 id="将-clickhouse-部署到集群"><a href="#将-clickhouse-部署到集群" class="headerlink" title="将 clickhouse 部署到集群"></a>将 clickhouse 部署到集群</h1><p>ClickHouse 集群是一个 homogenous 集群. 设置步骤是: </p>
<ol>
<li>在集群内所有机器上安装 ClickHouse 服务端</li>
<li>在配置文件中设置集群相关的配置</li>
<li>在集群内每台机器上创建本地表</li>
<li>创建分布式表（<a href="https://clickhouse.yandex/docs/en/table_engines/distributed/">Distributed table</a>）</li>
</ol>
<p>在 ClickHouse 集群中分布式表事实上是一种关联到每台机器本地表的 <code>view</code>。对分布式表执行查询将使用集群中所有分片（译者注：一个分片即为集群中的一台机器）的资源。可以为多个集群指定配置，并创建多个分布式表以提供对不同集群的 <code>view</code>。</p>
<p>下面的配置是一个有三个分片的集群，每个分片将数据保存到一个副本中（译者注：数据只有一份，没有副本）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;remote_servers&gt;</span><br><span class="line">    &lt;perftest_3shards_1replicas&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">                &lt;host&gt;example-perftest01j.yandex.ru&lt;&#x2F;host&gt;</span><br><span class="line">                &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">            &lt;&#x2F;replica&gt;</span><br><span class="line">        &lt;&#x2F;shard&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">                &lt;host&gt;example-perftest02j.yandex.ru&lt;&#x2F;host&gt;</span><br><span class="line">                &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">            &lt;&#x2F;replica&gt;</span><br><span class="line">        &lt;&#x2F;shard&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">                &lt;host&gt;example-perftest03j.yandex.ru&lt;&#x2F;host&gt;</span><br><span class="line">                &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">            &lt;&#x2F;replica&gt;</span><br><span class="line">        &lt;&#x2F;shard&gt;</span><br><span class="line">    &lt;&#x2F;perftest_3shards_1replicas&gt;</span><br><span class="line">&lt;&#x2F;remote_servers&gt;</span><br></pre></td></tr></table></figure>
<p>创建本地表（译者注：待确定是否在所有分片上都创建本地表）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE ontime_local (...) ENGINE &#x3D; MergeTree(FlightDate, (Year, FlightDate), 8192);</span><br></pre></td></tr></table></figure>
<p>创建分布式表，提供集群中本地表的 view：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE ontime_all AS ontime_local</span><br><span class="line">    ENGINE &#x3D; Distributed(perftest_3shards_1replicas, default, ontime_local, rand());</span><br></pre></td></tr></table></figure>
<p>可以在集群的每个机器上都创建间一个分布式表。这将允许在集群中的任何一个机器上都能执行分布式查询。除了分布式表还可以使用 <a href="https://clickhouse.yandex/docs/en/table_functions/remote/">remote</a> 表函数。</p>
<p>接下来在分布式表上执行 <a href="https://clickhouse.yandex/docs/en/query_language/queries/#insert">INSERT SELECT</a>，以将该表扩展到多个服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO ontime_all SELECT * FROM ontime;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是，上面给出的方法不适用于大型表的分片。</p>
</blockquote>
<p>可以预期，在3台服务器（而不是1台）上启动繁重的查询，执行速度提高了N倍。</p>
<p><img src="cluster_test.png" alt="cluster_test.png"></p>
<p>你可能已经注意到，分位数计算略有不同。发生这种情况是由于 t-digest 算法的实现是不确定的 – 它取决于数据处理的顺序。</p>
<p>在这个例子中，我们使用了一个包含 3 个分片的集群，每个分片包含一个副本。</p>
<p>为了在生产环境中提供弹性，我们建议每个分片应包含在多个数据中心之间分布的 2-3 个副本。请注意，ClickHouse 支持无限数量的副本。</p>
<p>配置一个包含三个副本的分片集群</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;remote_servers&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;perftest_1shards_3replicas&gt;</span><br><span class="line">        &lt;shard&gt;</span><br><span class="line">            &lt;replica&gt;</span><br><span class="line">                &lt;host&gt;example-perftest01j.yandex.ru&lt;&#x2F;host&gt;</span><br><span class="line">                &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                &lt;host&gt;example-perftest02j.yandex.ru&lt;&#x2F;host&gt;</span><br><span class="line">                &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">             &lt;replica&gt;</span><br><span class="line">                &lt;host&gt;example-perftest03j.yandex.ru&lt;&#x2F;host&gt;</span><br><span class="line">                &lt;port&gt;9000&lt;&#x2F;port&gt;</span><br><span class="line">             &lt;&#x2F;replica&gt;</span><br><span class="line">        &lt;&#x2F;shard&gt;</span><br><span class="line">    &lt;&#x2F;perftest_1shards_3replicas&gt;</span><br><span class="line">&lt;&#x2F;remote_servers&gt;</span><br></pre></td></tr></table></figure>
<p>要启用多副本功能，ZooKeeper 是必需的。 ClickHouse 将负责所有副本上的数据一致性，并在失败后自动运行还原过程。建议将 ZooKeeper 群集部署到单独的服务器。</p>
<p>在某些简单情况下 ZooKeeper 不是必需的，比如你可以通过在应用程序中编码，将数据写入所有副本中来复制数据。但不建议使用此方法，在这种情况下，应由应用程序负责保证所有副本上数据的一致性而不是 ClickHouse。</p>
<p>在配置文件中设置 ZooKeeper：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;zookeeper-servers&gt;</span><br><span class="line">    &lt;node&gt;</span><br><span class="line">        &lt;host&gt;zoo01.yandex.ru&lt;&#x2F;host&gt;</span><br><span class="line">        &lt;port&gt;2181&lt;&#x2F;port&gt;</span><br><span class="line">    &lt;&#x2F;node&gt;</span><br><span class="line">    &lt;node&gt;</span><br><span class="line">        &lt;host&gt;zoo02.yandex.ru&lt;&#x2F;host&gt;</span><br><span class="line">        &lt;port&gt;2181&lt;&#x2F;port&gt;</span><br><span class="line">    &lt;&#x2F;node&gt;</span><br><span class="line">    &lt;node&gt;</span><br><span class="line">        &lt;host&gt;zoo03.yandex.ru&lt;&#x2F;host&gt;</span><br><span class="line">        &lt;port&gt;2181&lt;&#x2F;port&gt;</span><br><span class="line">    &lt;&#x2F;node&gt;</span><br><span class="line">&lt;&#x2F;zookeeper-servers&gt;</span><br></pre></td></tr></table></figure>
<p>另外，我们需要设置宏以识别分片和副本，这将在创建表时使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;macros&gt;</span><br><span class="line">    &lt;shard&gt;01&lt;&#x2F;shard&gt;</span><br><span class="line">    &lt;replica&gt;01&lt;&#x2F;replica&gt;</span><br><span class="line">&lt;&#x2F;macros&gt;</span><br></pre></td></tr></table></figure>
<p>如果在创建新的副本时没有已存在的副本，则将实例化一个新的第一个副本。如果已经存在副本，则新副本将从现有副本中克隆数据。你可以选择先创建所有副本表，然后再向其中插入数据。也可以选择是在数据插入之后或期间创建一些副本并添加其他副本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE ontime_replica (...)</span><br><span class="line">ENGINE &#x3D; ReplicatedMergeTree(</span><br><span class="line">    &#39;&#x2F;clickhouse_perftest&#x2F;tables&#x2F;&#123;shard&#125;&#x2F;ontime&#39;,</span><br><span class="line">    &#39;&#123;replica&#125;&#39;,</span><br><span class="line">    FlightDate,</span><br><span class="line">    (Year, FlightDate),</span><br><span class="line">    8192);</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用 <a href="https://clickhouse.yandex/docs/en/table_engines/replication/#replicatedmergetree">ReplicatedMergeTree</a> 表类型。 在参数中，我们指定包含分片和副本标识符的 ZooKeeper 路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO ontime_replica SELECT * FROM ontime;</span><br></pre></td></tr></table></figure>
<p>复制以多主模式运行。数据可以加载到任何副本中，它将自动与其他副本同步。同步是异步的，因此在给定的时间点上，并非所有副本都包含最近插入的数据。为了允许数据插入，至少应有一个副本。其他副本在变为活动状态后，将同步数据并修复一致性。请注意，这种方案允许最近插入的数据丢失的可能性。</p>
]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>cluster</tag>
        <tag>集群</tag>
        <tag>clickhouse</tag>
      </tags>
  </entry>
  <entry>
    <title>cocos2d-x-3.15缺少libfmod.so.6</title>
    <url>/2017/06/20/cocos2d-x-3-15%E7%BC%BA%E5%B0%91libfmod-so-6/</url>
    <content><![CDATA[<p>cocos2d-x v3.15版, 在linux下编译之后执行test里的demo时报错:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;cpp-tests </span><br><span class="line">.&#x2F;cpp-tests: error while loading shared libraries: libfmod.so.6:</span><br><span class="line">cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>从报错可以看出缺少<code>libfmod.so.6</code>这个库文件, 网上搜索后得知这个文件在:<br><code>$COCOS2D_HOME/external/linux-specific/fmod/prebuilt/64-bit</code>目录下,<br>而且是在执行<code>$COCOS2D_HOME/build/install-deps-linux.sh</code>时发生报错的,</p>
<p>他们的解决办法是将上述目录下的两个库文件<code>libfmod.so</code>和<code>libfmodL.so</code>,<br>复制到<code>/usr/local/lib/</code>目录下, 并创建链接文件, 然后接着执行<code>install-deps-linux.sh</code>,<br>但是这个方法对我没有作用, 可能是因为我是用的系统的缘故<code>(deepin linux)</code>.</p>
<p><font color=red>如果上述方法对你也没用就试试下面的方法:</font><br>复制两个库文件到<code>/usr/lib/</code>目录下, 然后创建链接文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在cocos2d目录下执行</span><br><span class="line">cp external&#x2F;linux-specific&#x2F;fmod&#x2F;prebuilt&#x2F;64-bit&#x2F;* &#x2F;usr&#x2F;lib&#x2F;</span><br><span class="line">cd &#x2F;usr&#x2F;lib</span><br><span class="line">ln -s libfmod.so libfmod.so.6</span><br></pre></td></tr></table></figure>
<p>然后就可以直接测试demo了, 不用重新编译</p>
]]></content>
      <categories>
        <category>cocos2d</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>deepin</tag>
        <tag>cocos2d</tag>
        <tag>libfmod</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言strlen()与sizeof</title>
    <url>/2016/05/04/c%E8%AF%AD%E8%A8%80strlen-%E4%B8%8Esizeof/</url>
    <content><![CDATA[<blockquote>
<p>c语言没有string类型,字符串的处理使用的是char数组<br>c会默认在字符串的尾部增加一个<code>&#39;\0&#39;</code>,也叫空字符(用来标记字符串的结束),所以字符串真正在内存中占用的字节数会比字符串的字符数多1.</p>
</blockquote>
<h1 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h1><p>我们使用strlen()方法可以获取字符串的长度,也就是包含多少个字符数<br>然而获取到的这个字符数并不包含尾部被自动追加的<code>&#39;\0&#39;</code>空字符</p>
<h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h1><p>sizeof 这并不是一个方法,而是一个关键字,用来获得类型的大小,或某个量的大小,这里只讨论获取具体量的大小<br>sizeof获取的是c或者程序员为这个具体量分配了多大的空间(字节数)<br>以字符串,数组char举例:<br>声明了一个20大小的字符串:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">name = jack;</span><br></pre></td></tr></table></figure>
<p>那么<code>sizeof name</code>获得的大小就是20,而不是<code>jack</code>的字符数4,也不是真是占用内存的字节数5<br>而<code>strlen(name)</code>,方法获得的大小则是4,而不是5或者20</p>
<h1 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a>测试源码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST <span class="meta-string">&quot;i am jack&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;type your name:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name is :%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof name is : %ld\n&quot;</span>, <span class="keyword">sizeof</span> name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen name is : %ld\n&quot;</span>, <span class="built_in">strlen</span>(name));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof TEST is : %ld\n&quot;</span>, <span class="keyword">sizeof</span> TEST);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen TEST is : %ld\n&quot;</span>, <span class="built_in">strlen</span>(TEST));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type your name:</span><br><span class="line">jack</span><br><span class="line">name is :jack</span><br><span class="line"><span class="keyword">sizeof</span> name is : <span class="number">20</span></span><br><span class="line"><span class="built_in">strlen</span> name is : <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span> TEST is : <span class="number">10</span></span><br><span class="line"><span class="built_in">strlen</span> TEST is : <span class="number">9</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>strlen</tag>
        <tag>sizeof</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言中的指针</title>
    <url>/2016/05/04/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<blockquote>
<p>1、直接使用指针的表达式，表示使用指针代表的内存地址. <font color=red>(指针存放的数据为内存地址,如同int型变量存放的数据为整数)</font></p>
</blockquote>
<blockquote>
<p>2、在指针表达式前加上符号:<code>*</code>，表示使用指针指向的值，也就是指针所代表的内存地址中存储的值. <font color=red>(<code>*</code>也叫取值运算符或间接运算符,与之对应<code>&amp;</code>为地址运算符,放于正常变量之前可获得变量在内存中的地址,也就是获得一个指向这个变量的指针)</font></p>
</blockquote>
<blockquote>
<p>3、指针也有数据类型</p>
</blockquote>
<blockquote>
<p>4、假设int *opt，那么<code>opt++</code>表示指向下一个整数位置的内存地址<br>，而不是让opt所代表的内存地址在数值上+1；</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> foo1=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *foo2;</span><br><span class="line">foo2=&amp;foo1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*foo2:%d\n&quot;</span>,*foo2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;foo2:%d\n&quot;</span>,foo2);</span><br><span class="line">*foo2=<span class="number">11</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*foo2:%d\n&quot;</span>,*foo2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;foo2:%d\n&quot;</span>,foo2);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*foo2:<span class="number">10</span></span><br><span class="line">foo2:<span class="number">559162276</span></span><br><span class="line">*foo2:<span class="number">11</span></span><br><span class="line">foo2:<span class="number">559162276</span></span><br></pre></td></tr></table></figure>
<p>解释：<br>第一行，声明一个整型的变量foo1，其值为10<br>第二行，声明一个指针foo2，声明指针要使用<code>*</code>符号<br>第三行，获取变量foo1的内存地址，获取变量的地址要使用<code>&amp;</code>符号，并将内存地址赋给指针foo2，也就是让foo2代表(指向)foo1的值在内存中的存储位置<br>第四行，输出<code>*foo2</code>，也就是输出指针foo2所代表的内存地址中存储的值<br>第五行，输出<code>foo2</code>，也就是输出指针foo2所代表的内存地址<br>第六行，让指针foo2所代表的内存地址中存储的值，变为11(注意这里并没有修改指针foo2所代表的内存地址)<br>第七行，输出<code>*foo2</code>，也就是输出指针foo2所代表的内存地址中存储的值<br>第八行，输出<code>foo2</code>，也就是输出指针foo2所代表的内存地址</p>
<blockquote>
<p>注意执行结果，foo2所代表的内存地址中的值，通过<code>*foo2=11;</code>被修改后其内存地址并未发生改变，只是改变了该内存地址中存储的值，而指针foo2依然代表原来的内存地址</p>
</blockquote>
<p><font color=red>如有错误请指出</font></p>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言修饰符static,extern,#define,const</title>
    <url>/2016/05/04/c%E8%AF%AD%E8%A8%80%E4%BF%AE%E9%A5%B0%E7%AC%A6static-extern-define-const/</url>
    <content><![CDATA[<blockquote>
<p>写的比较乱，因为是刚开始学C，没有一个系统的概念，都是想到什么，测试到什么就添加什么，仅供参考<br>而且可能会有错误的地方，如果有请指出</p>
</blockquote>
<h1 id="static：静态"><a href="#static：静态" class="headerlink" title="static：静态"></a>static：静态</h1><h2 id="作用域以及声明方法："><a href="#作用域以及声明方法：" class="headerlink" title="作用域以及声明方法："></a>作用域以及声明方法：</h2><p>1、在函数中声明则仅作用于该函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、在函数外声明则作用于<font color=red>从声明开始到文件末尾</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#extern：引用(其他c文件)</p>
<p>##作用域以及声明方法：<br>1、可以声明变量或函数，并且不必变量初始化或函数定义实现，即可使用，因为引用变量或函数声明时，会同时引用被引用文件内的初始化语句<br>2、被引用的变量或函数不能被static修饰<br>3、相当与引用(复制？)其他文件中的声明和定义/初始化语句到本文件的声明位置<br>4、在本文件使用extern声明变量或函数时，变量或函数名以及函数返回类型和函数参数列表应与要引用的变量或方法一致(经测试，变量不一致时好像类似声明的指针类型变量，方法暂未测试)<br>5、在函数内声明则类似局部变量，作用域仅在本函数，在函数外，作用域从声明处到文件末尾<br>6、如果你是学习C语言的新手，而且暂时只是在使用文本编辑器在写C程序，那么需要注意，在编译有extern语句的C文件时，应该与被引用的文件一起编译(笔者表示在开始时一直在单独编译一个文件所以一直编译报错)<br>比如下面例子的a1.c和b.c，或者a2.c和b.c，编译的时候应该这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc a1.c b.c</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">gcc a2.c b.c</span><br><span class="line"><span class="comment">#这样编译器才能找到被extern的变量或函数</span></span><br></pre></td></tr></table></figure>

<p>不要将a1.c和a2.c以及b.c这三个一起编译，应该将a1.c和b.c一起编译，或者a2.c和b.c一起编译，这是两个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* a1.c */</span></span><br><span class="line"><span class="comment">/* 在文件开始声明(将类似全局变量) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> test1;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">testFun1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">testFun2</span><span class="params">(<span class="keyword">int</span> temp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">20</span>;</span><br><span class="line">    testFun1();</span><br><span class="line">    testFun2(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*####################*/</span></span><br><span class="line"><span class="comment">/* a2.c */</span></span><br><span class="line"><span class="comment">/* 在函数内部声明(将类似局部变量) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFun1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    myFun1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> test1;</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">testFun1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">testFun2</span><span class="params">(<span class="keyword">int</span> temp)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">30</span>;</span><br><span class="line">    testFun1();</span><br><span class="line">    testFun2(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*####################*/</span></span><br><span class="line"><span class="comment">/* b.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> test1=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1 in testFun1():%d\n&quot;</span>,test1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testFun2</span><span class="params">(<span class="keyword">int</span> temp)</span></span>&#123;</span><br><span class="line">    test1=temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1 in testFun2():%d\n&quot;</span>,test1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="“-define”：常量"><a href="#“-define”：常量" class="headerlink" title="“#define”：常量"></a>“#define”：常量</h1><h2 id="作用域以及声明方法：-1"><a href="#作用域以及声明方法：-1" class="headerlink" title="作用域以及声明方法："></a>作用域以及声明方法：</h2><p>1、在函数内声明则作用域仅在本函数，在函数外，作用域从声明处到文件末尾，不过大多在文件头，include语句下声明<br>2、定义后无法再次对其赋值<br>3、声明时末尾不能使用分号结束，不能声明数据类型(也就是没有数据类型)，不能有等号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 另一个例子 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test1();    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> a 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:%d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="const：常量"><a href="#const：常量" class="headerlink" title="const：常量"></a>const：常量</h1><h2 id="作用域以及声明方法：-2"><a href="#作用域以及声明方法：-2" class="headerlink" title="作用域以及声明方法："></a>作用域以及声明方法：</h2><p>1、在函数内声明则作用域仅在本函数，在函数外，作用域从声明处到文件末尾，不过大多在文件头，include语句下声明<br>2、定义后无法再次对其赋值<br>3、需要指定数据类型，并使用等号为其赋值，否则，则只能有默认值(因为在程序其他位置无法再次对其赋值)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>static</tag>
        <tag>extern</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言在函数中修改指针的值</title>
    <url>/2016/11/06/c%E8%AF%AD%E8%A8%80%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BF%AE%E6%94%B9%E6%8C%87%E9%92%88%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<p>继续学习c语言中…</p>
<h1 id="引入话题"><a href="#引入话题" class="headerlink" title="引入话题"></a>引入话题</h1><p>请注意文章标题: 在函数中修改指针的值, 而不是修改指针指向的值<br>修改指针指向的值很容易理解, 在函数参数中声明一个指针类型,<br>然后调用方法的时候把需要修改的值的指针传递过去就行了, 大体如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void test(int *a) &#123;</span><br><span class="line">    *a &#x3D; *a + 1; &#x2F;&#x2F;使用取值运算符让指针a指向的值+1</span><br><span class="line">    printf(&quot;a: %d&quot;, *a);</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int a &#x3D; 0;</span><br><span class="line">    test(&amp;a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a: 1</span><br></pre></td></tr></table></figure>

<p>但本文所要说的是如何修改指针的值, 看下面的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void test(int *a) &#123;</span><br><span class="line">    a &#x3D; a + 1; &#x2F;&#x2F;让指针a的值+1</span><br><span class="line">    if (a !&#x3D; NULL) &#123;</span><br><span class="line">    printf(&quot;test: a不为空\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int *a &#x3D; NULL;</span><br><span class="line">    if (a &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    printf(&quot;main: a为空\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    test(a);</span><br><span class="line">    if (a &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    printf(&quot;main: a为空\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main: a为空</span><br><span class="line">test: a不为空</span><br><span class="line">main: a为空</span><br></pre></td></tr></table></figure>
<p>可以看到虽然在test()方法里修改了指针的值(不是其指向的值),<br>但main()方法中的指针的值并没有改变, 其实这很容易理解,<code>因为指针也是一种变量</code><br>而且在c语言中方法之间传参都是按值传递, 第一个例子之所以成功修改变量a的值,<br>是因为相对于变量a来说是传递了a的地址(按地址传递),<br>但如果相对于指针而言, 则依然是按值传递(传递的a的地址就是指针的值)</p>
<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p>所以如果要通过函数修改传递过去的指针的值, 就得使用指向指针的指针,<br>可以如下声明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明test方法</span><br><span class="line">void test(int **b);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在main中声明指向指针a的指针b</span><br><span class="line">int *a &#x3D; NULL;</span><br><span class="line">int **b &#x3D; NULL;</span><br><span class="line">b &#x3D; &amp;a;</span><br></pre></td></tr></table></figure>
<p>这样调用test方法时将b传过去就行了, 在test()方法中修改b<code>所指向的值</code>,<br>也就是修改了指针a的值</p>
<h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>但上述方法比较容易把人搞糊涂, 所以最明了的方式是让test()方法返回修改后的指针,<br>还是第二个例子, 稍作修改:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int * test(int *a) &#123;</span><br><span class="line">    a &#x3D; a + 1; &#x2F;&#x2F;让指针a的值+1</span><br><span class="line">    if (a !&#x3D; NULL) &#123;</span><br><span class="line">    printf(&quot;test: a不为空\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int *a &#x3D; NULL;</span><br><span class="line">    if (a &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">    printf(&quot;main: a为空\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    a &#x3D; test(a);</span><br><span class="line">    if (a !&#x3D; NULL) &#123;</span><br><span class="line">    printf(&quot;main: a不为空\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main: a为空</span><br><span class="line">test: a不为空</span><br><span class="line">main: a不为空</span><br></pre></td></tr></table></figure>

<p>如果学过传c++, 那么c++中的<code>引用</code>这个概念可以很容易的实现在方法内修改指针,<br>后来才知道c中并没有<code>引用</code>这个东西…</p>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>指针</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言打印乘法口诀和三角</title>
    <url>/2016/05/04/c%E8%AF%AD%E8%A8%80%E6%89%93%E5%8D%B0%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80%E5%92%8C%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<p>打印乘法口诀和三角所用的算法跟java一样,直接上代码</p>
<h1 id="打印乘法口诀"><a href="#打印乘法口诀" class="headerlink" title="打印乘法口诀:"></a>打印乘法口诀:</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d\t&quot;</span>, j, i, i*j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果:</span></span><br><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span>   </span><br><span class="line"><span class="number">1</span>*<span class="number">2</span>=<span class="number">2</span>   <span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span></span><br><span class="line"><span class="number">1</span>*<span class="number">3</span>=<span class="number">3</span>   <span class="number">2</span>*<span class="number">3</span>=<span class="number">6</span>   <span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span></span><br><span class="line"><span class="number">1</span>*<span class="number">4</span>=<span class="number">4</span>   <span class="number">2</span>*<span class="number">4</span>=<span class="number">8</span>   <span class="number">3</span>*<span class="number">4</span>=<span class="number">12</span>  <span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span></span><br><span class="line"><span class="number">1</span>*<span class="number">5</span>=<span class="number">5</span>   <span class="number">2</span>*<span class="number">5</span>=<span class="number">10</span>  <span class="number">3</span>*<span class="number">5</span>=<span class="number">15</span>  <span class="number">4</span>*<span class="number">5</span>=<span class="number">20</span>  <span class="number">5</span>*<span class="number">5</span>=<span class="number">25</span></span><br><span class="line"><span class="number">1</span>*<span class="number">6</span>=<span class="number">6</span>   <span class="number">2</span>*<span class="number">6</span>=<span class="number">12</span>  <span class="number">3</span>*<span class="number">6</span>=<span class="number">18</span>  <span class="number">4</span>*<span class="number">6</span>=<span class="number">24</span>  <span class="number">5</span>*<span class="number">6</span>=<span class="number">30</span>  <span class="number">6</span>*<span class="number">6</span>=<span class="number">36</span></span><br><span class="line"><span class="number">1</span>*<span class="number">7</span>=<span class="number">7</span>   <span class="number">2</span>*<span class="number">7</span>=<span class="number">14</span>  <span class="number">3</span>*<span class="number">7</span>=<span class="number">21</span>  <span class="number">4</span>*<span class="number">7</span>=<span class="number">28</span>  <span class="number">5</span>*<span class="number">7</span>=<span class="number">35</span>  <span class="number">6</span>*<span class="number">7</span>=<span class="number">42</span>  <span class="number">7</span>*<span class="number">7</span>=<span class="number">49</span></span><br><span class="line"><span class="number">1</span>*<span class="number">8</span>=<span class="number">8</span>   <span class="number">2</span>*<span class="number">8</span>=<span class="number">16</span>  <span class="number">3</span>*<span class="number">8</span>=<span class="number">24</span>  <span class="number">4</span>*<span class="number">8</span>=<span class="number">32</span>  <span class="number">5</span>*<span class="number">8</span>=<span class="number">40</span>  <span class="number">6</span>*<span class="number">8</span>=<span class="number">48</span>  <span class="number">7</span>*<span class="number">8</span>=<span class="number">56</span>  <span class="number">8</span>*<span class="number">8</span>=<span class="number">64</span></span><br><span class="line"><span class="number">1</span>*<span class="number">9</span>=<span class="number">9</span>   <span class="number">2</span>*<span class="number">9</span>=<span class="number">18</span>  <span class="number">3</span>*<span class="number">9</span>=<span class="number">27</span>  <span class="number">4</span>*<span class="number">9</span>=<span class="number">36</span>  <span class="number">5</span>*<span class="number">9</span>=<span class="number">45</span>  <span class="number">6</span>*<span class="number">9</span>=<span class="number">54</span>  <span class="number">7</span>*<span class="number">9</span>=<span class="number">63</span>  <span class="number">8</span>*<span class="number">9</span>=<span class="number">72</span>  <span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span></span><br></pre></td></tr></table></figure>

<h1 id="三角-同时输出两个三角-一正一倒"><a href="#三角-同时输出两个三角-一正一倒" class="headerlink" title="三角,同时输出两个三角,一正一倒:"></a>三角,同时输出两个三角,一正一倒:</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 正-倒</span></span><br><span class="line"><span class="comment">     * 1-9</span></span><br><span class="line"><span class="comment">     * 3-7</span></span><br><span class="line"><span class="comment">     * 5-5</span></span><br><span class="line"><span class="comment">     * 7-3</span></span><br><span class="line"><span class="comment">     * 9-1 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (<span class="number">9</span>-i)/<span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=(<span class="number">9</span>-i)/<span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;  j&lt;= (<span class="number">9</span>-(<span class="number">10</span>-i))/<span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;  j&lt;= (<span class="number">10</span>-i); ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;  j&lt;= (<span class="number">9</span>-(<span class="number">10</span>-i))/<span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果:</span></span><br><span class="line">    *           *********</span><br><span class="line">   ***           *******</span><br><span class="line">  *****           *****</span><br><span class="line"> *******           ***</span><br><span class="line">*********           *</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>乘法口诀</tag>
        <tag>三角</tag>
        <tag>打印</tag>
      </tags>
  </entry>
  <entry>
    <title>dde-dock插件开发入门</title>
    <url>/2019/03/16/dde-dock%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>最近公司需要补充一些项目的文档，我负责的几个项目中比较有实用价值的是这个 dde-dock 插件的开发入门教程，这里是转载，<a href="https://github.com/linuxdeepin/dde-dock/blob/master/plugins/plugin-guide/plugins-developer-guide.md">原发</a>在 dde-dock 项目源码中。</p>
<h1 id="插件的工作原理"><a href="#插件的工作原理" class="headerlink" title="插件的工作原理"></a>插件的工作原理</h1><p>插件是一种在不需要改动并重新编译主程序本身的情况下去扩展主程序功能的一种机制。<br>dde-dock 插件是根据 Qt 插件标准所开发的共享库文件(<code>so</code>)，通过实现 Qt 的插件标准和 dde-dock 提供的接口，共同完成 dde-dock 的功能扩展。<br>可以通过以下链接查看关于 Qt 插件更详细的介绍：</p>
<p><a href="https://wiki.qt.io/Plugins">https://wiki.qt.io/Plugins</a><br><a href="https://doc.qt.io/qt-5/plugins-howto.html">https://doc.qt.io/qt-5/plugins-howto.html</a></p>
<h2 id="dde-dock-插件加载流程"><a href="#dde-dock-插件加载流程" class="headerlink" title="dde-dock 插件加载流程"></a>dde-dock 插件加载流程</h2><p>在 dde-dock 启动时会跑一个线程去检测目录<code>/usr/lib/dde-dock/plugins</code>下的所有文件，并检测是否是一个正常的动态库文件，如果是则尝试加载。尝试加载即检测库文件的元数据，插件的元数据定义在一个 JSON 文件中，这个后文会介绍，如果元数据检测通过就开始检查插件是否实现了 dde-dock 指定的接口，这一步也通过之后就会开始初始化插件，获取插件提供的控件，进而将控件显示在任务栏上。</p>
<h2 id="接口列表"><a href="#接口列表" class="headerlink" title="接口列表"></a>接口列表</h2><p>这里先列出 dde-dock 都提供了哪些接口，可作为一个手册查看，注意，为 dde-dock 编写插件并不是要实现所有接口，这些接口提供了 dde-dock 允许各种可能的功能，插件开发者可以根据自己的需求去实现自己需要的接口。后续的插件示例也将会用到这里列出的部分接口。</p>
<p>接口定义的文件一般在系统的如下位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;include&#x2F;dde-dock&#x2F;pluginproxyinterface.h</span><br><span class="line">&#x2F;usr&#x2F;include&#x2F;dde-dock&#x2F;pluginsiteminterface.h</span><br></pre></td></tr></table></figure>

<h3 id="PluginItemInterface"><a href="#PluginItemInterface" class="headerlink" title="PluginItemInterface"></a>PluginItemInterface</h3><p><strong><em>只有标明<code>必须实现</code>的接口是必须要由插件开发者实现的接口，其他接口如果不需要对应功能可不实现。</em></strong></p>
<p>PluginsItemInterface 中定义的接口除了displayMode 和 position（历史遗留），从插件的角度来看都是被动的，只能等待被任务栏的插件机制调用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>pluginName</td>
<td>返回插件名称，用于在 dde-dock 内部管理插件时使用 <code>必须实现</code></td>
</tr>
<tr>
<td>pluginDisplayName</td>
<td>返回插件名称，用于在界面上显示</td>
</tr>
<tr>
<td>init</td>
<td>插件初始化入口函数，参数 proxyInter 可认为是主程序的进程 <code>必须实现</code></td>
</tr>
<tr>
<td>itemWidget</td>
<td>返回插件主控件，用于显示在 dde-dock 面板上 <code>必须实现</code></td>
</tr>
<tr>
<td>itemTipsWidget</td>
<td>返回鼠标悬浮在插件主控件上时显示的提示框控件</td>
</tr>
<tr>
<td>itemPopupApplet</td>
<td>返回鼠标左键点击插件主控件后弹出的控件</td>
</tr>
<tr>
<td>itemCommand</td>
<td>返回鼠标左键点击插件主控件后要执行的命令数据</td>
</tr>
<tr>
<td>itemContextMenu</td>
<td>返回鼠标右键点击插件主控件后要显示的菜单数据</td>
</tr>
<tr>
<td>invokedMenuItem</td>
<td>菜单项被点击后的回调函数</td>
</tr>
<tr>
<td>itemSortKey</td>
<td>返回插件主控件的排序位置</td>
</tr>
<tr>
<td>setSortKey</td>
<td>重新设置主控件新的排序位置（用户拖动了插件控件后）</td>
</tr>
<tr>
<td>itemAllowContainer</td>
<td>返回插件控件是否允许被收纳</td>
</tr>
<tr>
<td>itemIsInContainer</td>
<td>返回插件是否处于收纳模式（仅在 itemAllowContainer 为 true 时有作用）</td>
</tr>
<tr>
<td>setItemIsInContainer</td>
<td>更新插件是否处于收纳模式的状态（仅在 itemAllowContainer 主 true 时有作用）</td>
</tr>
<tr>
<td>pluginIsAllowDisable</td>
<td>返回插件是否允许被禁用（默认不允许被禁用）</td>
</tr>
<tr>
<td>pluginIsDisable</td>
<td>返回插件当前是否处于被禁用状态</td>
</tr>
<tr>
<td>pluginStateSwitched</td>
<td>当插件的禁用状态被用户改变时此接口被调用</td>
</tr>
<tr>
<td>displayModeChanged</td>
<td>dde-dock 显示模式发生改变时此接口被调用</td>
</tr>
<tr>
<td>positionChanged</td>
<td>dde-dock 位置变化时时此接口被调用</td>
</tr>
<tr>
<td>refreshIcon</td>
<td>当插件控件的图标需要更新时此接口被调用</td>
</tr>
<tr>
<td>displayMode</td>
<td>用于插件主动获取 dde-dock 当前的显示模式</td>
</tr>
<tr>
<td>position</td>
<td>用于插件主动获取 dde-dock 当前的位置</td>
</tr>
</tbody></table>
<h3 id="PluginProxyInterface"><a href="#PluginProxyInterface" class="headerlink" title="PluginProxyInterface"></a>PluginProxyInterface</h3><p>由于上面的接口对于插件来说都是被动的，即插件本身无法确定这些接口什么时刻会被调用，很明显这对于插件机制来说是不完整的，因此便有了 PluginProxyInterface，它定义了一些让插件主动调用以控制 dde-dock 的一些行为的接口。PluginProxyInterface 的具体实例可以认为是抽象了的 dde-dock 主程序，或者是 dde-dock 中所有插件的管理员，这个实例将会通过 PluginItemInterface 中的 <code>init</code> 接口传递给插件，因此在上述 <code>init</code> 接口中总是会先把这个传入的对象保存起来以供后续使用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>itemAdded</td>
<td>向 dde-dock 添加新的主控件（一个插件可以添加多个主控件它们之间使用<code>ItemKey</code>区分）</td>
</tr>
<tr>
<td>itemUpdate</td>
<td>通知 dde-dock 有主控件需要更新</td>
</tr>
<tr>
<td>itemRemoved</td>
<td>从 dde-dock 移除主控件</td>
</tr>
<tr>
<td>requestWindowAutoHide</td>
<td>设置 dde-dock 是否允许隐藏，通常被用在任务栏被设置为智能隐藏或始终隐藏而插件又需要让 dde-dock 保持显示状态来显示一些重要信息的场景下</td>
</tr>
<tr>
<td>requestRefreshWindowVisible</td>
<td>通知 dde-dock 更新隐藏状态</td>
</tr>
<tr>
<td>requestSetAppletVisible</td>
<td>通知 dde-dock 显示或隐藏插件的弹出面板（鼠标左键点击后弹出的控件）</td>
</tr>
<tr>
<td>saveValue</td>
<td>统一的配置保存函数</td>
</tr>
<tr>
<td>getValue</td>
<td>统一的配置读取函数</td>
</tr>
</tbody></table>
<h1 id="构建一个-dde-dock-插件"><a href="#构建一个-dde-dock-插件" class="headerlink" title="构建一个 dde-dock 插件"></a>构建一个 dde-dock 插件</h1><p>接下来将介绍一个简单的 dde-dock 插件的开发过程，插件开发者可跟随此步骤熟悉为 dde-dock 开发插件的步骤，以便创造出更多具有丰富功能的插件。</p>
<h2 id="预期功能"><a href="#预期功能" class="headerlink" title="预期功能"></a>预期功能</h2><p>首先来确定下这个插件所需要的功能：</p>
<ul>
<li>实时显示 HOME 分区可使用的剩余大小百分比</li>
<li>允许禁用插件</li>
<li>鼠标悬浮在插件上显示 HOME 分区总容量和可用容量</li>
<li>鼠标左键点击插件显示一个提示框显示关于 HOME 分区更详细的信息</li>
<li>鼠标右键点击插件显示一个菜单用于刷新缓存和启动 gparted 程序</li>
</ul>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>下面以 Qt + cmake 为例进行说明，以 Deepin 15.9 环境为基础，安装如下的包：</p>
<ul>
<li>dde-dock-dev</li>
<li>cmake</li>
<li>qtbase5-dev-tools</li>
<li>pkg-config</li>
</ul>
<h2 id="项目基本结构"><a href="#项目基本结构" class="headerlink" title="项目基本结构"></a>项目基本结构</h2><p>创建必需的项目目录与文件，插件名称叫做<code>home_monitor</code>，所以创建以下的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">home_monitor</span><br><span class="line">├── home_monitor.json</span><br><span class="line">├── homemonitorplugin.cpp</span><br><span class="line">├── homemonitorplugin.h</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>接着来依次分析各个文件的作用。</p>
<h3 id="cmake-配置文件"><a href="#cmake-配置文件" class="headerlink" title="cmake 配置文件"></a>cmake 配置文件</h3><p><code>CMakeLists.txt</code> 是 cmake 命令要读取的配置文件，用于管理整个项目的源文件，依赖，构建等等，其内容如下：</p>
<blockquote>
<p>以<code>#</code>开头的行是注释，用于介绍相关命令，对创建一份新的 CMakeLists.txt 文件会有所帮助，目前可以简单地过一遍</p>
</blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 学习 cmake 时建议直接从命令列表作为入口，遇到不清楚意思的命令都可以在此处查阅：</span></span><br><span class="line"><span class="comment"># https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html</span></span><br><span class="line"><span class="comment"># 另外下面时完整的文档入口：</span></span><br><span class="line"><span class="comment"># https://cmake.org/cmake/help/latest/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置运行被配置所需的 cmake 最低版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 set 命令设置一个变量</span></span><br><span class="line"><span class="keyword">set</span>(PLUGIN_NAME <span class="string">&quot;home_monitor&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目名称</span></span><br><span class="line"><span class="keyword">project</span>(<span class="variable">$&#123;PLUGIN_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 qt moc 的支持</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment"># 启用 qrc 资源文件的支持</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定所有源码文件</span></span><br><span class="line"><span class="comment"># 使用了 cmake 的 file 命令，递归查找项目目录下所有头文件和源码文件，</span></span><br><span class="line"><span class="comment"># 并将结果放入 SRCS 变量中，SRCS 变量可用于后续使用</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SRCS <span class="string">&quot;*.h&quot;</span> <span class="string">&quot;*.cpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要用到的库</span></span><br><span class="line"><span class="comment"># 使用了 cmake 的 find_package 命令，查找库 Qt5Widgets 等，</span></span><br><span class="line"><span class="comment"># REQUIRED 参数表示如果没有找到则报错</span></span><br><span class="line"><span class="comment"># find_package 命令在找到并加载指定的库之后会设置一些变量，</span></span><br><span class="line"><span class="comment"># 常用的有：</span></span><br><span class="line"><span class="comment"># &lt;库名&gt;_FOUND          是否找到（Qt5Widgets_FOUND）</span></span><br><span class="line"><span class="comment"># &lt;库名&gt;_DIR            在哪个目录下找到的（Qt5Widgets_DIR）</span></span><br><span class="line"><span class="comment"># &lt;库名&gt;_INCLUDE_DIRS   有哪些头文件目录（Qt5Widgets_INCLUDE_DIRS）</span></span><br><span class="line"><span class="comment"># &lt;库名&gt;_LIBRARIES      有哪些库文件（Qt5Widgets_LIBRARIES）</span></span><br><span class="line"><span class="keyword">find_package</span>(Qt5Widgets REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(DtkWidget REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># find_package 命令还可以用来加载 cmake 的功能模块</span></span><br><span class="line"><span class="comment"># 并不是所有的库都直接支持 cmake 查找的，但大部分都支持了 pkg-config 这个标准，</span></span><br><span class="line"><span class="comment"># 因此 cmake 提供了间接加载库的模块：FindPkgConfig， 下面这行命令表示加载 FindPkgConfig 模块，</span></span><br><span class="line"><span class="comment"># 这个 cmake 模块提供了额外的基于 “pkg-config” 加载库的能力</span></span><br><span class="line"><span class="comment"># 执行下面的命令后后会设置如下变量，不过一般用不到：</span></span><br><span class="line"><span class="comment"># PKG_CONFIG_FOUND            pkg-config 可执行文件是否找到了</span></span><br><span class="line"><span class="comment"># PKG_CONFIG_EXECUTABLE       pkg-config 可执行文件的路径</span></span><br><span class="line"><span class="comment"># PKG_CONFIG_VERSION_STRING   pkg-config 的版本信息</span></span><br><span class="line"><span class="keyword">find_package</span>(PkgConfig REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 FindPkgConfig 模块后就可以使用 pkg_check_modules 命令加载需要的库</span></span><br><span class="line"><span class="comment"># pkg_check_modules 命令是由 FindPkgConfig 模块提供的，因此要使用这个命令必须先加载 FindPkgConfig 模块。</span></span><br><span class="line"><span class="comment"># 执行 pkg_check_modules 命令加载库也会设置一些类似执行 find_package 加载库后设置的变量：</span></span><br><span class="line"><span class="comment"># DdeDockInterface_FOUND</span></span><br><span class="line"><span class="comment"># DdeDockInterface_INCLUDE_DIRS</span></span><br><span class="line"><span class="comment"># DdeDockInterface_LIBRARIES</span></span><br><span class="line"><span class="comment"># 还有有另外的一些变量以及更灵活的用法，比如一次性查找多个库，这些请自行查找 cmake 文档学习。</span></span><br><span class="line">pkg_check_modules(DdeDockInterface REQUIRED dde-dock)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_definitions 命令用于声明/定义一些编译/预处理参数</span></span><br><span class="line"><span class="comment"># 根据 cmake 文档描述此命令已经有另外几个功能划分的更为细致的命令所取代，具体请查阅文档</span></span><br><span class="line"><span class="comment"># 在我们这里的例子应该使用较新的 add_compile_definitions 命令，不过为了保持与 dock 已有插件一致，</span></span><br><span class="line"><span class="comment"># 暂时仍然使用 add_definitions，add_definitions 的语法很简单就是直接写要定义的 flag 并在前面加上 &quot;-D&quot; 即可</span></span><br><span class="line"><span class="comment"># 括号中的 $&#123;QT_DEFINITIONS&#125; 变量会在执行 cmake 时展开为它的值，这个变量属于历史遗留，应该是在 qt3/qt4 时有用，</span></span><br><span class="line"><span class="comment"># 基于 qt5 或更高版本的新插件不必使用此变量。要查看 qt5 的库定义了哪些变量应该查看变量：$&#123;Qt5Widgets_DEFINITIONS&#125;</span></span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="string">&quot;$&#123;QT_DEFINITIONS&#125; -DQT_PLUGIN&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增一个编译目标</span></span><br><span class="line"><span class="comment"># 这里使用命令 add_library 来表示本项目要生成一个库文件目标，</span></span><br><span class="line"><span class="comment"># 类似的还有命令 add_executable 添加一个可执行二进制目标，甚至 add_custom_target(使用较少) 添加自定义目标</span></span><br><span class="line"><span class="comment"># SHARED 表示生成的库应该是动态库，</span></span><br><span class="line"><span class="comment"># 变量 $&#123;PLUGIN_NAME&#125; 和 $&#123;SRCS&#125; 都是前面处理好的，</span></span><br><span class="line"><span class="comment"># 另外 qrc 资源文件也应该追加在后面以编译进目标中。</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PLUGIN_NAME&#125;</span> SHARED <span class="variable">$&#123;SRCS&#125;</span> home_monitor.qrc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标的生成位置，这里表示生成在执行 make 的目录,</span></span><br><span class="line"><span class="comment"># 另外还有很多可用于设置的属性，可查阅 cmake 文档。</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;PLUGIN_NAME&#125;</span> PROPERTIES LIBRARY_OUTPUT_DIRECTORY ./)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标要使用的 include 目录，即头文件目录</span></span><br><span class="line"><span class="comment"># 变量 $&#123;DtkWidget_INCLUDE_DIRS&#125; 是在前面执行 find_package 命令时引入的</span></span><br><span class="line"><span class="comment"># 当出现编译失败提示找不到某些库的头文件时应该检查此处是否将所有需要的头文件都包含了</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PLUGIN_NAME&#125;</span> PUBLIC</span><br><span class="line">    <span class="variable">$&#123;Qt5Widgets_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="variable">$&#123;DtkWidget_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="variable">$&#123;DdeDockInterface_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标要使用的链接库</span></span><br><span class="line"><span class="comment"># 变量 $&#123;DtkWidget_LIBRARIES&#125; 和 $&#123;Qt5Widgets_LIBRARIES&#125; 是在前面执行 find_package 命令时引入的</span></span><br><span class="line"><span class="comment"># 当出现运行时错误提示某些符号没有定义时应该检查此处是否将所有用的库都写在了这里</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PLUGIN_NAME&#125;</span> PRIVATE</span><br><span class="line">    <span class="variable">$&#123;Qt5Widgets_LIBRARIES&#125;</span></span><br><span class="line">    <span class="variable">$&#123;DtkWidget_LIBRARIES&#125;</span></span><br><span class="line">    <span class="variable">$&#123;DdeDockInterface_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置安装路径的前缀(默认为&quot;/usr/local&quot;)</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_PREFIX <span class="string">&quot;/usr&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置执行 make install 时哪个目标应该被 install 到哪个位置</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS <span class="variable">$&#123;PLUGIN_NAME&#125;</span> LIBRARY DESTINATION lib/dde-dock/plugins)</span><br></pre></td></tr></table></figure>

<h3 id="元数据文件"><a href="#元数据文件" class="headerlink" title="元数据文件"></a>元数据文件</h3><p><code>home_monitor.json</code>文件是插件的元数据文件，指明了当前插件所使用的 dde-dock 的接口版本，dde-dock 在加载此插件时，会检测自己的接口版本是否与插件的接口版本一致，当双方的接口版本不一致或者不兼容时，dde-dock 为了安全将阻止加载对应的插件。另外，元数据文件是在源代码中使用特定的宏加载到插件中的。</p>
<p>在 dde-dock 内建的插件代码中，可以找到当前具体的接口版本，目前最新的版本是 <code>1.2</code> 。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;api&quot;</span>: <span class="string">&quot;1.2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外（可选的）还支持指定一个 dbus 服务，dock 在加载插件时会检查此插件所依赖的 dbus 服务，如果服务没有启动则不会初始化这个插件，直到服务启动，如下表示依赖 dbus 地址为 “com.deepin.daemon.Network” 的 dbus 服务。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;api&quot;</span>: <span class="string">&quot;1.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;depends-daemon-dbus-service&quot;</span>: <span class="string">&quot;com.deepin.daemon.Network&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插件核心类"><a href="#插件核心类" class="headerlink" title="插件核心类"></a>插件核心类</h3><p><code>homemonitorplugin.h</code> 声明了类 <code>HomeMonitorPlugin</code>，它继承（实现）了前面提到的 <code>PluginItemInterface</code>，这代表了它是一个实现了 dde-dock 接口的插件。</p>
<p>下面是最小化实现了一个 dock 插件的源码，只实现了必须实现的接口，请注意，下文的代码只是为了简述开发一个插件的主要过程，详细的示例代码应该查看 <code>home-monitor</code> 目录下的内容。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HOMEMONITORPLUGIN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOMEMONITORPLUGIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dde-dock/pluginsiteminterface.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeMonitorPlugin</span> :</span> <span class="keyword">public</span> QObject, PluginsItemInterface</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="comment">// 声明实现了的接口</span></span><br><span class="line">    Q_INTERFACES(PluginsItemInterface)</span><br><span class="line">    <span class="comment">// 插件元数据</span></span><br><span class="line">    Q_PLUGIN_METADATA(IID <span class="string">&quot;com.deepin.dock.PluginsItemInterface&quot;</span> FILE <span class="string">&quot;home_monitor.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HomeMonitorPlugin</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回插件的名称，必须是唯一值，不可以和其它插件冲突</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> QString <span class="title">pluginName</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插件初始化函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PluginProxyInterface *proxyInter)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回插件的 widget</span></span><br><span class="line">    <span class="function">QWidget *<span class="title">itemWidget</span><span class="params">(<span class="keyword">const</span> QString &amp;itemKey)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HOMEMONITORPLUGIN_H</span></span></span><br></pre></td></tr></table></figure>

<p><code>homemonitorplugin.cpp</code> 中包含对应接口的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;homemonitorplugin.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">HomeMonitorPlugin::HomeMonitorPlugin(QObject *parent)</span><br><span class="line">    : QObject(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> QString <span class="title">HomeMonitorPlugin::pluginName</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QStringLiteral(<span class="string">&quot;home_monitor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HomeMonitorPlugin::init</span><span class="params">(PluginProxyInterface *proxyInter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_proxyInter = proxyInter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QWidget *<span class="title">HomeMonitorPlugin::itemWidget</span><span class="params">(<span class="keyword">const</span> QString &amp;itemKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_UNUSED(itemKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里暂时返回空指针，这意味着插件会被 dde-dock 加载</span></span><br><span class="line">    <span class="comment">// 但是不会有任何东西被添加到 dde-dock 上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试插件加载"><a href="#测试插件加载" class="headerlink" title="测试插件加载"></a>测试插件加载</h2><p>当插件的基本结构搭建好之后应该测试下这个插件能否被 dde-dock 正确的加载，这时候测试如果有问题也可以及时处理。</p>
<h3 id="从源码构建"><a href="#从源码构建" class="headerlink" title="从源码构建"></a>从源码构建</h3><p>为了不污染源码目录，推荐在源码目录中创建 <code>build</code> 目录用于构建：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> home_monitor</span><br><span class="line"></span><br><span class="line">mkdir build</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>执行下面的命令即可将插件安装到系统中，也是 CMakeList.txt 文件指定的安装位置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>可以看到有<code>home_monitor.so</code>文件被安装在了 dde-dock 的插件目录。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">install -m 755 -p ./home_monitor/libhome_monitor.so /usr/lib/dde-dock/plugins/libhome_monitor.so</span><br></pre></td></tr></table></figure>

<h3 id="测试加载"><a href="#测试加载" class="headerlink" title="测试加载"></a>测试加载</h3><p>执行 <code>pkill dde-dock; dde-dock</code> 来重新运行 dde-dock，在终端输出中如果出现以下的输出，说明插件的加载已经正常：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">init plugin:  <span class="string">&quot;home_monitor&quot;</span></span><br><span class="line"></span><br><span class="line">init plugin finished:  <span class="string">&quot;home_monitor&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="创建插件主控件"><a href="#创建插件主控件" class="headerlink" title="创建插件主控件"></a>创建插件主控件</h2><p>创建新文件 informationwidget.h 和 informationwidget.cpp，用于创建控件类：InformationWidget，这个控件用于显示在 dde-dock 上。</p>
<p>此时的目录结构为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">home_monitor</span><br><span class="line"></span><br><span class="line">├── build&#x2F;</span><br><span class="line">├── home_monitor.json</span><br><span class="line">├── homemonitorplugin.cpp</span><br><span class="line">├── homemonitorplugin.h</span><br><span class="line">├── informationwidget.cpp</span><br><span class="line">├── informationwidget.h</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>informationwidget.h 文件内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INFORMATIONWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFORMATIONWIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStorageInfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InformationWidget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InformationWidget</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> QStorageInfo * <span class="title">storageInfo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_storageInfo; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="comment">// 用于更新数据的槽函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refreshInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 真正的数据显示在这个 Label 上</span></span><br><span class="line">    QLabel *m_infoLabel;</span><br><span class="line">    <span class="comment">// 处理时间间隔的计时器</span></span><br><span class="line">    QTimer *m_refreshTimer;</span><br><span class="line">    <span class="comment">// 分区数据的来源</span></span><br><span class="line">    QStorageInfo *m_storageInfo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// INFORMATIONWIDGET_H</span></span></span><br></pre></td></tr></table></figure>

<p>informationwidget.cpp 文件包含了对类 InformationWidget 的实现，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;informationwidget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">InformationWidget::InformationWidget(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">    , m_infoLabel(<span class="keyword">new</span> QLabel)</span><br><span class="line">    , m_refreshTimer(<span class="keyword">new</span> QTimer(<span class="keyword">this</span>))</span><br><span class="line">    <span class="comment">// 使用 &quot;/home&quot; 初始化 QStorageInfo</span></span><br><span class="line">    <span class="comment">// 如果 &quot;/home&quot; 没有挂载到一个单独的分区上，QStorageInfo 收集的数据将会是根分区的</span></span><br><span class="line">    , m_storageInfo(<span class="keyword">new</span> QStorageInfo(<span class="string">&quot;/home&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    m_infoLabel-&gt;setStyleSheet(<span class="string">&quot;QLabel &#123;&quot;</span></span><br><span class="line">                               <span class="string">&quot;color: white;&quot;</span></span><br><span class="line">                               <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    m_infoLabel-&gt;setAlignment(Qt::AlignCenter);</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *centralLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    centralLayout-&gt;addWidget(m_infoLabel);</span><br><span class="line">    centralLayout-&gt;setSpacing(<span class="number">0</span>);</span><br><span class="line">    centralLayout-&gt;setMargin(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    setLayout(centralLayout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接 Timer 超时的信号到更新数据的槽上</span></span><br><span class="line">    <span class="built_in">connect</span>(m_refreshTimer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;InformationWidget::refreshInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Timer 超时为 10s，即每 10s 更新一次控件上的数据，并启动这个定时器</span></span><br><span class="line">    m_refreshTimer-&gt;start(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    refreshInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InformationWidget::refreshInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取分区总容量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> total = m_storageInfo-&gt;bytesTotal();</span><br><span class="line">    <span class="comment">// 获取可用总容量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> <span class="built_in">available</span> = m_storageInfo-&gt;bytesAvailable();</span><br><span class="line">    <span class="comment">// 得到可用百分比</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> percent = qRound(<span class="built_in">available</span> / total * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新内容</span></span><br><span class="line">    m_infoLabel-&gt;setText(QString(<span class="string">&quot;Home:\n%1\%&quot;</span>).arg(percent));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在主控件类已经完成了，回到插件的核心类，将主控件类添加到核心类中。</p>
<p>在 <code>homemonitorplugin.h</code> 中相应位置添加成员声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;informationwidget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeMonitorPlugin</span> :</span> <span class="keyword">public</span> QObject, PluginsItemInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    InformationWidget *m_pluginWidget;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>homemonitorplugin.cpp</code> 中将添加成员的初始化，比如在 <code>init</code> 接口中初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HomeMonitorPlugin::init</span><span class="params">(PluginProxyInterface *proxyInter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_proxyInter = proxyInter;</span><br><span class="line"></span><br><span class="line">    m_pluginWidget = <span class="keyword">new</span> InformationWidget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加主控件到-dde-dock-面板上"><a href="#添加主控件到-dde-dock-面板上" class="headerlink" title="添加主控件到 dde-dock 面板上"></a>添加主控件到 dde-dock 面板上</h2><p>在插件核心类的 <code>init</code> 方法中获取到了 <code>PluginProxyInterface</code> 对象，调用此对象的 <code>itemAdded</code> 接口即可实现向 dde-dock 面板上添加项目。</p>
<p>第二个 <code>QString</code> 类型的参数代表了本插件所提供的主控件的 id，当一个插件提供多个主控件时，不同主控件之间的 id 要保证唯一。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HomeMonitorPlugin::init</span><span class="params">(PluginProxyInterface *proxyInter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_proxyInter = proxyInter;</span><br><span class="line"></span><br><span class="line">    m_pluginWidget = <span class="keyword">new</span> InformationWidget;</span><br><span class="line"></span><br><span class="line">    m_proxyInter-&gt;itemAdded(<span class="keyword">this</span>, pluginName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用 <code>itemAdded</code> 之后，dde-dock 会在合适的时机调用插件的<code>itemWidget</code>接口以获取需要显示的控件。如果插件提供了多个主控件到 dde-dock 上，那么插件核心类应该在 itemWidget 接口中分析参数 itemKey，并返回与之对应的控件对象，当插件只有一个可显示项目时，itemKey 可以忽略 (但不建议忽略)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QWidget *<span class="title">HomeMonitorPlugin::itemWidget</span><span class="params">(<span class="keyword">const</span> QString &amp;itemKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_UNUSED(itemKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_pluginWidget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再根据“测试插件加载”一节中的步骤，编译、安装、重启 dde-dock，就可以看到主控件在 dde-dock 面板上出现了，如下图所示：</p>
<p><img src="central-widget.png" alt="central-widget"></p>
<h2 id="支持禁用插件"><a href="#支持禁用插件" class="headerlink" title="支持禁用插件"></a>支持禁用插件</h2><p>与插件禁用和启用相关的接口有如下三个：</p>
<ul>
<li>pluginIsAllowDisable</li>
<li>pluginIsDisable</li>
<li>pluginStateSwitched</li>
</ul>
<p>故而在插件的核心类头文件中增加这三个接口的声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pluginIsAllowDisable</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pluginIsDisable</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pluginStateSwitched</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p>同时在插件的核心类实现类中增加这三个接口的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HomeMonitorPlugin::pluginIsAllowDisable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 告诉 dde-dock 本插件允许禁用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HomeMonitorPlugin::pluginIsDisable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 第二个参数 “disabled” 表示存储这个值的键（所有配置都是以键值对的方式存储的）</span></span><br><span class="line">    <span class="comment">// 第三个参数表示默认值，即默认不禁用</span></span><br><span class="line">    <span class="keyword">return</span> m_proxyInter-&gt;getValue(<span class="keyword">this</span>, <span class="string">&quot;disabled&quot;</span>, <span class="literal">false</span>).toBool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HomeMonitorPlugin::pluginStateSwitched</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前禁用状态的反值作为新的状态值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> disabledNew = !pluginIsDisable();</span><br><span class="line">    <span class="comment">// 存储新的状态值</span></span><br><span class="line">    m_proxyInter-&gt;saveValue(<span class="keyword">this</span>, <span class="string">&quot;disabled&quot;</span>, disabledNew);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新的禁用状态值处理主控件的加载和卸载</span></span><br><span class="line">    <span class="keyword">if</span> (disabledNew) &#123;</span><br><span class="line">        m_proxyInter-&gt;itemRemoved(<span class="keyword">this</span>, pluginName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m_proxyInter-&gt;itemAdded(<span class="keyword">this</span>, pluginName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就会引入一个新的问题，插件允许被禁用，那么在 dde-dock 启动时，插件有可能处于禁用状态，那么在初始化插件时就不能直接将主控件添加到 dde-dock 中，而是应该判断当前是否是禁用状态，修改接口 init 的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HomeMonitorPlugin::init</span><span class="params">(PluginProxyInterface *proxyInter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_proxyInter = proxyInter;</span><br><span class="line"></span><br><span class="line">    m_pluginWidget = <span class="keyword">new</span> InformationWidget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果插件没有被禁用则在初始化插件时才添加主控件到面板上</span></span><br><span class="line">    <span class="keyword">if</span> (!pluginIsDisable()) &#123;</span><br><span class="line">        m_proxyInter-&gt;itemAdded(<span class="keyword">this</span>, pluginName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新编译、安装、重启 dde-dock，然后 dde-dock 面板上点击鼠标右键查看“插件”子菜单就会看到空白项，点击它将禁用插件，再次点击则启用插件。</p>
<p>不过为什么是空白项呢？是因为有一个接口还没有实现：pluginDisplayName</p>
<p>在相应文件中分别添加如下内容，来修复这个问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> QString <span class="title">pluginDisplayName</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> QString <span class="title">HomeMonitorPlugin::pluginDisplayName</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QString(<span class="string">&quot;Home Monitor&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="disable-plugin.png" alt="disable-plugin"></p>
<h2 id="支持-hover-tip"><a href="#支持-hover-tip" class="headerlink" title="支持 hover tip"></a>支持 hover tip</h2><p>“hover tip” 就是鼠标移动到插件主控件上并悬浮一小段时间后弹出的一个提示框，可以用于显示一些状态信息等待，当然具体用来显示什么完全由插件开发者自己决定，要实现这个功能需要接口：</p>
<ul>
<li>itemTipsWidget</li>
</ul>
<p>首先在插件核心类中添加一个文本控件作为 tip 控件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.h</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    InformationWidget *m_pluginWidget;</span><br><span class="line">    QLabel *m_tipsWidget; <span class="comment">// new</span></span><br></pre></td></tr></table></figure>

<p>在 init 函数中初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HomeMonitorPlugin::init</span><span class="params">(PluginProxyInterface *proxyInter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_proxyInter = proxyInter;</span><br><span class="line"></span><br><span class="line">    m_pluginWidget = <span class="keyword">new</span> InformationWidget;</span><br><span class="line">    m_tipsWidget = <span class="keyword">new</span> QLabel; <span class="comment">// new</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果插件没有被禁用则在初始化插件时才添加主控件到面板上</span></span><br><span class="line">    <span class="keyword">if</span> (!pluginIsDisable()) &#123;</span><br><span class="line">        m_proxyInter-&gt;itemAdded(<span class="keyword">this</span>, pluginName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面在插件核心类中实现接口 itemTipsWidget：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.h</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">QWidget *<span class="title">itemTipsWidget</span><span class="params">(<span class="keyword">const</span> QString &amp;itemKey)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">QWidget *<span class="title">HomeMonitorPlugin::itemTipsWidget</span><span class="params">(<span class="keyword">const</span> QString &amp;itemKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_UNUSED(itemKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置/刷新 tips 中的信息</span></span><br><span class="line">    m_tipsWidget-&gt;setText(QString(<span class="string">&quot;Total: %1G\nAvailable: %2G&quot;</span>)</span><br><span class="line">                          .arg(qRound(m_pluginWidget-&gt;storageInfo()-&gt;bytesTotal() / qPow(<span class="number">1024</span>, <span class="number">3</span>)))</span><br><span class="line">                          .arg(qRound(m_pluginWidget-&gt;storageInfo()-&gt;bytesAvailable() / qPow(<span class="number">1024</span>, <span class="number">3</span>))));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_tipsWidget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dde-dock 在发现鼠标悬停在插件的控件上时就会调用这个接口拿到相应的控件并显示出来。</p>
<p><img src="tips-widget.png" alt="tips-widget"></p>
<h2 id="支持-applet"><a href="#支持-applet" class="headerlink" title="支持 applet"></a>支持 applet</h2><p>上面的 tips 显示的控件在鼠标移开之后就会消失，如果插件需要长时间显示一个窗体及时鼠标离开也会保持显示状态来做一些提示或功能的话那就需要使用 applet，applet 控件在左键点击后显示，点击控件以外的其他地方后消失。</p>
<p>applet 控件其实跟 tip 控件一样都是一个普通的 widget，但是可以在 applet 控件中显示交互性的内容，比如按钮，输入框等等。出于篇幅的原因这里 applet 控件就添加交互性的特性了，只用来显示一些文字，所以依然使用一个 lable 控件。</p>
<p>在插件核心类中添加一个文本控件作为 applet 控件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.h</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    InformationWidget *m_pluginWidget;</span><br><span class="line">    QLabel *m_tipsWidget;</span><br><span class="line">    QLabel *m_appletWidget; <span class="comment">// new</span></span><br></pre></td></tr></table></figure>

<p>在 init 函数中初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HomeMonitorPlugin::init</span><span class="params">(PluginProxyInterface *proxyInter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_proxyInter = proxyInter;</span><br><span class="line"></span><br><span class="line">    m_pluginWidget = <span class="keyword">new</span> InformationWidget;</span><br><span class="line">    m_tipsWidget = <span class="keyword">new</span> QLabel;</span><br><span class="line">    m_appletWidget = <span class="keyword">new</span> QLabel; <span class="comment">// new</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果插件没有被禁用则在初始化插件时才添加主控件到面板上</span></span><br><span class="line">    <span class="keyword">if</span> (!pluginIsDisable()) &#123;</span><br><span class="line">        m_proxyInter-&gt;itemAdded(<span class="keyword">this</span>, pluginName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着实现 applet 相关的接口 itemPopupApplet：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.h</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">QWidget *<span class="title">itemPopupApplet</span><span class="params">(<span class="keyword">const</span> QString &amp;itemKey)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.cpp</span></span><br><span class="line"><span class="function">QWidget *<span class="title">HomeMonitorPlugin::itemPopupApplet</span><span class="params">(<span class="keyword">const</span> QString &amp;itemKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_UNUSED(itemKey);</span><br><span class="line"></span><br><span class="line">    m_appletWidget-&gt;setText(QString(<span class="string">&quot;Total: %1G\nAvailable: %2G\nDevice: %3\nVolume: %4\nLabel: %5\nFormat: %6\nAccess: %7&quot;</span>)</span><br><span class="line">                            .arg(qRound(m_pluginWidget-&gt;storageInfo()-&gt;bytesTotal() / qPow(<span class="number">1024</span>, <span class="number">3</span>)))</span><br><span class="line">                            .arg(qRound(m_pluginWidget-&gt;storageInfo()-&gt;bytesAvailable() / qPow(<span class="number">1024</span>, <span class="number">3</span>)))</span><br><span class="line">                            .arg(QString(m_pluginWidget-&gt;storageInfo()-&gt;device()))</span><br><span class="line">                            .arg(m_pluginWidget-&gt;storageInfo()-&gt;displayName())</span><br><span class="line">                            .arg(m_pluginWidget-&gt;storageInfo()-&gt;name())</span><br><span class="line">                            .arg(QString(m_pluginWidget-&gt;storageInfo()-&gt;fileSystemType()))</span><br><span class="line">                            .arg(m_pluginWidget-&gt;storageInfo()-&gt;isReadOnly() ? <span class="string">&quot;ReadOnly&quot;</span> : <span class="string">&quot;ReadWrite&quot;</span>)</span><br><span class="line">                            );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_appletWidget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译，安装，重启 dde-dock 之后点击主控件即可看到弹出的 applet 控件。</p>
<p><img src="applet-widget.png" alt="applet-widget"></p>
<h2 id="支持右键菜单"><a href="#支持右键菜单" class="headerlink" title="支持右键菜单"></a>支持右键菜单</h2><p>增减右键菜单功能需要实现以下两个接口：</p>
<ul>
<li>itemContextMenu</li>
<li>invokedMenuItem</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.h</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> QString <span class="title">itemContextMenu</span><span class="params">(<span class="keyword">const</span> QString &amp;itemKey)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invokedMenuItem</span><span class="params">(<span class="keyword">const</span> QString &amp;itemKey, <span class="keyword">const</span> QString &amp;menuId, <span class="keyword">const</span> <span class="keyword">bool</span> checked)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// homemonitorplugin.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> QString <span class="title">HomeMonitorPlugin::itemContextMenu</span><span class="params">(<span class="keyword">const</span> QString &amp;itemKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_UNUSED(itemKey);</span><br><span class="line"></span><br><span class="line">    QList&lt;QVariant&gt; items;</span><br><span class="line">    items.reserve(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    QMap&lt;QString, QVariant&gt; refresh;</span><br><span class="line">    refresh[<span class="string">&quot;itemId&quot;</span>] = <span class="string">&quot;refresh&quot;</span>;</span><br><span class="line">    refresh[<span class="string">&quot;itemText&quot;</span>] = <span class="string">&quot;Refresh&quot;</span>;</span><br><span class="line">    refresh[<span class="string">&quot;isActive&quot;</span>] = <span class="literal">true</span>;</span><br><span class="line">    items.push_back(refresh);</span><br><span class="line"></span><br><span class="line">    QMap&lt;QString, QVariant&gt; <span class="built_in">open</span>;</span><br><span class="line">    <span class="built_in">open</span>[<span class="string">&quot;itemId&quot;</span>] = <span class="string">&quot;open&quot;</span>;</span><br><span class="line">    <span class="built_in">open</span>[<span class="string">&quot;itemText&quot;</span>] = <span class="string">&quot;Open Gparted&quot;</span>;</span><br><span class="line">    <span class="built_in">open</span>[<span class="string">&quot;isActive&quot;</span>] = <span class="literal">true</span>;</span><br><span class="line">    items.push_back(<span class="built_in">open</span>);</span><br><span class="line"></span><br><span class="line">    QMap&lt;QString, QVariant&gt; menu;</span><br><span class="line">    menu[<span class="string">&quot;items&quot;</span>] = items;</span><br><span class="line">    menu[<span class="string">&quot;checkableMenu&quot;</span>] = <span class="literal">false</span>;</span><br><span class="line">    menu[<span class="string">&quot;singleCheck&quot;</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 JSON 格式的菜单数据</span></span><br><span class="line">    <span class="keyword">return</span> QJsonDocument::fromVariant(menu).toJson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HomeMonitorPlugin::invokedMenuItem</span><span class="params">(<span class="keyword">const</span> QString &amp;itemKey, <span class="keyword">const</span> QString &amp;menuId, <span class="keyword">const</span> <span class="keyword">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_UNUSED(itemKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据上面接口设置的 id 执行不同的操作</span></span><br><span class="line">    <span class="keyword">if</span> (menuId == <span class="string">&quot;refresh&quot;</span>) &#123;</span><br><span class="line">        m_pluginWidget-&gt;storageInfo()-&gt;refresh();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;open&quot;</span>) &#123;</span><br><span class="line">        QProcess::startDetached(<span class="string">&quot;gparted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译，安装，重启 dde-dock 之后右键点击主控件即可看到弹出右键菜单。</p>
<p><img src="context-menu.png" alt="context-menu"></p>
<p>至此，一个包含基本功能的插件就完成了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>dde-dock</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-CMD-ENTRYPOINT</title>
    <url>/2017/09/13/docker-CMD-ENTRYPOINT/</url>
    <content><![CDATA[<p>一张图解释Dockerfile中CMD和ENTRYPOINT的关系,<br>另外使用’docker run’新建容器时, 镜像后面跟的命令会覆盖Dockerfile中的CMD.<br><img src="docker.png" alt="docker"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>cmd</tag>
        <tag>entrypoint</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 容器起不来怎么办</title>
    <url>/2020/10/07/docker-%E5%AE%B9%E5%99%A8%E8%B5%B7%E4%B8%8D%E6%9D%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<p>有时 docker 容器会由于错误修改了某些配置文件而无法启动，如 <code>entrypoint</code> 脚本或服务程序的配置文件等等，如果容器内没有什么有价值的数据，那么重新创建容器自然是首选，本文讨论的是容器不能被删除，该如何修复这种情况。</p>
<p>容器跑不起来，<code>docker exec</code> 命令就无法运行，这意味着无法进入容器，修正有问题的配置文件；此时可以使用 <code>docker cp</code> 命令，将容器内的出问题的配置文件复制出来到主机上，在主机上修正配置文件后，再使用 <code>docker cp</code> 命令将其复制回容器内，覆盖掉容器内的原文件，此时执行 <code>docker start</code> 命令启动容器就可以了。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker运行php容器网站无法运行</title>
    <url>/2017/09/12/docker%E8%BF%90%E8%A1%8Cphp%E5%AE%B9%E5%99%A8%E7%BD%91%E7%AB%99%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p>使用如下命令启动一个php容器, 并将php项目的目录映射到容器内的apache容器下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80 --name php_app -v &quot;/project/directory&quot;:/var/www/html -d php</span><br></pre></td></tr></table></figure>
<p>然后访问<code>127.0.0.1</code>, 结果网站无法运行, 提示:<code>Permission denied</code>,</p>
<p>进入正在运行的php容器, 去看看项目目录在容器里的权限是什么:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it php_app bash</span><br><span class="line">cd /var/www/html</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>
<p>发现文件的拥有者和属组都无法识别, 直接显示的UID和GID, 都是1000,<br>这是因为项目文件在容器外, 也就是主机本地的拥有者和属组是都是我的用户,<br>而我的用户的UID和GID在主机中是1000,<br>但是php容器里却没有我这个账户, 所以也就无法正常识别所有者了,<br>自然网站无法正常运行. 要想解决这个问题就得知道php这个容器<br>使用的是哪个用户来启动apache和php服务, 经过搜索得知是”www-data”用户,<br>那么修改这个用户的UID和GID为我的就行了(这里都是1000):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupmod -g 1000 www-data &amp;&amp; usermod -u 1000 -g 1000 www-data</span><br></pre></td></tr></table></figure>

<p>然后重启php容器即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart php_app</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
        <tag>权限</tag>
        <tag>permission-denied</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse中DDMS的LOGcat只有一列level</title>
    <url>/2016/05/04/eclipse%E4%B8%ADDDMS%E7%9A%84LOGcat%E5%8F%AA%E6%9C%89%E4%B8%80%E5%88%97level/</url>
    <content><![CDATA[<p>参考<a href="http://stackoverflow.com/questions/25010393/eclipse-logcat-shows-only-the-first-letter-from-each-message">此贴</a>解决此问题。</p>
<p>退出eclipse,打开下面的文件</p>
<p>~/workspace/.metadata/.plugins/org.eclipse.core.runtime/.settings/com.android.ide.eclipse.ddms.prefs</p>
<p>粘贴下面的东西到打开的文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ddms.logcat.auotmonitor.level=error  </span><br><span class="line">ddms.logcat.automonitor=<span class="keyword">false</span>  </span><br><span class="line">ddms.logcat.automonitor.userprompt=<span class="keyword">true</span>  </span><br><span class="line">eclipse.preferences.version=<span class="number">1</span></span><br><span class="line">logcat.view.colsize.Application=<span class="number">169</span></span><br><span class="line">logcat.view.colsize.Level=<span class="number">54</span></span><br><span class="line">logcat.view.colsize.PID=<span class="number">54</span></span><br><span class="line">logcat.view.colsize.Tag=<span class="number">198</span></span><br><span class="line">logcat.view.colsize.Text=<span class="number">619</span></span><br><span class="line">logcat.view.colsize.Time=<span class="number">182</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>eclipse</tag>
        <tag>ddms</tag>
        <tag>logcat</tag>
        <tag>不显示</tag>
      </tags>
  </entry>
  <entry>
    <title>edge 实现 ctrl tab 切换最近标签页</title>
    <url>/2021/08/13/edge-%E5%AE%9E%E7%8E%B0-ctrl-tab-%E5%88%87%E6%8D%A2%E6%9C%80%E8%BF%91%E6%A0%87%E7%AD%BE%E9%A1%B5/</url>
    <content><![CDATA[<p>以前一直在用 firefox 火狐浏览器作为主力浏览器，主要是因为它可以做到不翻墙就实现全平台（linux/mac/windows/android/ios）数据同步，只是 firefox 在 linux 下长时间运行后会变得打开新网页速度很慢，必须要退出程序重新打开才能恢复正常访问速度，给我这种感觉已经很长一段时间了，搜索不到解决方法，自己也没有摸索出来根本原因，但苦于没有更好的选择，只能一直将就下去。</p>
<p>不久前巨硬为 linux 版 edge 浏览器增加了账户同步功能，我终于等来了一个新的，不翻墙全平台数据同步浏览器，虽然是测试版，但巨硬维护很积极，bug 修复更新很及时，相信很快就会发布正式版。</p>
<p>对我来说 edge 浏览器在各个平台上的使用体验都很符合需求，唯独有一点让我很不舒服，就是 ctrl-tab 切换标签页的方式，firefox 浏览器按一下 ctrl-tab 默认会在最近使用的两个标签页中切换，而 edge 则是循环得朝着右边的标签页切换，chrome 也是同样的行为。在搜索这个问题相关的内容时发现，有一部分人觉得这种方式很好，当然也有一部分人和我有同样的感觉，所以这个问题比较主观，并不是说 edge 或 chrome 的切换模式就一定是不好用的。当然 edge 或 chrome 能够像 firefox 一样对这个行为在设置里提供一个修改选项自然是最好的结果。</p>
<p>经过一段时间的摸索，最终找到了一个满足需求的扩展程序，在 edge 和 chrome 的官方扩展仓库中都能找到，链接分别是：</p>
<p><a href="https://microsoftedge.microsoft.com/addons/detail/quickey-%E2%80%93-the-quick-tab-s/mcjciddpjefdpndgllejgcekmajmehnd">https://microsoftedge.microsoft.com/addons/detail/quickey-%E2%80%93-the-quick-tab-s/mcjciddpjefdpndgllejgcekmajmehnd</a></p>
<p><a href="https://chrome.google.com/webstore/detail/quickey-%E2%80%93-the-quick-tab-s/ldlghkoiihaelfnggonhjnfiabmaficg">https://chrome.google.com/webstore/detail/quickey-%E2%80%93-the-quick-tab-s/ldlghkoiihaelfnggonhjnfiabmaficg</a></p>
<p>扩展程序代码仓库是： <a href="https://github.com/fwextensions/QuicKey">https://github.com/fwextensions/QuicKey</a></p>
<p>QuickKey 扩展程序提供了很多丰富的功能，感兴趣的可以自行探索。</p>
<p>针对修改 ctrl-tab 行为的功能并不是默认启用的，需要手动修改一些浏览器配置，官方有详细的文档：<a href="https://fwextensions.github.io/QuicKey/ctrl-tab/">https://fwextensions.github.io/QuicKey/ctrl-tab/</a></p>
<p>下面我筛选出适合我的步骤，并翻译如下，此方法适用于 edge 和 chrome。</p>
<h2 id="使用-ctrl-tab-切换最近标签页"><a href="#使用-ctrl-tab-切换最近标签页" class="headerlink" title="使用 ctrl-tab 切换最近标签页"></a>使用 ctrl-tab 切换最近标签页</h2><p>正常情况下 edge/chrome 不允许设置 ctrl-tab 作为切换标签页的快捷键，但是可以使用开发者工具打破这一限制。（相对于其他方法这是最简单有效的一个方法）</p>
<ol>
<li>根据上面的链接安装 QuickKey 扩展程序</li>
<li>右键点击工具栏上 QuickKey 扩展程序图标，在弹出的菜单中选择“扩展选项”</li>
<li>向下滚动至 <code>Browser keyboard shortcuts</code> 或 <code>Chrome keyboard shortcuts</code></li>
<li>点击 <code>Change browser shortcuts</code> 或 <code>Change Chrome shortcuts</code> 按钮</li>
<li>在打开的新标签页中按 <code>ctrl-shift-J</code>（Windows/Linux）或 <code>cmd-opt-J</code>（macOS）打开开发者工具面板</li>
<li>复制以下代码粘贴到开发者工具面板中，按回车键执行：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chrome.developerPrivate.updateExtensionCommand(&#123;</span><br><span class="line">    extensionId: &quot;mcjciddpjefdpndgllejgcekmajmehnd&quot;,</span><br><span class="line">    commandName: &quot;30-toggle-recent-tabs&quot;,</span><br><span class="line">    keybinding: &quot;Ctrl+Tab&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>到这里就完成了，且已经生效了，可以按 ctrl-tab 快捷键测试下。</p>
<p>注意：如果你使用 edge 浏览器，但却是从 Chrome 扩展程序商店安装的 QuickKey 扩展，那么你需要将上面代码中的 <code>mcjciddpjefdpndgllejgcekmajmehnd</code> 替换为 <code>ldlghkoiihaelfnggonhjnfiabmaficg</code> 也就是修改以下 <code>extensionId</code> 的值。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>chrome</tag>
        <tag>edge</tag>
        <tag>ctrl-tab</tag>
      </tags>
  </entry>
  <entry>
    <title>freedesktop software</title>
    <url>/2021/08/15/freedesktop-software/</url>
    <content><![CDATA[<h2 id="与-freedesktop-org-相关的软件"><a href="#与-freedesktop-org-相关的软件" class="headerlink" title="与 freedesktop.org 相关的软件"></a>与 freedesktop.org 相关的软件</h2><p>下面是一个与 freedesktop.org 相关的不完全软件列表。</p>
<p>你可以去我们的 <a href="https://gitlab.freedesktop.org/">Gitlab 服务</a>查看和下载它们的代码、Bugs、提交合并请求。</p>
<p>freedesktop.org 本身并不每天运行这些项目：我们为自己运行项目的社区提供托管和基础设施。</p>
<p>All projects hosted by us are available under open-source licenses under equitable terms to all parties. These projects do not require Contributor License Agreements which assign more rights to one party than another. They may require an assertion like the Developer’s Certificate of Origin which is simply a more formal document to state that you are leally permitted to contribute under the project’s license; you do not, however, need to assign anyone rights that you do not yourself receive to others’ contributions.</p>
<h2 id="桌面中间件和框架"><a href="#桌面中间件和框架" class="headerlink" title="桌面中间件和框架"></a>桌面中间件和框架</h2><p>这些项目提供了桌面的基础服务。</p>
<ul>
<li>AccountsService 提供本地账户的信息。</li>
<li>D-Bus 是一个详细系统，提供了进程间和服务间通讯。</li>
<li>GeoClue 提供地理位置信息。</li>
<li>PolicyKit 是一个允许非特权应用配置和请求特权服务和接口的工具。</li>
<li>NetworkManager 允许应用发现，配置，连接有线和无线网络。</li>
<li>realmd 允许客户端发现，认证和加入网络（如 Active Directory）。</li>
<li>upower 提供了关于电源设备，如电池和充电状态的信息。</li>
<li>Zeitgeist 是一个桌面事件日志框架。</li>
</ul>
<h2 id="桌面规范和工具"><a href="#桌面规范和工具" class="headerlink" title="桌面规范和工具"></a>桌面规范和工具</h2><p>这些规范和工具定义了跨桌面标准和互通性。</p>
<ul>
<li>desktop-file-utils 提供了一些命令行工具用来处理 .desktop 和 .menu 文件。</li>
<li>icon-theme 包含了一些关于图标主题的标准，还引用了一个叫 hicolor 的默认图标主题。</li>
<li>pyxdg 是一个访问 freedesktop.org 标准的 python 库。</li>
<li>shared-mime-info 是一个包含大量常见 MIME 类型的包，通过将现有的 KDE 和 GNOME 数据库转换为新格式并将它们合并在一起创建，以及基于 share-mime-info 规范的更新数据库的软件。</li>
<li>startup-notification 是启动通知的示例实现（在应用程序完成启动时告诉桌面环境）。</li>
<li>xdg-utils 是一套命令行实用程序，用于简化与自由桌面的整合。它具有创建菜单、打开文件、设置 mime 类型等简单功能。</li>
<li>xdg-user-dirs 是一个处理用户 home 目录下一些标准目录的工具。</li>
</ul>
<h2 id="显卡驱动，窗口系统和支持库"><a href="#显卡驱动，窗口系统和支持库" class="headerlink" title="显卡驱动，窗口系统和支持库"></a>显卡驱动，窗口系统和支持库</h2><p>这些项目允许应用程序在屏幕上渲染图形，包括对 GPU 加速的支持。</p>
<ul>
<li>Beignet 是针对老式英特尔 GPU 的 OpenCL 实现，现在被 NEO 驱动所取代。</li>
<li>Cairo 是一个具有跨设备输出支持的矢量图形库。</li>
<li>DRM 是 Linux 内核图形子系统，在 dri-devel 列表中开发。</li>
<li>drm_hwcomposer 是在 DRM/KMS 设备上运行的 Android HWComposer 的后端。</li>
<li>Mesa 提供了 OpenGL、OpenGL ES、Vulkan、EGL 和 GLX 渲染 API 的硬件加速和软件实现。</li>
<li>Monado 是用于虚拟和增强现实环境和设备的 OpenXR API 的实现。</li>
<li>Nouveau 是 NVIDIA GPU 的逆向工程驱动程序。<ul>
<li>Piglit 是用于 OpenGL 和 OpenGL ES 实现的测试套件。</li>
<li>VirGL 为 VM 内的虚拟客户提供 OpenGL 和 OpenGL ES 加速。</li>
</ul>
</li>
<li>Pixman 是一个低级的纯软件 2D 像素操作和合成库。</li>
<li>Plymouth 在开机启动期间提供启动画面和进度更新。</li>
<li>Wayland 是一个被各种桌面使用的窗口系统。</li>
<li>X.Org 是 X Window 系统的一个实现，称为 X11。<ul>
<li>XCB 为 X11 协议提供了一个低级客户端库。</li>
<li>Xephyr 是一个嵌套的 X11 服务器，主要用于测试。</li>
<li>xrestop 是一个 X Server 资源使用监视器像 “top” 命令一样，它使用 XRes 扩展。</li>
<li>xsettings 提供了配置中心的功能。</li>
<li>X Testing 提供有关用于测试 X 服务器和客户端的各种软件的信息。</li>
<li>xwininfo 是一个窗口信息实用程序，适用于应用程序、工具包和窗口管理器的开发人员。</li>
</ul>
</li>
</ul>
<h2 id="输入、国际化-i18n-和字体渲染"><a href="#输入、国际化-i18n-和字体渲染" class="headerlink" title="输入、国际化 (i18n) 和字体渲染"></a>输入、国际化 (i18n) 和字体渲染</h2><p>这些项目为键盘、鼠标、手写板或其他输入和字体渲染提供了支持。</p>
<ul>
<li>fontconfig 是一个用于配置和自定义字体访问的库。<ul>
<li>Xft 是一个用于客户端字体渲染的库。</li>
</ul>
</li>
<li>libinput 是输入设备的高级包装库，提供对键盘、鼠标、触摸板、触摸屏和手写板的访问。<ul>
<li>libevdev 是输入设备的高级包装库，提供对键盘、指针、触摸板、触摸屏和平板设备的访问。</li>
</ul>
</li>
<li>uchardet 是一个编码检测器库，它从未知字符编码文件中提取字节序列并尝试确定文本的编码。</li>
<li>UTF-8 是一个记录和宣传开源项目使用 UTF-8 编码的项目。</li>
<li>xkeyboard-config 是 XKB 键盘布局的存储库，用于大多数桌面和窗口系统。</li>
</ul>
<h2 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h2><ul>
<li>Bustle 记录并显示 D-Bus 流量的序列图。</li>
<li>CppUnit 是著名的单元测试 JUnit 框架的 C++ 移植。</li>
<li>kmscon 是一个基于 KMS/DRM 的系统控制台。</li>
<li>libbsd 是一个提供 BSD 系统实用功能的库。</li>
<li>pkg-config 是一个用于管理，开发库的编译/链接标志的系统，适用于大多数构建系统。</li>
<li>Slirp 是一种通用 TCP-IP 仿真器，被虚拟机管理程序广泛用于提供虚拟网络服务。</li>
<li>SPICE 提供对虚拟访客的远程访问。</li>
<li>SyncEvolution 在设备和服务之间同步日历和联系人信息。</li>
</ul>
<h2 id="多媒体和图片支持"><a href="#多媒体和图片支持" class="headerlink" title="多媒体和图片支持"></a>多媒体和图片支持</h2><p>这些项目为音频、图像和视频的捕获、回放和流式传输提供支持。</p>
<ul>
<li>Farstream 允许基于网络远程传输多媒体流。</li>
<li>GStreamer 是一个流媒体框架。</li>
<li>libnice 在 NAT 之后使用 ICE 协议在各方之间建立对等连接。</li>
<li>libopenraw 是一个用于 Camera RAW 文件解码和处理的开源库。</li>
<li>libspectre 是 PostScript 渲染库。</li>
<li>media-player-info 描述了外部媒体播放器设备。</li>
<li>Poppler 是一个 PDF 渲染库。</li>
<li>PulseAudio 是一个 sound 系统和API。</li>
<li>VDPAU 提供视频解码加速和高质量视频呈现。</li>
</ul>
<h2 id="其他硬件支持"><a href="#其他硬件支持" class="headerlink" title="其他硬件支持"></a>其他硬件支持</h2><p>这些项目为硬件设备提供了高级支持。</p>
<ul>
<li>cups-pk-helper 供细粒度的 PolicyKit 身份验证集成，以允许用户配置 CUPS 打印服务。</li>
<li>fprint 为各种指纹读取器提供硬件支持。</li>
<li>ModemManager 是一个 DBus 系统服务，它为与移动宽带调制解调器的通信提供统一的高级 API。<ul>
<li>libmbim 是一个较低级别的库，用于管理 MBIM-powered 驱动的移动宽带调制解调器。</li>
<li>libqmi 是一个较低级别的库，用于管理 QMI-powered 驱动的移动宽带调制解调器。</li>
</ul>
</li>
</ul>
<h2 id="其他地方托管的项目"><a href="#其他地方托管的项目" class="headerlink" title="其他地方托管的项目"></a>其他地方托管的项目</h2><p>这些项目以前由 freedesktop.org 托管，但已转移到其他地方。</p>
<ul>
<li>AppStream 是几个主要的GNU/Linux提供者之间的协议（如红帽公司、Canonical公司、SUSE、Debian、Mandriva等），为了要创造Linux上的共同的软件安装程序以及一个统一的软件安装图形用户界面，还有分享元数据。</li>
<li>at-spi2 是一个为应用程序提供可访问性工具信息的框架。</li>
<li>Avahi 是一个多播 dns 网络服务发现库。</li>
<li>Clipart 是一个开源剪贴画存储库。</li>
<li>Cogl 是 OpenGL 和 OpenGL ES 之上的抽象</li>
<li>colord 是一个颜色管理服务。</li>
<li>epoxy 处理 OpenGL 函数指针。</li>
<li>Flatpak 安装、管理和运行沙盒桌面应用程序。</li>
<li>FreeType 是一个 TrueType 字体渲染库。</li>
<li>Galago 是一个桌面状态框架，旨在在程序之间传输状态信息。</li>
<li>FriBidi 是一个实现 Unicode Bidirectional Algorithm（双向算法）并处理了阿拉伯语的库。</li>
<li>HarfBuzz 是通用的 OpenType 布局引擎，由 Pango、Qt 和可能的其他公司共享。</li>
<li>intltool 提供了用于翻译 XML 文件的脚本。</li>
<li>LDTP 是一个 Linux 桌面测试框架。</li>
<li>libburn 是一个开源库套件，用于读取、制作和写入光盘。</li>
<li>libminidump 是一种用于核心转储的压缩格式。</li>
<li>LibreOffice 是一个跨桌面的办公套件。</li>
<li>OHM 是温度和风扇传感器的监视器。</li>
<li>OpenRaster 是一种用于分层光栅图像的文件格式。</li>
<li>p11-glue 是一个 PKCS#11 支持库。</li>
<li>PackageKit 允许用户发现和安装软件包（跨发行版）。</li>
<li>SCIM (Smart Common Input Method) 是一个开发输入法服务的平台。</li>
<li>systemd 是一个完整的系统管理器，包括服务和守护进程管理、日志记录、会话控制等。</li>
<li>Telepathy 是一种实时通信框架（在线状态、消息传递、voice/video-over-IP等）。</li>
<li>Tracker 是一个文件系统索引器、元数据存储系统和搜索工具</li>
<li>udisks 提供一个守护程序、工具和库来访问和操作磁盘、存储设备和技术。</li>
<li>uim 是一种支持多种语言的输入法，重点是中日韩。</li>
<li>VA-API 为所有视频格式提供视频加速 API。</li>
<li>xiccd 是一个X11颜色管理守护程序。</li>
<li>XQuartz 是一个在 Apple MacOS 上运行的X11服务器。</li>
</ul>
<h2 id="不活跃的项目"><a href="#不活跃的项目" class="headerlink" title="不活跃的项目"></a>不活跃的项目</h2><p>这些项目以前托管在这里，但不再维护的。代码可能无法使用，并且可能无法为这些项目提供修复或更改。</p>
<ul>
<li>APOC 提供了配置和策略控制。</li>
<li>CCSS 提供 CSS 解析.</li>
<li>CJK-Unifonts 提供了CJK Unicode TrueType字体，包括Minnan和Hakka语言。</li>
<li>ConsoleKit 提供了登录和会话管理，现在已被 Logind 替换。</li>
<li>Desktop VFS 是针对GUI应用程序的虚拟文件系统。</li>
<li>dolt 是 libtool（与 autoconf automake 一起使用的工具） 的包装器，提高其性能，现在是多余的。</li>
<li>Enchant 是一个跨桌面拼写检查工具。</li>
<li>Eventuality was an “application automation meets cron” type D-Bus based framework for creating a means to schedule arbitrary “actions” performed by conforming apps.</li>
<li>glitz 是 OpenGL 2D 图形库，包括 GPU 加速的 Cairo 后端。</li>
<li>GTK-Qt Theme Engine 旨在统一 GTK 和 Qt 的主题。</li>
<li>Gypsy 是一个守护进程，提供对 GPS 设备的访问。</li>
<li>HAL was an all-encompassing hardware abstraction layer.</li>
<li>Hieroglyph 是一个 PostScript 渲染库。</li>
<li>icon-slicer 是生成图标主题和 libXcursor 游标主题的实用程序。</li>
<li>immodule for Qt 是 Qt 的模块化，可扩展的输入法子系统。</li>
<li>libdlo 是一个用于 DisplayLink USB 图形适配器的用户空间库。</li>
<li>liblazy 封装了一些常见的D-Bus提供了常见的 D-Bus 方法。</li>
<li>liboil 是一个库，为了简化 MMX/SSE/Altivec 扩展的开发和代码维护。</li>
<li>libxklavier 是一个工具库，X keyboard 相关的。</li>
<li>Loudmouth 是一个 XMPP 工具库。</li>
<li>OpenSync 是一个在设备之间提供标准化数据同步的项目。</li>
<li>Papyon 支持 MSN Messenger 协议。</li>
<li>pm-utils 发行版无关的一组管理睡眠和唤醒的脚本。</li>
<li>Razor 试图替换基于 RPM 的系统的 yum 包管理器。</li>
<li>Scratchbox2 是一个交叉汇编环境。</li>
<li>shared-desktop-ontologies was an attempt to define standard NEPOMUK ontologies for the semantic desktop.</li>
<li>Shave 使 AutoTools 构建输出不那么冗余。</li>
<li>swfdec 为 Adobe Flash playback 提供支持。</li>
<li>system-tools-backends 尝试提供发行版无关的系统配置工具。</li>
<li>Tango 提供常见的图标和主题设计指南。</li>
<li>unicode-translation 旨在将 Unicode 字符名称和其他数据翻译成多种语言。</li>
<li>waimea 旨在成为 X 窗系统的标准窗口管理器，使用 Cairo 图形库进行所有渲染。</li>
<li>wmctrl 是一个与兼容 EWMH 的窗口管理器交互的命令行工具。</li>
<li>xfullscreen 是一个对支持全屏模式的应用程序或窗口管理器非常有用的模块。</li>
<li>Xoo 是嵌套 X 服务器的包装器。</li>
<li>xprint 试图为 X11 提供打印服务。</li>
<li>xresponse 是一个测量鼠标点击事件响应时间的工具。</li>
<li>Ytstenut 是一种允许在多个设备之间同步用户活动的协议。</li>
</ul>
<p>翻译自：<a href="https://www.freedesktop.org/wiki/Software/">https://www.freedesktop.org/wiki/Software/</a></p>
]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>freedesktop</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试qt程序时打印qt特有的类型数据</title>
    <url>/2018/10/23/gdb%E8%B0%83%E8%AF%95qt%E7%A8%8B%E5%BA%8F%E6%97%B6%E6%89%93%E5%8D%B0qt%E7%89%B9%E6%9C%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>如果没有使用 qtcreator 调试 qt 程序，而是手动或利用其他 IDE 使用 gdb 调试，会发现 qt 类型的数据如 QString QList QMap 等不能直接查看其值。其实 gdb 是提供了关于打印数据的接口的，叫做 <code>Pretty-Printer</code>，这是一种利用 python 代码更好的输出变量数据的机制，感兴趣的可以搜索下相关内容。qtcreator 之所以可以愉快的打印出 qt 相应的数据也是因为它使用了这种机制，下面的命令可以查看 qtcreator 的安装目录中的 python 文件，命令在 debian 系的 linux 系统上有效:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt-file show qtcreator-data | grep py</span></span><br><span class="line">qtcreator-data: /usr/share/doc/qtcreator-data/copyright</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/boosttypes.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/cdbbridge.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/creatortypes.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/dumper.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/gdbbridge.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/lldbbridge.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/misctypes.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/opencvtypes.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/pdbbridge.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/personaltypes.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/qttypes.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/debugger/stdtypes.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/qml/qmlpuppet/qml2puppet/instances/nodeinstancesignalspy.cpp</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/qml/qmlpuppet/qml2puppet/instances/nodeinstancesignalspy.h</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/templates/wizards/classes/python/file.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/templates/wizards/classes/python/wizard.json</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/templates/wizards/files/python/file.py</span><br><span class="line">qtcreator-data: /usr/share/qtcreator/templates/wizards/files/python/wizard.json</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>/usr/share/qtcreator/debugger/</code> 目录下关于 qtcreator 对 debug 所做的优化，不过不知道为什么直接使用 qtcreator 提供的 qt 类型相关的脚本没有成功(有成功的可以在下面回复方法指点一下)。因此又在 github 上搜索相关内容找到了另一个 qt 相关的 Pretty-Print 脚本，项目地址为：<a href="https://github.com/Lekensteyn/qt5printers">https://github.com/Lekensteyn/qt5printers</a>，在 linux 系统下具体使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆项目到~/.git/qt5printers目录下</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:Lekensteyn/qt5printers.git ~/.git/qt5printers</span><br></pre></td></tr></table></figure>

<p>复制以下内容到<code>~/.gdbinit</code>文件中，若文件不存在则手动创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> sys, os.path</span><br><span class="line">sys.path.insert(<span class="number">0</span>, os.path.expanduser(<span class="string">&#x27;~/.gdb&#x27;</span>))</span><br><span class="line"><span class="keyword">import</span> qt5printers</span><br><span class="line">qt5printers.register_printers(gdb.current_objfile())</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>做完之后就可以 debug 一个 qt 程序测试了</p>
]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>getDuration()获取媒体总长度值为-1</title>
    <url>/2016/05/04/getDuration-%E8%8E%B7%E5%8F%96%E5%AA%92%E4%BD%93%E6%80%BB%E9%95%BF%E5%BA%A6%E5%80%BC%E4%B8%BA-1/</url>
    <content><![CDATA[<p>例如VideoView获取视频总长度：<br>在视频播放前获取到的视频总长度都为-1<br>想要在视频播放前获取到总长度的话:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">videoView.setOnPreparedListener(<span class="keyword">new</span> MyOnPreparedListener());</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOnPreparedListener</span> <span class="keyword">implements</span> <span class="title">OnPreparedListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPrepared</span><span class="params">(MediaPlayer mp)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">            video.getDuration();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>getDuration</tag>
        <tag>视频总长度</tag>
        <tag>videoview</tag>
        <tag>mediaplayer</tag>
      </tags>
  </entry>
  <entry>
    <title>git-找回已删除的分支</title>
    <url>/2018/10/04/git-%E6%89%BE%E5%9B%9E%E5%B7%B2%E5%88%A0%E9%99%A4%E7%9A%84%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<p>手残总是难免的，有时候不小心删掉了一个还没有合并或者push的分支，等反应过来似乎已经找不到这个分支在仓库中存在的痕迹了。</p>
<p>这时<code>git reflog</code>命令就体现出了它的价值，其实git会把我们在仓库里的所有操作都记录下来，<br>从<code>git reflog</code>命令的输出就可以看到，就算是从分支A切换到分支B也会被记录下来，那么假设，分支B被误删，<br>执行<code>git reflog</code>命令后就可以找到分支B的痕迹: “commit id”，不管是从其他分支切换到分支B，还是分支B的一个提交记录，<br>都会看到其”commit id”，复制这个”commit id”然后切换过去，此时仓库处于分离头指针状态，其实现在已经是在分支B了，<br>只需要从当前状态创建一个分支，那么分支B也就复活了： <code>git checkout -b B-reborn</code><br>这个分支<code>B-reborn</code>就是先前删除的分支B。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hides overloaded virtual function</title>
    <url>/2018/10/04/hides-overloaded-virtual-function/</url>
    <content><![CDATA[<p>在<code>重载</code>父类的同名虚函数时会出现<code>hides overloaded virtual function</code>编译警告。<br>从字面上的意思其实就可以理解：重载的虚函数被隐藏了。</p>
<p>三个关键点：</p>
<ul>
<li>重载</li>
<li>虚函数</li>
<li>隐藏</li>
</ul>
<p>这个编译警告之所以出现，是因为上面三个关键点，首先是发生了<code>重载</code>，子类重载了父类的函数，其次被重载的是虚函数，这时这个被重载的父类的虚函数将会被隐藏。<br>何为隐藏呢，应该是不能使用子类实例直接调用父类被隐藏的函数，调用时必须指定父类命名空间，往深了说也就是编译器如果在子类中发现了要使用的函数的名字，注意，是名字不包含函数签名，只要名字匹配上，就不会再去父类中去寻找这个名字的函数，即便子类中的函数参数不匹配，也不会再去父类中寻找。</p>
<p>其实去掉<code>虚函数</code>这个关键点，在c++中当重载了父类的函数时，隐藏同样会发生，举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;foo of A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;foo of B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B *b = <span class="keyword">new</span> B();</span><br><span class="line">    b-&gt;foo(); <span class="comment">//编译报错</span></span><br><span class="line">    b-&gt;A::foo(); <span class="comment">//应该指定命名空间A::</span></span><br><span class="line">    b-&gt;foo(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当重载的父类函数为虚函数时，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="comment">//将父类函数声明为虚函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;foo of A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">//此处会有编译警告：&quot;&#x27;B::foo&#x27; hides overloaded virtual function&quot;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;foo of B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B *b = <span class="keyword">new</span> B();</span><br><span class="line">    b-&gt;foo(); <span class="comment">//编译报错依旧</span></span><br><span class="line">    b-&gt;A::foo(); <span class="comment">//应该指定命名空间A::</span></span><br><span class="line">    b-&gt;foo(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译错误依旧，但多了一个编译警告，关于这个编译警告，有种解释说是为了避免书写错误，这就要说到多态，上面的例子没有应用多态有些不合适，修改一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookA</span>;</span> <span class="comment">//改动处</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookB</span>;</span> <span class="comment">//改动处</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(BookA *)</span> </span>&#123; <span class="comment">//改动处</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;foo of A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(BookB *)</span> </span>&#123; <span class="comment">//改动处</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;foo of B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *b = <span class="keyword">new</span> B(); <span class="comment">//改动处</span></span><br><span class="line">    b-&gt;foo(<span class="keyword">new</span> BookB());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之前的例子的区别是多声明了两个类：<code>BookA</code>和<code>BookB</code>，函数的参数类型换成了这两个类，<strong>最重要的一点是<code>main</code>函数中将实例B声明为了A类型</strong>，此时就可以比较清晰的看出为什么这个警告是为了书写错误：</p>
<p>假设我们就是要在B类中重写父类A的<code>void foo(BookA *)</code>函数，以便在<code>main</code>函数中实现以类型A的实例去调用B对象的重写函数(多态调用)，但却因为书写错误，把B类行的函数的参数写成了<code>BookB *</code>，这就与初衷不符了，此时这个编译警告就是有价值的了。</p>
<p>再假设，我们就是要在B类中声明<code>void foo(BookB *)</code>这么一个函数，且并不是为了重写父类中的函数，那么此时这个编译警告就是多余的，我们可以使用<code>using</code>来避免这个警告，例如在类B中做出如下声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::foo;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(BookB *)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;foo of B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就是告诉编译器，我们明确要使用这两个函数，并不是为了重写，这样有一个可能不期望出现的情况，就是B的实例也可调用<code>void foo(BookA *)</code>函数，如果不想这个情况发生，可以把<code>using</code>放到私有的里面，这样既解决了编译警告，又不会暴露父类的这个函数出去：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(BookB *)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;foo of B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> A::foo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考了一个帖子：<br><a href="https://stackoverflow.com/questions/18515183/c-overloaded-virtual-function-warning-by-clang">https://stackoverflow.com/questions/18515183/c-overloaded-virtual-function-warning-by-clang</a></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>virtual</tag>
      </tags>
  </entry>
  <entry>
    <title>hybrid-sleep和sleep以及hibernate的区别</title>
    <url>/2016/05/04/hybrid-sleep%E5%92%8Csleep%E4%BB%A5%E5%8F%8Ahibernate%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="bybrid-sleep"><a href="#bybrid-sleep" class="headerlink" title="bybrid-sleep"></a>bybrid-sleep</h1><p>混合休眠模式:<br>是指电脑sleep(睡眠模式)和hibernate(休眠模式)同时进行,即把信息保存到内存的同时也写入到系统主分区的hiberfil.sys文件中</p>
<h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><p>睡眠模式,linux下也叫挂起(suspend):<br>把信息到存到内存中,但不能断电,断电后数据丢失,恢复最快</p>
<h1 id="hibernate"><a href="#hibernate" class="headerlink" title="hibernate"></a>hibernate</h1><p>休眠模式:<br>把信息写入到文件中,也就是硬盘中,不会有断电丢失数据的问题,但恢复时最慢,和重新开机一样</p>
<h1 id="对比图表"><a href="#对比图表" class="headerlink" title="对比图表:"></a>对比图表:</h1><p><img src="duibi.png" alt="duibi"></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>hybrid-slep</tag>
        <tag>sleep</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>java中this和.this</title>
    <url>/2016/04/22/java%E4%B8%ADthis%E5%92%8C-this/</url>
    <content><![CDATA[<p>“this”是指(或者说:所代表的是)当前这段代码所在的类的对象,<br>而”类名.this”是指”类名”的对象(一般在匿名类或内部类中使用来调用外部类的方法或属性)</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> method（）&#123;</span><br><span class="line">                A.<span class="keyword">this</span>  <span class="comment">//这里的&quot;A.this&quot;就是表示类&quot;A&quot;的对象,在这种情况下&quot;A.this&quot;和&quot;this&quot;是一样的</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         <span class="class"><span class="keyword">class</span>  <span class="title">B</span> </span>&#123;  <span class="comment">//&quot;class A&quot;中的一个内部类&quot;B&quot;(内部类也可以是使用关键字&quot;new&quot; 所新实例出来的一个匿名类或者接口,比如&quot;new OnClickListener()&quot;)</span></span><br><span class="line">                  <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                             A.<span class="keyword">this</span>  <span class="comment">//这里的&quot;A.this&quot;还是表示类&quot;A&quot;的对象。。但是这里是在内部类里面。。所以这里如果使用的是&quot;this&quot;那就是内部类B的对象了。。但是我们经常会在内部类里面调用外部的东西。。所以就用&quot;A.this&quot;这种方式就行了</span></span><br><span class="line">                   &#125;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>java中获取一个子字符串中出现的次数</title>
    <url>/2016/05/04/java%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<p>假设要得到字符串B在字符串A中出现的次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设字符串A和B已声明并赋值</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fromIndex=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(fromIndex!=-<span class="number">1</span>)&#123;</span><br><span class="line">    fromIndex=A.indexOf(B,fromIndex);</span><br><span class="line">    <span class="keyword">if</span>(fromIndex!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fromIndex+=B.length();;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure>
<p>主要用到的就是一个字符串对象的indexOf()方法</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>字符串</tag>
        <tag>次数</tag>
      </tags>
  </entry>
  <entry>
    <title>java字符输入输出流在输出结尾多一个乱码字符:&#39;?&#39;</title>
    <url>/2016/04/23/java%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%9C%A8%E8%BE%93%E5%87%BA%E7%BB%93%E5%B0%BE%E5%A4%9A%E4%B8%80%E4%B8%AA%E4%B9%B1%E7%A0%81%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>原因以及解决方法：</p>
<p>核心方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">         FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">         FileWriter fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         int b=0;</span></span><br><span class="line"><span class="comment">         while(b!=-1)&#123;</span></span><br><span class="line"><span class="comment">             b=fr.read();</span></span><br><span class="line"><span class="comment">             System.out.print(&quot;-&quot;+(char)b);</span></span><br><span class="line"><span class="comment">             fw.write(b);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         用这种方法会比下面的方法在最后的文本后面多出一个乱码&#x27;?&#x27;</span></span><br><span class="line"><span class="comment">         因为当读取到最后一个字符时，b此时还不等于-1，判断后会接着读取</span></span><br><span class="line"><span class="comment">         下一个字符，但在上一次读取时已读取到最后一个字符，所以这次</span></span><br><span class="line"><span class="comment">         就什么都读取不到(产生乱码)，并返回-1，结束循环</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> b;</span><br><span class="line">         <span class="keyword">while</span>((b=fr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">             System.out.print(<span class="string">&quot;-&quot;</span>+(<span class="keyword">char</span>)b);</span><br><span class="line">             fw.write(b);</span><br><span class="line">　　　　　　<span class="comment">//这个方法的优点在于它会在读取的同时判断是否执行方法体</span></span><br><span class="line">         &#125;</span><br><span class="line">         fr.close();</span><br><span class="line">         fw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>乱码字符</tag>
        <tag>输出流</tag>
        <tag>输入流</tag>
      </tags>
  </entry>
  <entry>
    <title>java打印三角和乘法口诀</title>
    <url>/2016/05/04/java%E6%89%93%E5%8D%B0%E4%B8%89%E8%A7%92%E5%92%8C%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印正三角</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">helloworld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String cell=<span class="string">&quot;*&quot;</span>;</span><br><span class="line">        String space=<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lines=<span class="number">1</span>; lines&lt;=<span class="number">9</span>; lines++) &#123;</span><br><span class="line">            <span class="comment">// 只有偶数时才打印</span></span><br><span class="line">            <span class="keyword">if</span> (lines%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 打印空格</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> spaces=<span class="number">1</span>; spaces&lt;=(<span class="number">9</span>-lines)/<span class="number">2</span>; spaces++) &#123;</span><br><span class="line">                    System.out.print(space);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印三角</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> cells=<span class="number">1</span>; cells&lt;=lines; cells++) &#123;</span><br><span class="line">                    System.out.print(cell);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印空格</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> spaces=<span class="number">1</span>; spaces&lt;=(<span class="number">9</span>-lines)/<span class="number">2</span>; spaces++) &#123;</span><br><span class="line">                    System.out.print(space);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印倒三角</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">helloworld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String cell=<span class="string">&quot;*&quot;</span>;</span><br><span class="line">        String space=<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lines=<span class="number">9</span>; lines&gt;=<span class="number">1</span>; lines--) &#123;</span><br><span class="line">            <span class="comment">// 只有偶数时才打印</span></span><br><span class="line">            <span class="keyword">if</span> (lines%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 打印空格</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> spaces=<span class="number">1</span>; spaces&lt;=(<span class="number">9</span>-lines)/<span class="number">2</span>; spaces++) &#123;</span><br><span class="line">                    System.out.print(space);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印三角</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> cells=<span class="number">1</span>; cells&lt;=lines; cells++) &#123;</span><br><span class="line">                    System.out.print(cell);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印空格</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> spaces=<span class="number">1</span>; spaces&lt;=(<span class="number">9</span>-lines)/<span class="number">2</span>; spaces++) &#123;</span><br><span class="line">                    System.out.print(space);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印乘法口诀</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">helloworld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lines=<span class="number">1</span>; lines&lt;=<span class="number">9</span>; lines++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> columns=<span class="number">1</span>; columns&lt;=lines; columns++) &#123;</span><br><span class="line">                System.out.print(columns+<span class="string">&quot;*&quot;</span>+lines+<span class="string">&quot;=&quot;</span>+columns*lines+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附上图片:<br><img src="zsanjiao.png" alt="正三角"><br><img src="dsanjiao.png" alt="倒三角"><br><img src="koujue.png" alt="乘法口诀"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>乘法口诀</tag>
        <tag>三角</tag>
        <tag>打印</tag>
      </tags>
  </entry>
  <entry>
    <title>jsp-android使用http</title>
    <url>/2016/04/23/jsp-android%E4%BD%BF%E7%94%A8http/</url>
    <content><![CDATA[<blockquote>
<p>先说两种客户端发送http到服务端、然后再说服务端如何处理</p>
</blockquote>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>首先客户端有两种方式可以发送http请求<br>当然还有其他方式，这里只讨论这两种方式:</p>
<h2 id="doget方式"><a href="#doget方式" class="headerlink" title="doget方式"></a>doget方式</h2><p>客户端中先使用“url?name1=value1&amp;&amp;name2=value2&amp;&amp;….”来new出<font color=red><strong>HttpGet</strong></font>的对象<br>使用<font color=red><strong>HttpClient</strong></font>的对象：<font color=red><strong>deafultHttpClient</strong></font>来发送<font color=red><strong>HttpGet</strong></font>的对象到服务端、同时将会获得服务器返回的<font color=red><strong>HttpResponse</strong></font>对象、<br>接着<font color=red><strong>HttpResponse</strong></font>对象调用getEntity()来获取服务端发送过来的信息</p>
<h2 id="dopost方式"><a href="#dopost方式" class="headerlink" title="dopost方式"></a>dopost方式</h2><p>客户端先使用URL来new出<font color=red><strong>HttpPost</strong></font>的对象<br>接着使用NameValuePair来保存要传递的Post的参数<br>可以使用集合框架、例如new一个<font color=red><strong>List<NameValuePair></strong></font>的对象<font color=red><strong>params</strong></font>、并使用其<code>add(new BasicNameValuePair(&quot;name&quot;,&quot;value&quot;))</code>方法来将数据保存起来、</p>
<p>此时还不能直接发送、要将<font color=red><strong>params</strong></font>放到<font color=red><strong>HttpPost</strong></font>的对象中才行、然而<font color=red><strong>List<NameValuePair></strong></font>类型的<font color=red><strong>params</strong></font>并不能直接被放置到<font color=red><strong>HttpPost</strong></font>中</p>
<p>需要转换成另一种类型的数据：<font color=red><strong>HttpEntity</strong></font>、在转换的同时还可以设置一下编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpEntity httpEntity=<span class="keyword">new</span> UrlEncodedFormEntity(<span class="string">&quot;params&quot;</span>,<span class="string">&quot;GB2312&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>将数据参数放置到<font color=red><strong>HttpPost</strong></font>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">httpPost.setEntity(httpEntity);</span><br></pre></td></tr></table></figure>
<p>使用<font color=red><strong>HttpClient</strong></font>的对象：<font color=red><strong>deafultHttpClient</strong></font>来发送<font color=red><strong>HttpPost</strong></font>的对象到服务端、同时将会获得<font color=red><strong>HttpResponse</strong></font>对象、</p>
<p>接着<font color=red><strong>HttpResponse</strong></font>对象调用<font color=red><strong>getEntity()</strong></font>来获取服务端发送过来的信息</p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>服务端接收数据比较简单<br>首先设置下请求编码防止中文乱码<br>然后使用request对象来获取参数就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String username=request.getParameter(<span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jsp</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>jsp</tag>
        <tag>http</tag>
        <tag>httpget</tag>
        <tag>httppost</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s dashboard 无法登陆</title>
    <url>/2020/04/15/k8s-dashboard-%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<p>先说环境：<br>两节点 k8s 集群，一台 master，k8s 版本为 <code>1.18.1</code>，所使用的 dashboard 版本为 <code>v2.0.0-rc7</code></p>
<p>dashboard 安装方法直接按照官网所说的执行即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete ns kubernetes-dashboard</span><br><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.0.0-rc7&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml</span><br></pre></td></tr></table></figure>

<p>现在 dashboard 已经部署好了，问题是如何访问 dashboard 服务，首先新版的 dashboard 将默认权限控制到了最小，只够 dashboard 部署，要想正常访问 dashboard 服务需要按照下面这个官方文档对其进行授权和创建管理员账户：<br><a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md">https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md</a></p>
<p>如果不想细看，可以直接将如下代码保存至 <code>dashboard-admin.yaml</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f dashboard-admin.yaml</span><br></pre></td></tr></table></figure>

<p>接着获取创建的 admin 账户的 token：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#39;&#123;print $1&#125;&#39;)</span><br></pre></td></tr></table></figure>

<p>拿到 token 开始将 dashboard 服务暴露出来，有两种方式：</p>
<ul>
<li>方式一 proxy 反向代理</li>
</ul>
<p>需要注意的是使用这种方式只能是在本机访问（服务也必须在本机），因为目前 dashboard 不支持除 <code>localhost</code> 和 <code>127.0.0.1</code> 以外的主机名登录进入控制台（ <a href="https://github.com/kubernetes/dashboard/issues/4624">https://github.com/kubernetes/dashboard/issues/4624</a> ），这意味着无法从集群外通过浏览器打开 dashboard，表示不懂这种设计，这样的 dashboard 还有什么用？如果是我理解不正确，请留言指正。</p>
<p>执行如下命令启动代理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure>

<p>然后在浏览器访问（注意必须是 http）：</p>
<p><a href="http://127.0.0.1:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy">http://127.0.0.1:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy</a></p>
<ul>
<li>方式二 端口转发</li>
</ul>
<p>执行如下命令进行端口转发：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo kubectl port-forward --namespace kubernetes-dashboard --address 0.0.0.0 service&#x2F;kubernetes-dashboard 443</span><br></pre></td></tr></table></figure>

<p>然后在集群外的机器上访问进行端口转发的那台机器的 ip 即可（注意必须是 https）：</p>
<p><a href="https://yournodeip/">https://YourNodeIP/</a></p>
<p>打开 web 界面后用上面获取到的 token 登录即可</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>dashboard</tag>
        <tag>登录</tag>
      </tags>
  </entry>
  <entry>
    <title>klib-khash 使用记录</title>
    <url>/2019/11/20/klib-khash-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>klib 的项目地址：<a href="https://github.com/attractivechaos/klib/">https://github.com/attractivechaos/klib/</a></p>
<p>klib 官方文档：<a href="http://attractivechaos.github.io/klib/">http://attractivechaos.github.io/klib/</a></p>
<p>总的来说整个 klib 库小巧且功能强大，各种实现之间没有依赖，大多只需要 include 头文件即可使用，目前已经使用过的有 khash 和 klist，这里先说我个人在使用 khash 的过程中遇到的问题和使用过程中需要注意的点。</p>
<p>上面的 klib 官方文档链接中有不少入门的小例子，但也只是简单的使用方法，很多接口并没有提及，不过也有可能作者没有及时更新文档中的例子。</p>
<p>在使用过程中要时刻谨记 khash 中给出的接口都是宏，这也意味着在调试的时候很不方便，如果搞不懂一个接口的意思或者想知道这个接口都做了什么，最好还是看一下 khash.h 中的实现。</p>
<p>就我个人来说，最想提出要注意的一点是 <code>内存释放</code>，在过去一段时间内，我手上依赖 klib 的程序一直都有内存泄漏，不过我始终没有找到原因，直到昨天我才终于定位到是 khash 相关的数据没有被彻底释放。导致这一问题出现的重要原因也在于我接手这个项目时，khash 相关的释放代码已经大量存在了，以至于先入为主，令我以为正确的释放操作就应该就那样，昨天定位到这个问题后我仔细分析了一下 khash 的源码，发现一直以来程序里关于销毁释放内存的操作，一直都是错误的。下面只会使用正确的方法（至少目前我认为是正确的:))，以免误导了其他人。</p>
<p>khash 里面提供了两种数据结构：hashmap 和 hashset，两种结构的使用方法大致是一样的，可以把 hashset 结构看作是没有值的 hashmap。</p>
<h1 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明 hashmap 名字和键值的类型</span></span><br><span class="line"><span class="comment">// 这个宏还定义了大量的函数，不过一般都不直接使用那些函数，而是使用通用的接口宏</span></span><br><span class="line"><span class="comment">// 这里声明了一个键值对是 int:int 的 map 类型，注意这里只是声明了一个 类型</span></span><br><span class="line"><span class="comment">// 这个 map 类型的名字是 MAP_int2int，map 的名字后面会经常用到</span></span><br><span class="line"><span class="comment">// 此外，这个宏是对宏 KHASH_INIT 的一个简单封装</span></span><br><span class="line"><span class="comment">// 如果有复杂需求要使用 KHASH_INIT，则需要提供两个 hash 函数，我没有用到就不举例了</span></span><br><span class="line"><span class="comment">// hash 函数的实现可以参考 khash 里已有的来实现</span></span><br><span class="line">KHASH_MAP_INIT_INT(MAP_int2int, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">khash_t</span>(MAP_int2int) *map_int2int = kh_init(MAP_int2int); <span class="comment">// 使用上面声明的 map 类型声明并初始化一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">khiter_t</span> iter = <span class="number">0</span>; <span class="comment">// 访问键、值都需要使用 iter</span></span><br><span class="line">iter = kh_get(MAP_int2int, map_int2int, <span class="number">100</span>); <span class="comment">// 查看 100 这个键是否在 map 中存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iter == kh_end(map_int2int)) &#123; <span class="comment">// 不存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>; <span class="comment">// 将 100 这个键放入 map，ret 是一个额外的返回值，用来表示放入操作的结果</span></span><br><span class="line">    iter = kh_put(MAP_int2int, map_int2int, <span class="number">100</span>, &amp;ret); <span class="comment">// 放入成功后返回值 iter 即表示为 100 这个键在 map 中的位置</span></span><br><span class="line">&#125;</span><br><span class="line">kh_value(map_int2int, iter) = <span class="number">200</span>; <span class="comment">// 使用 iter 来存值，值为 200</span></span><br><span class="line"><span class="comment">/* 至此 map 中就有了 100:200 这一个数据 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 map</span></span><br><span class="line"><span class="keyword">for</span> (iter = kh_begin(map_int2int); iter != kh_end(map_int2int); iter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!kh_exist(map_int2int, iter)) &#123; <span class="comment">// 这里的判断一定要有</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    do_something_foo(kh_key(map_int2int, iter));</span><br><span class="line">    do_something_bar(kh_val(map_int2int, iter));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* khash 里还提供了更便利的遍历宏：kh_foreach 和 kh_foreach_value */</span></span><br><span class="line"></span><br><span class="line">kh_del(MAP_int2int, map_int2int, iter); <span class="comment">// 当确定一个 iter 之后，可以移除一个键值对</span></span><br><span class="line">kh_clear(MAP_int2int, map_int2int); <span class="comment">// 清空这个 map 的所有数据</span></span><br><span class="line"></span><br><span class="line">do_something_zzz(map_int2int); <span class="comment">// 清空后的 map 还可以继续使用，比如继续往里面存值</span></span><br><span class="line"></span><br><span class="line">kh_destroy(MAP_int2int, map_int2int); <span class="comment">// 销毁 map，销毁之后就不能再使用了</span></span><br></pre></td></tr></table></figure>

<h1 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与 demo1 基本相同，但多了释放内存的操作，不再使用过多注释了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一些结构体变量</span></span><br><span class="line">&#125; <span class="keyword">struct_a_t</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct_a_t</span> *<span class="title">create_struct_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个创建示例结构体的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_struct_a</span><span class="params">(<span class="keyword">struct_a_t</span> *)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个销毁示例结构体的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_str</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *c_str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个销毁示例字符串的函数</span></span><br><span class="line">    <span class="built_in">free</span>(c_str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建测试数据</span></span><br><span class="line"><span class="keyword">char</span> *test_key = <span class="string">&quot;test_key_data&quot;</span>;</span><br><span class="line"><span class="keyword">struct_a_t</span> *test_value = create_struct_a();</span><br><span class="line"></span><br><span class="line">KHASH_MAP_INIT_STR(MAP_str2struct_p, <span class="keyword">struct_a_t</span> *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">khash_t</span>(MAP_str2struct_p) *map_str2struct_p = kh_init(MAP_str2struct_p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">khiter_t</span> iter = <span class="number">0</span>;</span><br><span class="line">iter = kh_get(MAP_str2struct_p, map_str2struct_p, test_key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iter == kh_end(map_str2struct_p)) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    iter = kh_put(MAP_str2struct_p, map_str2struct_p, test_key, &amp;ret);</span><br><span class="line">&#125;</span><br><span class="line">kh_value(map_str2struct_p, iter) = test_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (iter = kh_begin(map_str2struct_p); iter != kh_end(map_str2struct_p); iter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!kh_exist(map_str2struct_p, iter)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    do_something_foo(kh_key(map_str2struct_p, iter));</span><br><span class="line">    do_something_bar(kh_val(map_str2struct_p, iter));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kh_del(MAP_str2struct_p, map_str2struct_p, iter);</span><br><span class="line">kh_clear(MAP_str2struct_p, map_str2struct_p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是，map 或 set 中不论键还是值，只要类型是指针，那么指针指向的内存就需要使用者自行释放</span></span><br><span class="line">kh_free_vals(MAP_str2struct_p, map_str2struct_p, free_struct_a); <span class="comment">// 销毁值的宏</span></span><br><span class="line">kh_free(MAP_str2struct_p, map_str2struct_p, free_str); <span class="comment">// 销毁键的宏</span></span><br><span class="line"></span><br><span class="line">kh_destroy(MAP_str2struct_p, map_str2struct_p);</span><br></pre></td></tr></table></figure>

<h1 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还可以嵌套使用</span></span><br><span class="line"></span><br><span class="line">KHASH_MAP_INIT_INT(MAP_int2int, <span class="keyword">int</span>);</span><br><span class="line">KHASH_MAP_INIT_STR(MAP_str2map_p, <span class="keyword">khash_t</span>(MAP_int2int) *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">khash_t</span>(MAP_str2map_p) *map_str2map_p = kh_init(MAP_str2map_p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>klib</tag>
        <tag>khash</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 原始套接字收发 packet</title>
    <url>/2022/07/16/linux-%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E6%94%B6%E5%8F%91-packet/</url>
    <content><![CDATA[<p>近期工作接触到了些 linux 在 OSI 二层（数据链路层）使用 ethernet 协议收发数据包的内容，网上搜罗了一些有用的文档：</p>
<ul>
<li><a href="https://austinmarton.wordpress.com/2011/09/14/sending-raw-ethernet-packets-from-a-specific-interface-in-c-on-linux/">https://austinmarton.wordpress.com/2011/09/14/sending-raw-ethernet-packets-from-a-specific-interface-in-c-on-linux/</a></li>
<li><a href="https://www.binarytides.com/raw-sockets-c-code-linux/">https://www.binarytides.com/raw-sockets-c-code-linux/</a></li>
<li><a href="https://squidarth.com/networking/systems/rc/2018/05/28/using-raw-sockets.html">https://squidarth.com/networking/systems/rc/2018/05/28/using-raw-sockets.html</a></li>
<li><a href="https://stackoverflow.com/questions/14774668/what-is-raw-socket-in-socket-programming">https://stackoverflow.com/questions/14774668/what-is-raw-socket-in-socket-programming</a></li>
<li><a href="https://www.tenouk.com/Module43a.html">https://www.tenouk.com/Module43a.html</a></li>
<li>推荐： <a href="https://www.opensourceforu.com/2015/03/a-guide-to-using-raw-sockets/">https://www.opensourceforu.com/2015/03/a-guide-to-using-raw-sockets/</a></li>
<li>推荐： <a href="https://github.com/xgfone/snippet/blob/master/snippet/docs/linux/program/raw-socket.md">https://github.com/xgfone/snippet/blob/master/snippet/docs/linux/program/raw-socket.md</a></li>
<li>推荐： <a href="https://man7.org/linux/man-pages/man7/packet.7.html">https://man7.org/linux/man-pages/man7/packet.7.html</a></li>
<li>推荐(上面链接的中文翻译)： <a href="https://manpages.debian.org/unstable/manpages-zh/packet.7.zh_CN.html">https://manpages.debian.org/unstable/manpages-zh/packet.7.zh_CN.html</a></li>
</ul>
<p>另外有一些第三方库也可以做到处理链路层数据：</p>
<ul>
<li>libpcap 第三方 c 开发文档： <a href="https://www.devdungeon.com/content/using-libpcap-c">https://www.devdungeon.com/content/using-libpcap-c</a></li>
<li>libpcap 官方 c 开发文档： <a href="https://www.tcpdump.org/pcap.html">https://www.tcpdump.org/pcap.html</a></li>
<li>libpcap： <a href="https://ruofeng.me/2018/04/23/use-libpcap-to-send-and-capture/">https://ruofeng.me/2018/04/23/use-libpcap-to-send-and-capture/</a></li>
<li>libnet 库： <a href="https://github.com/libnet/libnet">https://github.com/libnet/libnet</a></li>
<li>libnet 库： <a href="https://codedocs.xyz/libnet/libnet/globals.html">https://codedocs.xyz/libnet/libnet/globals.html</a></li>
</ul>
<p>下面是我对 linux man 手册 packet(7) 的翻译，虽然上面已有相关中文翻译的链接，但我个人认为有部分相关术语使用得不太合适，另外我自己再翻译一边也可以加深我个人理解。</p>
<h1 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h1><p>packet - 设备层的 packet 接口</p>
<h1 id="SYNOPSIS-概要"><a href="#SYNOPSIS-概要" class="headerlink" title="SYNOPSIS 概要"></a>SYNOPSIS 概要</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;if_packet.h&gt;</span><br><span class="line">#include &lt;net&#x2F;ethernet.h&gt; &#x2F;* the L2 protocols *&#x2F;</span><br><span class="line"></span><br><span class="line">packet_socket &#x3D; socket(AF_PACKET, int socket_type, int protocol);</span><br></pre></td></tr></table></figure>

<h1 id="DESCRIPTION-描述"><a href="#DESCRIPTION-描述" class="headerlink" title="DESCRIPTION 描述"></a>DESCRIPTION 描述</h1><p>如使用如下调用创建的 socket 被称为 packet socket：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">packet_socket &#x3D; socket(AF_PACKET, int socket_type, int protocol);</span><br></pre></td></tr></table></figure>

<p>packet sockets 被用来在设备驱动层（OSI 2 层 数据链路层）收发数据包（raw packets）。这允许用户在 OSI 1 层 物理层之上实现 linux 用户空间的协议模块。</p>
<p>socket_type 参数可以使用 SOCK_RAW 或者 SOCK_DGRAM，使用 SOCK_RAW 时收发的数据包 包含 链路层的协议头（译者注：通常是以太网链路层协议头），使用 SOCK_DGRAM 时收发的原始数据包 不包含 链路层协议头。链路层协议头相关信息可以从结构体 sockaddr_ll 中获取到。</p>
<p>protocol 参数是 网络字节序（大端） 的 IEEE 802.3 协议编号。相关定义可以在 &lt;linux/if_ether.h&gt; 头文件中查找。当 protocol 参数使用 htons(ETH_P_ALL) 时，相当于接收所有协议的数据包。protocol 参数指定的所有数据包会先给到用户创建的 socket，然后才由内核相关协议栈程序处理（译者注：也就是说用户实现的数据包处理程序，优先级高于内核，但不等于内核不再继续处理）。</p>
<p>在用户空间创建这种类型的 socket 时，进程必须拥有 CAP_NET_RAW 的能力以便管理 network namespace（译者注：这里是在说运行程序时需要一定的权限，或者直接使用 root 账户运行）。</p>
<p>使用 SOCK_RAW 参数时，数据包会从设备驱动不经任何修改得被程序接收和发送。当接收一个数据包时，address 仍被解析并设置到结构体 sockaddr_ll 中。当发送一个数据包时，用户提供的 buffer 需要包含物理层协议头（译者注：用户要发送的数据中需要包含以太网协议头，同时还需要在 sockaddr_ll 中设置以太网协议头中已经包含了的目标 MAC 地址）。数据包不经修改得被放网络接口的驱动队列中，网络接口由目标 address 定义（译者注：sockaddr_ll 结构体的一个成员）。SOCK_RAW 类似但不兼容 Linux 2.0 时使用的参数 AF_INET + SOCK_PACKET。</p>
<p>使用 SOCK_DGRAM 参数时相当于处于一个较高层次。接收数据包时，以太网协议头将会被移除。发送数据包时，会自动从 sockaddr_ll 中提取的以太网协议头信息进行封包。 </p>
<p>默认情况下，所有 protocol 参数指定的协议类型的数据包，都会给到用户创建的 socket。如果需要只获取某个网络接口上的数据包，可以使用 bind(2) 函数，将指定的 socket 和 sockaddr_ll 传入作为参数，sockaddr_ll 中需要设置的字段有 sll_family（使用 AF_PACKET），sll_protocol 和 sll_ifindex（指定的网络接口）。</p>
<p>这种类型的 socket 不支持 connect 操作。</p>
<p>当调用 recvmsg(2) recv(2) 或 recvfrom(2) 时，如果指定了 MSG_TRUNC flag，将会返回数据包的真实大小，即使数据包的大小比参数 buffer 要大。</p>
<h2 id="Address-types"><a href="#Address-types" class="headerlink" title="Address types"></a>Address types</h2><p>结构体 sockaddr_ll 是设备无关的，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct sockaddr_ll &#123;</span><br><span class="line">   unsigned short sll_family;   &#x2F;* Always AF_PACKET *&#x2F;</span><br><span class="line">   unsigned short sll_protocol; &#x2F;* Physical-layer protocol *&#x2F;</span><br><span class="line">   int            sll_ifindex;  &#x2F;* Interface number *&#x2F;</span><br><span class="line">   unsigned short sll_hatype;   &#x2F;* ARP hardware type *&#x2F;</span><br><span class="line">   unsigned char  sll_pkttype;  &#x2F;* Packet type *&#x2F;</span><br><span class="line">   unsigned char  sll_halen;    &#x2F;* Length of address *&#x2F;</span><br><span class="line">   unsigned char  sll_addr[8];  &#x2F;* Physical-layer address *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体成员相关含义如下（译者注：并非在所有使用场景下，都需要给所有的成员变量赋值，比如上面提到的调用 bind(2) 函数时，只需要设置 3 个成员即可）：</p>
<ul>
<li>sll_family 始终应该是 AF_PACKT</li>
<li>ssl_protocol 是 &lt;linux/if_ether.h&gt; 头文件中定义的标准的 ethernet protocol 类型，且使用网络序（大端），默认是 socket 的 protocol（译者注：这里的意思应该是每种 socket_type 都有其默认的 protocol，具体不清楚）（译者注：使用此头文件中未定义的值也可以，比如 Profinet 的 0x8892 就没有在头文件中定义，但仍可以使用）</li>
<li>sll_ifindex 是网络接口的索引号，参见 netdevice(7)，值为 0 时表示 any 接口（只允许执行 bind 操作）。</li>
<li>sll_hatype 是 ARP 类型，参见 &lt;linux/if_arp.h&gt; 头文件。</li>
<li>sll_pkttype 是数据包类型，可选的值有：<ul>
<li>PACKET_HOST 发送到 local host 的数据包</li>
<li>PACKET_BROADCAST 以太网广播数据包（译者注：以太网协议头的目标 MAC 地址为全 0xFF）</li>
<li>PACKET_MULTICAST 以太网多播数据包</li>
<li>PACKET_OTHERHOST 发送到其他机器的数据包，且此数据包已经被设备驱动在 promiscuous 模式下捕获</li>
<li>PACKET_OUTGOING 来自本地主机的数据包，该数据包被环回到数据包套接字</li>
<li>这些类型都只在接收数据时有效（译者注：这个字段应该是只在接收数据时其作用）</li>
</ul>
</li>
<li>sll_halen 地址数据的长度</li>
<li>sll_addr 地址（译者注：以太网协议时，是 MAC 地址）</li>
</ul>
<p>当发送数据包时，只需要设置 sll_family + sll_protocol + sll_ifindex + sll_addr + sll_halen 即可，其他字段应该是 0。其他字段在接收数据时需要设置。</p>
<blockquote>
<p>后续内容未经过完整翻译</p>
</blockquote>
<h2 id="Socket-options"><a href="#Socket-options" class="headerlink" title="Socket options"></a>Socket options</h2><p>socket options 通过调用 setsockopt(2) 设置，level 参数应该是 SOL_PACKET</p>
<ul>
<li>PACKET_ADD_MEMBERSHIP / PACKET_DROP_MEMBERSHIP<br>  packet sockets 可以被用来设置物理层/链路层多播和 promiscuous 模式（传统的 ioctls SIOCSIFFLAGS SIOCADDMULTI  SIOCDELMULTI 也可以实现相同的目的）。PACKET_ADD_MEMBERSHIP 用来新增配置，相对应的 PACKET_DROP_MEMBERSHIP 则用来移除配置。它们都需要结构体 packet_mreq 作为参数，其定义如下：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct packet_mreq &#123;</span><br><span class="line">    int            mr_ifindex;    &#x2F;* interface index *&#x2F;</span><br><span class="line">    unsigned short mr_type;       &#x2F;* action *&#x2F;</span><br><span class="line">    unsigned short mr_alen;       &#x2F;* address length *&#x2F;</span><br><span class="line">    unsigned char  mr_address[8]; &#x2F;* physical-layer address *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  此结构体成员含义如下：<ul>
<li>mr_ifindex 根据网络接口索引号，指定将要修改哪个网络接口</li>
<li>mr_type 执行要执行什么操作，其可选值如下：<ul>
<li>PACKET_MR_PROMISC 表示允许接收共享介质上的所有数据包（即： promiscuous mode）</li>
<li>PACKET_MR_MULTICAST 设置 multicast group</li>
<li>PACKET_MR_ALLMULTI 表示接收此网络接口上的 all multicast packets</li>
</ul>
</li>
<li>mr_alen / mr_address 用来在 mr_type 为 PACKET_MR_MULTICAST 时，设置 multicast group 相关信息</li>
</ul>
</li>
<li>PACKET_AUXDATA (since Linux 2.6.21)<br>  If this binary option is enabled, the packet socket passes a metadata structure along with each packet in the recvmsg(2) control field.  The structure can be read with cmsg(3).  It is defined as  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct tpacket_auxdata &#123;</span><br><span class="line">  __u32 tp_status;</span><br><span class="line">  __u32 tp_len;      &#x2F;* packet length *&#x2F;</span><br><span class="line">  __u32 tp_snaplen;  &#x2F;* captured length *&#x2F;</span><br><span class="line">  __u16 tp_mac;</span><br><span class="line">  __u16 tp_net;</span><br><span class="line">  __u16 tp_vlan_tci;</span><br><span class="line">  __u16 tp_vlan_tpid; &#x2F;* Since Linux 3.14; earlier, these</span><br><span class="line">                         were unused padding bytes *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>PACKET_FANOUT (since Linux 3.1)</li>
<li>PACKET_RESERVE (with PACKET_RX_RING)</li>
<li>PACKET_RX_RING</li>
<li>PACKET_STATISTICS</li>
<li>PACKET_TIMESTAMP (with PACKET_RX_RING; since Linux 2.6.36)</li>
<li>PACKET_TX_RING (since Linux 2.6.31)</li>
<li>PACKET_VERSION (with PACKET_RX_RING; since Linux 2.6.27)</li>
<li>PACKET_QDISC_BYPASS (since Linux 3.14)</li>
</ul>
<h2 id="ioctls"><a href="#ioctls" class="headerlink" title="ioctls"></a>ioctls</h2><p>SIOCGSTAMP 可以用来获取接收最后一个数据包的时间戳 timestamp。参数是结构体 timeval。</p>
<p>另外，所有在 netdevice(7) 和 socket(7) 中定义的标准 ioctls 在 packet sockets 上都是有效的。</p>
<h2 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h2><p>除了在将数据包传递给设备驱动程序时发生的错误之外，数据包套接字不进行错误处理。他们没有未决错误的概念。</p>
<h1 id="ERRORS"><a href="#ERRORS" class="headerlink" title="ERRORS"></a>ERRORS</h1><ul>
<li>EADDRNOTAVAIL Unknown multicast group address passed.</li>
<li>EFAULT User passed invalid memory address.</li>
<li>EINVAL Invalid argument.</li>
<li>EMSGSIZE Packet is bigger than interface MTU.</li>
<li>ENETDOWN Interface is not up.</li>
<li>ENOBUFS Not enough memory to allocate the packet.</li>
<li>ENODEV Unknown device name or interface index specified in interface address.</li>
<li>ENOENT No packet received.</li>
<li>ENOTCONN No interface address passed.</li>
<li>ENXIO Interface address contained an invalid interface index.</li>
<li>EPERM User has insufficient privileges to carry out this operation.</li>
</ul>
<p>In addition, other errors may be generated by the low-level driver.</p>
<h1 id="VERSIONS"><a href="#VERSIONS" class="headerlink" title="VERSIONS"></a>VERSIONS</h1><p>AF_PACKET is a new feature in Linux 2.2.  Earlier Linux versions<br>supported only SOCK_PACKET.</p>
<h1 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h1><p>对于可移植程序，建议通过 pcap(3) 使用 AF_PACKET；尽管这仅涵盖了 AF_PACKET 功能的一个子集。</p>
<p>The SOCK_DGRAM packet sockets make no attempt to create or parse the IEEE 802.2 LLC header for a IEEE 802.3 frame.<br>SOCK_DGRAM 数据包套接字不会尝试为 IEEE 802.3 帧创建或解析 IEEE 802.2 LLC header。</p>
<p>When ETH_P_802_3 is specified as protocol for sending the kernel creates the 802.3 frame and fills out the length field; the user has to supply the LLC header to get a fully conforming packet.<br>当 ETH_P_802_3 被指定为发送协议时，内核创建 802.3 帧并填写长度字段；用户必须自行提供 LLC header 才能获得完全符合要求的数据包。</p>
<p>Incoming 802.3 packets are not multiplexed on the DSAP/SSAP protocol fields; instead they are supplied to the user as protocol ETH_P_802_2 with the LLC header prefixed.<br>传入的 802.3 数据包不会在 DSAP/SSAP 协议字段上复用；相反，它们作为带有 LLC 标头前缀的协议 ETH_P_802_2 提供给用户。</p>
<p>It is thus not possible to bind to ETH_P_802_3; bind to ETH_P_802_2 instead and do the protocol multiplex yourself.<br>因此无法绑定到 ETH_P_802_3；而是绑定到 ETH_P_802_2 并自己进行协议复用。</p>
<p>The default for sending is the standard Ethernet DIX encapsulation with the protocol filled in.<br>发送的默认值是标准的以太网 DIX 封装，并填充了协议。</p>
<p>Packet sockets are not subject to the input or output firewall<br>chains.</p>
<h2 id="Compatibility"><a href="#Compatibility" class="headerlink" title="Compatibility"></a>Compatibility</h2><p>In Linux 2.0, the only way to get a packet socket was with the<br>call:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket(AF_INET, SOCK_PACKET, protocol)</span><br></pre></td></tr></table></figure>

<p>This is still supported, but deprecated and strongly discouraged.<br>The main difference between the two methods is that SOCK_PACKET<br>uses the old struct sockaddr_pkt to specify an interface, which<br>doesn’t provide physical-layer independence.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct sockaddr_pkt &#123;</span><br><span class="line">   unsigned short spkt_family;</span><br><span class="line">   unsigned char  spkt_device[14];</span><br><span class="line">   unsigned short spkt_protocol;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>spkt_family contains the device type, spkt_protocol is the IEEE<br>802.3 protocol type as defined in &lt;sys/if_ether.h&gt; and<br>spkt_device is the device name as a null-terminated string, for<br>example, eth0.</p>
<p>This structure is obsolete and should not be used in new code.</p>
<h1 id="BUGS"><a href="#BUGS" class="headerlink" title="BUGS"></a>BUGS</h1><p>The IEEE 802.2/803.3 LLC handling could be considered as a bug.</p>
<p>Socket filters are not documented.</p>
<p>The MSG_TRUNC recvmsg(2) extension is an ugly hack and should be<br>replaced by a control message.  There is currently no way to get<br>the original destination address of packets via SOCK_DGRAM.</p>
]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>raw socket</tag>
        <tag>packet</tag>
        <tag>ethernet</tag>
        <tag>link layer</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 系统使用 comfast CF-WU810N 无线网卡创建 wifi 热点</title>
    <url>/2021/08/12/linux-%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8-comfast-CF-WU810N-%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E5%88%9B%E5%BB%BA-wifi-%E7%83%AD%E7%82%B9/</url>
    <content><![CDATA[<p>我用来创建热点的工具是 create_ap 可以直接去官方仓库中查看 README 来安装：<a href="https://github.com/oblique/create_ap">https://github.com/oblique/create_ap</a></p>
<p>把 USB 无线网卡插到运行 linux 系统的机器上，然后使用 <code>lsusb</code> 命令查看信息，可以得到如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bus 001 Device 006: ID 0bda:8179 Realtek Semiconductor Corp. RTL8188EUS 802.11n Wireless Network Adapter</span><br></pre></td></tr></table></figure>

<p>可以看到芯片是 <code>RTL8188EUS</code>，在 manjaro 系统下，虽然可以识别设备，也能正常连接无线网使用，但默认驱动不能用来创建 wifi 热点，所以需要手动安装一个新的驱动。</p>
<p>经过搜索和不断测试，最终确定一个可用驱动：<br><a href="https://github.com/aircrack-ng/rtl8188eus">https://github.com/aircrack-ng/rtl8188eus</a></p>
<p>手动安装方法可以参考驱动代码仓库的 README 文档。</p>
<p>如果是 arch 系的系统，比如 manjaro 系统，可以直接 aur 仓库里的包：<code>8188eu-aircrack-dkms-git</code>，这个包里带有必要的配置文件，安装完成后重启即可生效。</p>
<p>驱动生效后就可以使用 <code>create_ap</code> 工具创建 wifi 热点了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>wifi</tag>
        <tag>RTL8188EUS</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下为两个网卡调整路由规则</title>
    <url>/2019/11/26/linux%E4%B8%8B%E4%B8%BA%E4%B8%A4%E4%B8%AA%E7%BD%91%E5%8D%A1%E8%B0%83%E6%95%B4%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>公司有线网是电信的，访问境外的服务器会间歇性得无法访问，但有一个无线网是移动的，用手机测试发现一直没什么问题，所以搞了个无线网卡连无线网。</p>
<p>但电脑的数据默认只走有线网，只有关了有线网才能用无线网，但是公司内部的服务只能通过有线网访问，所以就尝试了以下方案：</p>
<ul>
<li>192.168.1.0/24 网段走有线网，其他走无线网</li>
<li>只在访问境外服务器的时候走无线网</li>
</ul>
<p>经过测试确定这两个方案都能满足我的需求，但是由于无线不如有限稳定，所以最后确定使用第二种方案。</p>
<p>调整路由的工具使用 ip 命令的子命令 route，除了路由子命令还有很多其他网络相关的功能，具体可以查看 ip 命令的 man 手册。</p>
<p>linux 下当连接无线网和有线网之后使用 <code>ip route</code>，可以简写为 <code>ip r</code> 可以列出当前所有的路由规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default via 192.168.1.1 dev enp2s0 proto static metric 100</span><br><span class="line">default via 192.168.1.1 dev wlx200db012a6be proto dhcp metric 600</span><br><span class="line">172.17.0.0&#x2F;16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown</span><br><span class="line">192.168.1.0&#x2F;24 dev enp2s0 proto kernel scope link src 192.168.1.208 metric 100</span><br><span class="line">192.168.1.0&#x2F;24 dev wlx200db012a6be proto kernel scope link src 192.168.1.74 metric 600</span><br><span class="line">192.168.252.0&#x2F;24 dev xdroid0 proto kernel scope link src 192.168.252.1</span><br></pre></td></tr></table></figure>
<p>其中 enp2s0 是有线网相关的路由，wlx200db012a6be 是无线网相关的路由，此外还有 docker 和 xdroid 相关的，后面这两个不用管，没有安装这两个程序的机器也不会有这两种路由。</p>
<p>从上面的路由规则可以看到 enp2s0 相关的 metric 值为 100 而 wlx200db012a6be 相关的 metric 值为 600，这就表示 enp2s0 相关的路由规则比 wlx200db012a6be 相关的路由规则优先级高。在相同的条件下，如相同的 prefix（IP 地址段）时系统将优先使用 enp2s0。</p>
<p>例如以下这两条规则，就表示访问 192.168.1.* 就会走 enp2s0：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.0&#x2F;24 dev enp2s0 proto kernel scope link src 192.168.1.208 metric 100</span><br><span class="line">192.168.1.0&#x2F;24 dev wlx200db012a6be proto kernel scope link src 192.168.1.74 metric 600</span><br></pre></td></tr></table></figure>

<p>此外要注意调整路由规则需要 root 权限。</p>
<h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>删除有线网的 default 规则即可实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip r del default via 192.168.1.1 dev enp2s0 proto static metric 100</span><br></pre></td></tr></table></figure>
<p>如此一来，除了 192.168.1.0/24 网段即内网网段内的 ip 访问会走有线网，其他的都会走无线网。</p>
<h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>假设我要访问的境外服务器地址为 <code>123.456.789.111</code>，那么只需要添加一条走无线网的路由规则，其仅匹配这个 ip 地址而不是一个网段就行了，经过一番测试，最后确定以下命令可行，测试过程中的无效、错误命令就不贴了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip r add 123.456.789.111 via 192.168.1.1 dev wlx200db012a6be</span><br></pre></td></tr></table></figure>
<p>注意 via 后面需要写无线网的网关，不写或者写错都会导致这个 ip 无法访问。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网卡</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下使用drcom登录认证</title>
    <url>/2016/12/02/linux%E4%B8%8B%E4%BD%BF%E7%94%A8drcom%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>首先感谢开发者:<br><a href="https://github.com/drcoms/drcom-generic">https://github.com/drcoms/drcom-generic</a><br>这个项目基于python实现了d,p,x版drcom认证,请到上述链接查看相关信息,<br>项目的wiki简单介绍了各版本的使用方法.</p>
<p>首先下载上面的<code>drcom-generic</code>,我将其下载到了家目录<code>~/</code>下,完整目录:<code>~/drcom-generic</code></p>
<h1 id="取得必要信息"><a href="#取得必要信息" class="headerlink" title="取得必要信息"></a>取得必要信息</h1><p>下面启动到windows,或者找一个有windows系统的电脑,因为需要知道官方的drcom客户端是连接的哪个服务器,<br>以及其他信息,用来配置drcom-generic</p>
<p>在windows下安装上一个软件: wireshark<br>这个软件很好找,就不说怎么安装了,安装好之后,如果你现在使用drcom上网的,<br>那么就<font color=red>退出drcom客户端,也就是注销登录(这一步是必须的)</font></p>
<p>然后打开wireshark, 软件会列出有所有的网络适配器,我用的是无线网,适配器名称时:”无线网络连接”,<br>只有已连接网络的适配器会有数据波动,如图所示:<br><img src="1.png" alt="list"></p>
<p>双击已连接网络的适配器,本例中是第二项”无线网络连接”,然后wireshark就开始记录这个适配器的数据了,</p>
<p>现在打开drcom客户端,输入账户密码点击登录,如图所示:<br><img src="2.png" alt="drcom"></p>
<p>等登录成功后,点击drcom客户端里的注销,注销之后点击wireshark软件里的”停止”按钮,如图:<br><img src="3.png" alt="stop"></p>
<p>然后选择左上角的”文件”按钮,点击另存为:<br><img src="4.png" alt="saveas"></p>
<p>名字随便写就行了,一会儿还要改的,本例中保存为<code>abc.pcapng</code>,到这里windows下的工作就完成了.</p>
<h1 id="配置drcom-generic"><a href="#配置drcom-generic" class="headerlink" title="配置drcom-generic"></a>配置drcom-generic</h1><p>回到linux系统,把之前保存的<code>abc.pcapng</code>文件复制到<code>~/drcom-generic</code>目录下,然后打开”drcom_d_config.py”文件,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filename &#x3D;</span><br></pre></td></tr></table></figure>
<p>搜索上面的文字,看看等号后面是什么,本例中是<code>3.pcapng</code>,<br>那么就把<code>abc.pcapng</code>改名为<code>3.pcapng</code>,然后打开一个终端,执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;drcom-generic</span><br><span class="line">python2 drcom_d_config.py &gt; config.txt</span><br></pre></td></tr></table></figure>
<p>执行完毕后,如果一切正常那么打开”~/drcom-generic/config.txt”文件,就可以看到一些配置信息,</p>
<p>不要关闭”config.txt”文件,再打开同目录下的”latest-wired.py”文件,找到类似”config.txt”内容的部分,<br>修改”latest-wired.py”里的那部分内容,改成和”config.txt”一样就行了</p>
<p>然后再在”latest-wired.py”文件里找”IS_TEST =”,找到后将等号后面改成”False”</p>
<p>最后连接就开始测试在linux下登录了,使用下面的命令来登录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;drcom-generic</span><br><span class="line">python2 latest-wired.py</span><br></pre></td></tr></table></figure>

<p>我写了一个方便启动，关闭drcom的脚本，有兴趣的可以看看:<br><a href="https://github.com/listenerri/scripts/blob/master/shell/drcom.sh">https://github.com/listenerri/scripts/blob/master/shell/drcom.sh</a></p>
<p>下载下来后赋予可执行权限:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x drcom.sh</span><br></pre></td></tr></table></figure>
<p>就可以用这个脚本来启动和关闭了,具体命令是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#当不使用参数直接执行drcom.sh时,等同于使用-l参数</span><br><span class="line"></span><br><span class="line">#登录</span><br><span class="line">drcom.sh -l</span><br><span class="line">#重启</span><br><span class="line">drcom.sh -r</span><br><span class="line">#退出</span><br><span class="line">drcom.sh -q</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>drcom</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下控制风扇转速</title>
    <url>/2017/10/26/linux%E4%B8%8B%E6%8E%A7%E5%88%B6%E9%A3%8E%E6%89%87%E8%BD%AC%E9%80%9F/</url>
    <content><![CDATA[<p>本文不一定适用于所有电脑，需要自己找到对应的设备文件</p>
<p>我的电脑中，风扇对应到linux下的设备文件的路径是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;sys&#x2F;class&#x2F;hwmon&#x2F;hwmon2&#x2F;pwm1</span><br></pre></td></tr></table></figure>
<p>其他电脑即便不是这个文件，也在类似的目录下，这个文件的内容是”0-255“的数值，<br>相应的数值大小对应相应的风扇转速，向这个文件中写入不同的数据风扇就控制风扇的转速了。</p>
<p>我的电脑中这个文件的默认值是”85“。</p>
<p>下面附上我写的一个shell脚本，放到PATH里就可以方便的控制风扇转速了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">read -p &quot;input speed(0-255) and ENTER: &quot; SPEED</span><br><span class="line">[[ -z $SPEED ]] &amp;&amp; SPEED&#x3D;85</span><br><span class="line">echo $SPEED | sudo tee &#x2F;sys&#x2F;class&#x2F;hwmon&#x2F;hwmon2&#x2F;pwm1</span><br></pre></td></tr></table></figure>
<p>注意如果上述提到的设备文件不同，需要修改脚本中的路径。<br>将上述代码保存为一个shell文件，如<code>fancontrol.sh</code>，并为其增加可执行权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod a+x fancontrol.sh</span><br></pre></td></tr></table></figure>
<p>然后复制到PATH下，如<code>/bin</code>下。</p>
<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;最大转速</span><br><span class="line">fancontrol.sh 255</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>fanspeed</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下添加UEFI启动项</title>
    <url>/2016/07/25/linux%E4%B8%8B%E6%B7%BB%E5%8A%A0UEFI%E5%90%AF%E5%8A%A8%E9%A1%B9/</url>
    <content><![CDATA[<p>今天突然发生了一件怪事,系统重启后没有了硬盘的uefi启动项, 吓了我一跳,我以为硬盘挂了,立即进livecd查看硬盘信息,好在一切正常.<br>我的电脑通常会自动添加应该第一分区(esp分区)里的一些启动项, 但这次重启几次之后依然不能自动添加,而我又是archlinux单系统,没得用easyuefi,<br>所以只能手动在linux下添加了,我没有在livecd中进行添加,而是进入硬盘中的archlinux后添加的.<br>有人会疑惑,没有启动项是怎么进入系统的??<br>详细的就不说了,本文主要说怎么添加uefi启动项,就只简单描述下如何在没有uefi启动项的情况下进入系统:<br><strong>进入BIOS,启动uefi的shell模式,在shell模式中找到archlinux的efi引导文件,直接回车就行了</strong></p>
<h1 id="efibootmgr命令"><a href="#efibootmgr命令" class="headerlink" title="efibootmgr命令"></a>efibootmgr命令</h1><p>在windows下通常使用easyuefi软件来管理uefi启动项,linux下我还不知道有什么图形化的软件来管理uefi启动项,<br>只知道一个efibootmgr命令,在终端中进行操作,这个命令的参数选项有:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usage: efibootmgr [options]</span><br><span class="line">    -a | --active         sets bootnum active</span><br><span class="line">    -A | --inactive       sets bootnum inactive</span><br><span class="line">    -b | --bootnum XXXX   modify BootXXXX (hex)</span><br><span class="line">    -B | --delete-bootnum delete bootnum (hex)</span><br><span class="line">    -c | --create         create new variable bootnum and add to bootorder</span><br><span class="line">    -C | --create-only    create new variable bootnum and do not add to bootorder</span><br><span class="line">    -D | --remove-dups    remove duplicate values from BootOrder</span><br><span class="line">    -d | --disk disk       (defaults to /dev/sda) containing loader</span><br><span class="line">    -e | --edd [1|3|-1]   force EDD 1.0 or 3.0 creation variables, or guess</span><br><span class="line">    -E | --device num      EDD 1.0 device number (defaults to 0x80)</span><br><span class="line">    -g | --gpt            force disk with invalid PMBR to be treated as GPT</span><br><span class="line">    -i | --iface name     create a netboot entry for the named interface</span><br><span class="line">    -l | --loader name     (defaults to \EFI\redhat\grub.efi)</span><br><span class="line">    -L | --label label     Boot manager display label (defaults to &quot;Linux&quot;)</span><br><span class="line">    -m | --mirror-below-4G t|f mirror memory below 4GB</span><br><span class="line">    -M | --mirror-above-4G X percentage memory to mirror above 4GB</span><br><span class="line">    -n | --bootnext XXXX   set BootNext to XXXX (hex)</span><br><span class="line">    -N | --delete-bootnext delete BootNext</span><br><span class="line">    -o | --bootorder XXXX,YYYY,ZZZZ,...     explicitly set BootOrder (hex)</span><br><span class="line">    -O | --delete-bootorder delete BootOrder</span><br><span class="line">    -p | --part part        (defaults to 1) containing loader</span><br><span class="line">    -q | --quiet            be quiet</span><br><span class="line">    -t | --timeout seconds  set boot manager timeout waiting for user input.</span><br><span class="line">    -T | --delete-timeout   delete Timeout.</span><br><span class="line">    -u | --unicode | --UCS-2  pass extra args as UCS-2 (default is ASCII)</span><br><span class="line">    -v | --verbose          print additional information</span><br><span class="line">    -V | --version          return version and exit</span><br><span class="line">    -w | --write-signature  write unique sig to MBR if needed</span><br><span class="line">    -@ | --append-binary-args file  append extra args from file (use &quot;-&quot; for stdin)</span><br><span class="line">    -h | --help             show help/usage</span><br></pre></td></tr></table></figure>
<p>看起来复杂,其实只需要用到其中几个,下面说几个常用的:</p>
<ul>
<li>不加任何参数表示打印当前所有的启动项和启动顺序</li>
<li>-b 修改</li>
<li>-B 删除</li>
<li>-c 添加</li>
<li>-d 指定硬盘(默认是/dev/sda)<strong>[注意这里的根目录是相对于系统的根来说的]</strong></li>
<li>-l 指定引导器(默认是\EFI\redhat\grub.efi)<strong>[注意这里的根目录是相对于你的esp分区来说的,而且用反斜杠<code>\</code>来表示目录级别]</strong></li>
<li>-L 启动项的名字</li>
</ul>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>下面说两个简单的例子:<br><font color=red><strong><em>注意efibootmgr命令需要使用root权限!!</em></strong></font></p>
<h2 id="添加一个名叫Arch的启动项"><a href="#添加一个名叫Arch的启动项" class="headerlink" title="添加一个名叫Arch的启动项"></a>添加一个名叫Arch的启动项</h2><p>背景描述:</p>
<ol>
<li>硬盘是/dev/sda</li>
<li>esp分区被挂载到/boot/efi目录下</li>
<li>esp分区中包含/EFI/arch/bootx64.efi文件<br>具体添加的命令是:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">efibootmgr -c -d /dev/sda -l &#x27;\EFI\arch\bootx64.efi&#x27; -L Arch</span><br></pre></td></tr></table></figure>
这样就添加好了,命令的返回信息也显示已经添加完成了,还可以直接执行bootmgr命令查看.</li>
</ol>
<h2 id="删除一个名叫Arch的启动项"><a href="#删除一个名叫Arch的启动项" class="headerlink" title="删除一个名叫Arch的启动项"></a>删除一个名叫Arch的启动项</h2><p>efibootmgr并不能通过启动项的名字来删除它,只能通过编号来删除,<br>直接执行efibootmgr返回的信息中就包含了每个启动项的编号,比如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~# efibootmgr</span><br><span class="line">BootCurrent: 0000</span><br><span class="line">Timeout: 0 seconds</span><br><span class="line">BootOrder: 0000,0002,0003,0001</span><br><span class="line">Boot0000* Arch</span><br><span class="line">Boot0001* CD/DVD Drive </span><br><span class="line">Boot0002* UEFI: KingstonDataTraveler 2.0PMAP</span><br><span class="line">Boot0003* Hard Drive</span><br></pre></td></tr></table></figure>
<p>可以看到启动<code>Boot0000</code>就是名叫Arch的启动项,<br>另外BootOrder显示的是启动项的顺序,具体修改方法就自己执行<code>man efibootmgr</code>命令查看吧;)<br>那么删除Arch这个启动项的命令就是:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">efibootmgr -b 0 -B</span><br></pre></td></tr></table></figure>
<p>注意命令中的<code>0</code>是数字0,如果是删除<code>Boot0002</code>的话就把数字<code>0</code>改为<code>2</code>即可</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>从上面两个命令可以看出efibootmgr这个命令的参数是需要结合使用的,<br>比如删除选项<code>-B</code>就需要结合修改选项<code>-b</code><br>还有其实直接执行<code>efibootmgr -c</code>也可以创建一个启动项,但这个启动项八成是不能用的,<br>具体原因就自己man去吧~~</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>uefi</tag>
        <tag>启动项</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中oracle数据库的监听和EM的开启和关闭shell脚本</title>
    <url>/2016/04/23/linux%E4%B8%ADoracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%91%E5%90%AC%E5%92%8CEM%E7%9A%84%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%ADshell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>linux和win下的oracle不同、开机后不能直接使用<br>经过一段时间摸索、终于大体摸清了linux下oracle的数据库启动流程<br>所以自己动手写了几个shell脚本、省的每次都要输一堆命令来启动数据库、启动监听、启动em。。<br>不同的数据库安装和不同的系统可能有较大的差异、不能保证都能用</p>
<h1 id="启动数据库"><a href="#启动数据库" class="headerlink" title="启动数据库"></a>启动数据库</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> 打开数据库</span><br><span class="line"><span class="built_in">echo</span> startup|sqlplus <span class="string">&quot;/as sysdba&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> 关闭数据库</span><br><span class="line"><span class="built_in">echo</span> shut|sqlplus <span class="string">&quot;/as sysdba&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="启动监听"><a href="#启动监听" class="headerlink" title="启动监听"></a>启动监听</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> 打开监听</span><br><span class="line">lsnrctl start</span><br></pre></td></tr></table></figure>

<h1 id="关闭监听"><a href="#关闭监听" class="headerlink" title="关闭监听"></a>关闭监听</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> 关闭监听</span><br><span class="line">lsnrctl stop</span><br></pre></td></tr></table></figure>

<h1 id="打开em"><a href="#打开em" class="headerlink" title="打开em"></a>打开em</h1><p>也就是通过浏览器访问：<a href="https://127.0.0.1:1158/em%EF%BC%9A">https://127.0.0.1:1158/em：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> 打开em</span><br><span class="line">emctl start dbconsole</span><br></pre></td></tr></table></figure>

<h1 id="关闭em"><a href="#关闭em" class="headerlink" title="关闭em"></a>关闭em</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> 关闭em</span><br><span class="line">emctl stop dbconsole</span><br></pre></td></tr></table></figure>

<p>以上各功能的shell脚本分别复制保存为6个后缀为’.sh’的文件、并赋予可执行权限<br>在终端中分别执行就行了<br>应该是没有启动顺序的<br>要非得有的话：</p>
<ol>
<li>数据库启动</li>
<li>监听启动</li>
<li>EM启动</li>
</ol>
<p>第三步应该是可选的,如果不需要浏览器打开<br><code>https://127.0.0.1:1158/em</code><br>就不必执行开启em的脚本,如果数据库连不上或者有其他问题可以执行后开启试试</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>数据库</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>linux主要目录的作用</title>
    <url>/2016/04/22/linux%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>手动敲一遍、算是加强记忆吧~</p>
<p><font color=red>/：</font>文件系统的入口，也是最高一级的目录</p>
<p><font color=red>/bin：</font>最基本的且着急用户和普通用户都可以使用的命令放在此目录下，如：ls、cp等</p>
<p><font color=red>/boot：</font>存放Linux的内核及引导系统所需要的文件，包括引导装载程序</p>
<p><font color=red>/etc：</font>存放系统配置文件，一些服务器的配置文件也放在这里</p>
<p><font color=red>/dev：</font>存放所有的设备文件，比如声卡、磁盘等</p>
<p><font color=red>/home：</font>包含普通用户的个人主目录，如/home/lisi</p>
<p><font color=red>/lib：</font>包含二进制文件的共享库</p>
<p><font color=red>/media：</font>即插即用型存储设备如U盘、光盘等的自动挂载点在此目录下创建</p>
<p><font color=red>/mnt：</font>用于存放临时性挂在存储设备，如光驱可挂载到/met/cdrom下</p>
<p><font color=red>/proc：</font>存放进程信息以及内核信息，由内核在内存中产生</p>
<p><font color=red>/root：</font>Linux超级用户的主目录</p>
<p><font color=red>/sbin：</font>存放系统管理命令，一般只有超级用户才能执行</p>
<p><font color=red>/tmp：</font>公用的临时文件目录。/var/tmp目录于此目录类似</p>
<p><font color=red>/usr：</font>存放应用程序及相关文件，比如命令、帮助文件等</p>
<p><font color=red>/var：</font>存放系统中经常变化（vary）的文件，如在/var/log目录中存放系统日志</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>linux创建wifi热点</title>
    <url>/2016/05/04/linux%E5%88%9B%E5%BB%BAwifi%E7%83%AD%E7%82%B9/</url>
    <content><![CDATA[<p><strong><font color=red>本文中使用的系统是archlinux,其他系统应该只有安装方法不同</font></strong></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yaourt -S archlinuxcn/create_ap</span><br><span class="line"><span class="comment">#或者：</span></span><br><span class="line">yaourt -S aur/create_ap</span><br></pre></td></tr></table></figure>
<h1 id="终端下创建热点"><a href="#终端下创建热点" class="headerlink" title="终端下创建热点"></a>终端下创建热点</h1><p>首先执行ifconfig命令查看网卡端口<br>下面是我的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ap0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ...................</span><br><span class="line">enp4s0f2: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu </span><br><span class="line">        ...................</span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        ...................</span><br><span class="line">ppp0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  </span><br><span class="line">        ...................</span><br><span class="line">wlp3s0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ...................</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>ap0：是我用create_ap命令创建出来的ap</li>
<li>enp4s0f2：有线网卡</li>
<li>lo：暂时不清楚</li>
<li>ppp0：这个用ADSL上网的话就会出现</li>
<li>wlp3s0：无线网卡</li>
</ul>
<p>当你没有使用create_ap创建ap时，ifconfig命令不会返回ap0，当你没有使用ADSL上网时(路由器LAN口直连)不会有ppp0</p>
<h2 id="路由器LAN口直连"><a href="#路由器LAN口直连" class="headerlink" title="路由器LAN口直连"></a>路由器LAN口直连</h2><p>所以，如果你没有使用ADSL上网时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">创建一个名字是wifiName，密码是wifiPasswd的热点</span><br><span class="line">sudo create_ap wlp3s0 enp4s0f2 wifiName wifiPasswd</span><br></pre></td></tr></table></figure>

<h2 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h2><p>如果你用的是ADSL上网的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">创建一个名字是wifiName，密码是wifiPasswd的热点</span><br><span class="line">sudo create_ap wlp3s0 ppp0 wifiName wifiPasswd</span><br></pre></td></tr></table></figure>

<h2 id="wifi"><a href="#wifi" class="headerlink" title="wifi"></a>wifi</h2><p>如果你使用wifi上网的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个名字是wifiName，密码是wifiPasswd的热点</span><br><span class="line">sudo create_ap wlp3s0 wlp3s0 wifiName wifiPasswd</span><br></pre></td></tr></table></figure>

<h2 id="创建没有密码的热点"><a href="#创建没有密码的热点" class="headerlink" title="创建没有密码的热点"></a>创建没有密码的热点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个名字是wifiName，没有密码的热点</span><br><span class="line">sudo create_ap wlp3s0 wlp3s0 wifiName</span><br></pre></td></tr></table></figure>
<p>也就是不写密码就行了</p>
<blockquote>
<p>上面几种方法根据自己的情况任选一种，创建好之后执行ifconfig命令就会发现多出来了一个ap0的接口信息</p>
</blockquote>
<h1 id="使用systemctl创建后台热点-服务"><a href="#使用systemctl创建后台热点-服务" class="headerlink" title="使用systemctl创建后台热点(服务)"></a>使用systemctl创建后台热点(服务)</h1><p>安装create_ap时，会自动生成一个wifi.service文件到/usr/lib/systemd/system目录下<br>里面也是调用了create_ap命令来创建热点，可以打开这个文件，按需编辑，<br>编辑好内容之后，就可执行systemctl来启动创建热点的服务了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl start wifi.service</span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">systemctl stop wifi.service</span><br></pre></td></tr></table></figure>

<p>也可以开机自动运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#允许开机自动执行</span></span><br><span class="line">systemctl <span class="built_in">enable</span> wifi.service</span><br><span class="line"><span class="comment">#禁止开机自动执行</span></span><br><span class="line">systemctl <span class="built_in">disable</span> wifi.service</span><br></pre></td></tr></table></figure>

<p>可以修改wifi.service文件为你想要的文件名，比如修改成create_ap.service，那么启动服务时的命令就要改成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl start create_ap.service</span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">systemctl stop create_ap.service</span><br></pre></td></tr></table></figure>
<p>开机自动启动同上</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>wifi</tag>
        <tag>热点</tag>
      </tags>
  </entry>
  <entry>
    <title>linux制作可启动iso</title>
    <url>/2016/05/04/linux%E5%88%B6%E4%BD%9C%E5%8F%AF%E5%90%AF%E5%8A%A8iso/</url>
    <content><![CDATA[<p>在arch下mkisofs命令和genisoimage命令是一样的,mkisofs是genisoimage的一个链接</p>
<p>使用isolinux作为引导,需自行下载并放到iso根目录下,<br>需手动编写isolinux.cfg并放到isolinux下,具体参见其他可启动iso</p>
<p>最后使用如下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkisofs -o myiso.iso -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table myiso</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<p>-o 将生成的iso文件</p>
<p>-b 引导程序<font color=red>(这里的路径是指iso的根目录,也就是相对于myiso这个目录)</font></p>
<p>-c 将boot.cat生成到isolinux下<font color=red>(boot.cat是自动生成的)</font></p>
<p>myiso 是要制作iso的目录,也是iso的根目录</p>
<p>其他参数请man mkisofs</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>iso</tag>
        <tag>可启动</tag>
        <tag>u盘启动</tag>
      </tags>
  </entry>
  <entry>
    <title>linux映射修饰键</title>
    <url>/2016/10/24/linux%E6%98%A0%E5%B0%84%E4%BF%AE%E9%A5%B0%E9%94%AE/</url>
    <content><![CDATA[<p>首先，先说一个并不好用的方法，请看链接：<a href="https://wiki.archlinux.org/index.php/Xmodmap">使用xmodmap命令映射按键</a><br>之所以说这是一个不好用的方法是因为它在大多数桌面环境下没法实现开机自动映射，<br>只能进入系统后手动执行命令才能实现映射，而且即便手动执行映射命令生效了，<br>也会由于未知原因，过一段时间后失效，所以要想安稳的实现映射还是看下面的方法吧。</p>
<p>本方法基于X图形框架，也就是要实现按键映射必须启动X</p>
<p>请留意文章标题，说的是修饰键(modified key)，也就是Ctrl,Alt,Shift,Esc,Super(windows)等键，<br>而是不键盘上的任意键，应该也可以实现任意键，但就需要深入学习X框架了，<br>推荐从这里入门： <a href="https://wiki.archlinux.org/index.php/X_KeyBoard_extension">Arch WiKi: X KeyBoard extension</a></p>
<p>下面说简单的修饰键映射方法：<br>首先在X图形框架的配置文件夹<code>/etc/X11/xorg.conf.d/</code>下新建<code>90-custom-kbd.conf</code>文件，<br>然后将下面的代码粘贴到上面新建的文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Section &quot;InputClass&quot;</span><br><span class="line">    Identifier &quot;keyboard defaults&quot;</span><br><span class="line">    MatchIsKeyboard &quot;on&quot;</span><br><span class="line"></span><br><span class="line">    Option &quot;XKbOptions&quot; &quot;caps:escape&quot;</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>

<p>我们需要注意以及修改的地方只有“caps:escape”这个位置，<br>当前这段配置的作用是将caps（大写锁定）键映射到esc键，也就是说，<br>让大写锁定键的作用变成esc键，而不再是原有的大写锁定作用，同时esc键保留原有的作用。</p>
<p>看到这里你可能以为so easy，这样看来只需要修改成”ctrl:alt”就可以实现，让ctrl键变成alt键了。</p>
<p>然而，并不是。。<br>起初我也以为是这样，经过测试后无效，摸索了很久终于弄懂了，<br>原来”caps:escape”是一个已经定义好的选项，所以可以直接拿来用，而不是随便写的,<br>而”ctrl:alt”并不是以定义的选项所以无效。</p>
<p>那么怎么定义选项呢，抱歉，我也没学会，就像文章开头所说的这就需要深入学习X框架了，<br>庆幸的是，已经有了大量以定义的选项，我们可以找到自己需要的并拿来使用，</p>
<p>以定义的选项可以从系统的这个文件里找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;X11&#x2F;xkb&#x2F;rules&#x2F;base.lst</span><br></pre></td></tr></table></figure>

<p>打开这个文件，搜索”! option”，注意搜索关键字里包含感叹号和空格，<br>这个关键字下面就是以定义的选项了，共分为两列，第一列是选项名，第二列可以理解为选项的作用，<br>向下翻，以”grp”和”lv3”开头的选项不看，这些是更改键盘布局的选项，<br>再往下就基本都是修饰键映射的选项了。</p>
<p>比如这个选项”ctrl:menu_rctrl”可以实现把menu键映射为右ctrl键，<br>那么就修改之前新建的那个文件：<code>/etc/X11/xorg.conf.d/90-custom-kbd.conf</code>的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Section &quot;InputClass&quot;</span><br><span class="line">    Identifier &quot;keyboard defaults&quot;</span><br><span class="line">    MatchIsKeyboard &quot;on&quot;</span><br><span class="line"></span><br><span class="line">    Option &quot;XKbOptions&quot; &quot;ctrl:menu_rctrl&quot;</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>

<p>保存后重启X图形框架，或者重启系统就可以实现把menu键映射为右ctrl键了。</p>
<p>下面给出一些特殊名字的含义：</p>
<ul>
<li>menu: 一般在右ctrl键的左边，正常功能相当于鼠标右键</li>
<li>super: 我们一般叫它windows键</li>
<li>numlock: 右边数字键盘开关键</li>
<li>compose: Fn功能键</li>
</ul>
<p>另外左右ctrl或者alt键通过字母l和r来区分，<br>比如左ctrl键是lctrl,右ctrl键是rctrl</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>map</tag>
        <tag>key</tag>
        <tag>modified</tag>
        <tag>映射</tag>
        <tag>按键</tag>
      </tags>
  </entry>
  <entry>
    <title>macvim 图形界面无法显示中文</title>
    <url>/2020/02/17/macvim-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<p>使用 brew cask 安装的 macvim，版本为：<code>8.1.2234,161</code></p>
<p>macvim 图形界面中文显示成问号，但在终端下面却可以正常显示，网上搜了很久都在说编码问题，其实不是，正解如下：</p>
<ol>
<li>打开 macvim GUI</li>
<li>点击菜单栏-Preferences</li>
<li>点击 Advanced</li>
<li>取消选中 <code>Use Core Text renderer</code> 选项</li>
<li>重启 macvim GUI</li>
</ol>
]]></content>
      <categories>
        <category>osx</category>
      </categories>
      <tags>
        <tag>osx</tag>
        <tag>macvim</tag>
      </tags>
  </entry>
  <entry>
    <title>minikube 启动失败</title>
    <url>/2020/04/07/minikube-%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p>首先：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 官方仓库：</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;minikube</span><br><span class="line"># 官方安装教程：</span><br><span class="line">https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;tasks&#x2F;tools&#x2F;install-minikube&#x2F;</span><br><span class="line"># 官方使用教程：</span><br><span class="line">https:&#x2F;&#x2F;kubernetes.io&#x2F;zh&#x2F;docs&#x2F;setup&#x2F;learning-environment&#x2F;minikube&#x2F;</span><br></pre></td></tr></table></figure>

<p>安装过程比较省心，没出什么意外就成功了，在执行： <code>minikube start</code> 时一直报错，无法成功启动环境，主要原因自然还是因为 GFW 的问题。</p>
<p>可是我挂上代理（proxychains 命令无效，我用的 http_proxy &amp;&amp; https_proxy）依然起不来，使用如下命令可以将日志打印到终端上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">minikube start --logtostderr</span><br></pre></td></tr></table></figure>

<p>经过分析后发现失败原因是因为有一个 docker 镜像 <code>gcr.io/k8s-minikube/kicbase:v0.0.8</code> pull 不下来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pulling base image ...</span><br><span class="line">cache.go:104] Beginning downloading kic artifacts                                                                                                                                                               </span><br><span class="line">preload.go:81] Checking if preload exists for k8s version v1.18.0 and runtime docker                                                                                                                            </span><br><span class="line">preload.go:97] Found local preload: &#x2F;home&#x2F;ri&#x2F;.minikube&#x2F;cache&#x2F;preloaded-tarball&#x2F;preloaded-images-k8s-v2-v1.18.0-docker-overlay2-amd64.tar.lz4                                                                    </span><br><span class="line">cache.go:46] Caching tarball of preloaded images                                                                                                                                                                </span><br><span class="line">preload.go:123] Found &#x2F;home&#x2F;ri&#x2F;.minikube&#x2F;cache&#x2F;preloaded-tarball&#x2F;preloaded-images-k8s-v2-v1.18.0-docker-overlay2-amd64.tar.lz4 in cache, skipping download                                                      </span><br><span class="line">cache.go:49] Finished downloading the preloaded tar for v1.18.0 on docker                                                                                                                                       </span><br><span class="line">cache.go:106] Downloading gcr.io&#x2F;k8s-minikube&#x2F;kicbase:v0.0.8@sha256:2f3380ebf1bb0c75b0b47160fd4e61b7b8fef0f1f32f9def108d3eada50a7a81 to local daemon                                                            </span><br><span class="line">image.go:84] Writing gcr.io&#x2F;k8s-minikube&#x2F;kicbase:v0.0.8@sha256:2f3380ebf1bb0c75b0b47160fd4e61b7b8fef0f1f32f9def108d3eada50a7a81 to local daemon                                                                 </span><br><span class="line">profile.go:138] Saving config to &#x2F;home&#x2F;ri&#x2F;.minikube&#x2F;profiles&#x2F;minikube&#x2F;config.json ...                                                                                                                           </span><br><span class="line">lock.go:35] WriteFile acquiring &#x2F;home&#x2F;ri&#x2F;.minikube&#x2F;profiles&#x2F;minikube&#x2F;config.json: &#123;Name:mk3e177ff84a9b80716918e458a1d55c30d5128d Clock:&#123;&#125; Delay:500ms Timeout:1m0s Cancel:&lt;nil&gt;&#125;                                </span><br></pre></td></tr></table></figure>

<p>后面还有一处报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output: Unable to find image &#39;gcr.io&#x2F;k8s-minikube&#x2F;kicbase:v0.0.8@sha256:2f3380ebf1bb0c75b0b47160fd4e61b7b8fef0f1f32f9def108d3eada50a7a81&#39; locally</span><br></pre></td></tr></table></figure>

<p>这就很奇怪，因为我执行 <code>docker images</code> 是可以看到这个镜像的：<code>gcr.io/k8s-minikube/kicbase:v0.0.8</code>，起初我以为是镜像 pull 的不完整，找了台境外机器按照同样的流程执行了下，一切正常，pull 下来的镜像的 <code>image id</code> 和大小跟我本地是一样的</p>
<p>删除我本地的镜像，再次在我本地执行 <code>minikube start</code> 经过漫长等待后（我的代理慢）依旧是同样的报错，看来是 minikube 不认我本地这个镜像，难道是数据真的不完整？</p>
<p>那好，我把境外机器上的镜像 save 到文件，下载到本地，load 进来，再次 start，好吧，依然不认，报错依旧</p>
<p>接着就去扣 minikube 代码了，发现 minikube 校验镜像时会用到一个 docker RepoDigest 的东西，其实就是上面日志里，镜像名后 <code>@</code> 符号后面的一串摘要（指纹/校验码/随便怎么叫吧），关键代码可以点下面的连接去 github 仓库看：</p>
<p><a href="https://github.com/kubernetes/minikube/blob/5ea20f5a06b6000428d26a7a80f0f852d5148696/pkg/minikube/image/image.go#L87">https://github.com/kubernetes/minikube/blob/5ea20f5a06b6000428d26a7a80f0f852d5148696/pkg/minikube/image/image.go#L87</a></p>
<p>关于 docker 镜像的 RepoDigest 可以使用上面代码中的命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images --format &#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;@&#123;&#123;.Digest&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>我本地执行上面命令发现容器的 <code>RepoDigest</code> 是 <code>none</code>，境外机器上则是正确的</p>
<p>现在能确定如下问题：</p>
<ol>
<li>我本地 pull 下来的镜像内容没问题，但丢失了 <code>RepoDigest</code></li>
<li>docker save &amp; load 命令也会丢失 <code>RepoDigest</code></li>
<li>删除本地镜像重新来过依然丢失 <code>RepoDigest</code></li>
</ol>
<p>本来已经要放弃了，打算直接在境外机器上学习，但突然想到我是否可以修改本地镜像的 <code>RepoDigest</code> 呢？</p>
<p>网上搜了一圈没有找到有用的信息，只能自己摸索尝试了，过程不再赘述，要修改的文件是（注意，要访问这个文件需要 root 权限）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 我用的系统是 deepin linux 基于 debian，其他发行版不知道是否是同样的路径</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;repositories.json</span><br></pre></td></tr></table></figure>

<p>这个 json 文件的格式是压缩后的，可以使用如下命令让其好看些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;repositories.json | json_pp</span><br></pre></td></tr></table></figure>

<p>对比本地和境外机器上的同一文件发现本地的确少了一个 <code>RepoDigest</code> 相关的数据，按照相同的格式加上即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;Repositories&quot; : &#123;</span><br><span class="line">        &quot;gcr.io&#x2F;k8s-minikube&#x2F;kicbase&quot; : &#123;</span><br><span class="line">            &quot;gcr.io&#x2F;k8s-minikube&#x2F;kicbase@sha256:2f3380ebf1bb0c75b0b47160fd4e61b7b8fef0f1f32f9def108d3eada50a7a81&quot; : &quot;sha256:11589cdc9ef4b67a64cc243dd3cf013e81ad02bbed105fc37dc07aa272044680&quot;</span><br><span class="line">            &quot;gcr.io&#x2F;k8s-minikube&#x2F;kicbase:v0.0.8&quot;:&quot;sha256:11589cdc9ef4b67a64cc243dd3cf013e81ad02bbed105fc37dc07aa272044680&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面的摘要数据根据自己实际情况修改，以自己机器上的日志为准</p>
<p>修改完成后切记重启 docker daemon 使之生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>minikube</tag>
      </tags>
  </entry>
  <entry>
    <title>miui 正在通过usb安装</title>
    <url>/2017/02/25/miui-%E6%AD%A3%E5%9C%A8%E9%80%9A%E8%BF%87usb%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>最近miui有个坑爹的设计, 就是使用adb从电脑端安装应用的时候会弹出一个提示,<br>询问是否同意安装, 之所以坑爹是最近的版本把关闭这个功能的选项取消了,<br>导致每次调试应用都要手动点击同意安装, 解决方法:</p>
<h1 id="需要的东西"><a href="#需要的东西" class="headerlink" title="需要的东西"></a>需要的东西</h1><p>root<br>任何可以管理手机根目录下文件的文件管理器, 比如RE文件管理器</p>
<h1 id="位置以及修改"><a href="#位置以及修改" class="headerlink" title="位置以及修改"></a>位置以及修改</h1><p>用RE管理器进入以下目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;data&#x2F;data&#x2F;com.miui.securitycenter&#x2F;shared_prefs</span><br></pre></td></tr></table></figure>
<p>用RE管理器的编辑模式(默认是查看模式)打开这个文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote_provider_preferences.xml</span><br></pre></td></tr></table></figure>

<p>找到下面这句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;boolean name&#x3D;&quot;perm_adb_install_notify&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line"># 将其中的&quot;true&quot;修改为&quot;false&quot;</span><br><span class="line"># 修改后为:</span><br><span class="line">&lt;boolean name&#x3D;&quot;perm_adb_install_notify&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>还有找到这句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 要确保这句中的值为&quot;true&quot;</span><br><span class="line"># 这个选项对应的时开发者选项里的&quot;USB安装&quot;</span><br><span class="line"># 只有这个值为&quot;true&quot;的时候这个选项才是打开的</span><br><span class="line">&lt;boolean name&#x3D;&quot;security_adb_install_enable&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>OK了, 不过这个方法好像重启手机后会重置, 需要再次设置, 不过也是不错的了</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>miui</tag>
        <tag>usb</tag>
      </tags>
  </entry>
  <entry>
    <title>新博客的第一篇</title>
    <url>/2016/04/20/my-first-blog-on-hexo-github-pages/</url>
    <content><![CDATA[<p>本博客是使用hexo(一个静态网站生成框架)和github pages搭建的一个博客系统<br>主题使用的是: <a href="https://github.com/iissnan/hexo-theme-next">next</a></p>
<p>过一段时间就会把在csdn的一些文章迁移过来</p>
<p>测试图片:<br><img src="test.jpg" alt="test"></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>mysql 杂记</title>
    <url>/2020/10/21/mysql-%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="存储相关"><a href="#存储相关" class="headerlink" title="存储相关"></a>存储相关</h1><p>页，数据库管理数据的最小单元<br>区，预请求磁盘空间单元，确保读取时的效率，根据数据量延伸出四种状态，某些状态下的区直属于表<br>段，区的集合<br>表，表空间，管理段和部分区</p>
<h1 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h1><p>在指定索引时尽量设置索引的 唯一 属性，这种唯一的二级索引，在 等值 查询时性能近乎与主键等价，等值查询不包括 IS NULL 查询</p>
<p>在查询时尽量避免回表（再从聚簇索引拿数据），当查询列和查询条件都是索引时即可避免</p>
<p>使用 OR 时要慎重：一个使用到 索引 A 的搜索条件和没有使用 A 的搜索条件使用 OR 连接起来后将无法使用 A<br>SELECT * FROM single_table WHERE key2 &gt; 100 OR common_field = ‘abc’;<br>其中 key2 和 common_field 都有各自的索引<br>那么上述查询语句将无法按照预期使用 key2 的索引，而是会拿所有 key2 的值去回表，在回表的时候使用 common_field 的索引</p>
<p>对于联合索引，查询条件要注意索引列声明的顺序，且只有左边的查询条件是 等值 查询时右边的查询条件才能继续使用联合索引</p>
<p>索引列必须和常数比较才会使用索引，两个列进行比较则不会使用到索引</p>
<p>在执行连接查询时，驱动表被访问一次，被驱动表可能会被访问多次，次数与驱动表数据量有关（扇出）</p>
<p>在创建索引时，如果可以尽量使用唯一索引</p>
<h1 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h1><p>事务：脏读，脏写，不可重复读，幻读<br>脏读和脏写强调回滚：当前事务操作了另一个事务 B 的中间状态数据，而事务 B 即将执行回滚<br>不可重复读：当前事务多次读取同一组数据时，发现数据不同，类似于幻读，但覆盖到其他事务对数据的修改和删除操作<br>幻读强调读取到了新数据：当前事务以相同条件多次读取数据时，发现了之前没有见过的数据，因为其他事务插入了新数据</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 索引学习小结</title>
    <url>/2020/08/24/mysql-%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="mysql-索引"><a href="#mysql-索引" class="headerlink" title="mysql 索引"></a>mysql 索引</h1><p>学习了《MySQL 是怎样运行的：从根儿上理解 MySQL》中的索引一节，收获颇丰，总结如下。</p>
<h2 id="innodb-索引（组织结构-b-树）"><a href="#innodb-索引（组织结构-b-树）" class="headerlink" title="innodb 索引（组织结构 b+ 树）"></a>innodb 索引（组织结构 b+ 树）</h2><p>用户记录 -&gt; 用户记录数据页-&gt; 目录项记录 -&gt; 目录项记录数据页 -&gt; 更大范围目录项记录 -&gt; 更大范围目录项记录数据页 -&gt; 更大范围…</p>
<ol>
<li><code>用户记录数据页</code> 中包含针对 <code>用户记录</code> 的目录，称为 <code>页目录</code>，用来使用二分法快速查找 <code>用户记录</code></li>
<li><code>目录项记录数据页</code> 是针对 <code>用户记录数据页</code> 的目录，也包含一个 <code>页目录</code>，但用来使用二分法快速查找 <code>目录项记录</code></li>
<li>一个 <code>用户记录数据页</code> 对应多个 <code>用户记录</code></li>
<li>一个 <code>用户记录数据页</code> 对应一个 <code>目录项记录</code></li>
<li>一个 <code>目录项记录数据页</code> 对应多个 <code>目录项记录</code></li>
<li>一个 <code>目录项记录数据页</code> 对应一个 <code>更大范围目录项记录</code></li>
<li>…</li>
</ol>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>以上述结构组织数据，且存储了所有 <code>完整</code> 用户记录的索引，一般是主键索引</p>
<h2 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h2><p>以上述结构组织数据，但数据不存储完整用户记录，仅存储索引列 + 主键列的值，一般是用户自己建立的索引。这里存储主键的原因是用来使用这个主键进行 <code>回表</code>，去聚簇索引中取出该索引列对应的完整用户记录，因为会查询两次索引，所以二级索引命名由此而来，除聚簇索引外都是二级索引，联合（多列）索引也属于二级索引的一种</p>
<h2 id="MyISAM："><a href="#MyISAM：" class="headerlink" title="MyISAM："></a>MyISAM：</h2><p>与 innodb 索引最大的区别在于组织结构，innodb 索引中最重要的聚簇索引意味着索引即数据，数据亦即索引；但 myisam 索引秉承着索引就是索引，数据就是数据，二者不能放到一起的宗旨，将索引和数据分开存储，用户记录被 <code>无脑</code> 塞到数据文件里去，索引文件中保存用户记录在数据文件中的行号（文件偏移量）和主键，查询时基于主键命中索引后，拿着行号去数据文件中直接取用户记录，这种访问文件的方法是随机存取，因此虽然 myisam 的所有索引都是二级索引，也不会有太大的性能问题</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 获取表结构</title>
    <url>/2020/06/11/mysql-%E8%8E%B7%E5%8F%96%E8%A1%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>获取建表语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE table_name</span><br></pre></td></tr></table></figure>

<p>获取表结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># DESC 是 DESCRIBE 的缩写</span><br><span class="line">DESC table_name</span><br><span class="line">SHOW COLUMNS FROM table_name</span><br></pre></td></tr></table></figure>

<p>筛选字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># field_name 可以包括通配符</span><br><span class="line">DESC table_name &quot;field_name&quot;</span><br><span class="line">SHOW COLUMNS FROM table_name LIKE &quot;field_name&quot;</span><br></pre></td></tr></table></figure>

<p>另外，经过测试，<code>SHOW COLUMNS FROM</code> 语句除了可以使用 LIKE 关键字，还可以使用 WHERE 子句，但 <code>DESCRIBE</code> 语句不支持。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>表结构</tag>
        <tag>字段</tag>
      </tags>
  </entry>
  <entry>
    <title>nextcloud 部署后没有日历邮件等应用</title>
    <url>/2021/08/13/nextcloud-%E9%83%A8%E7%BD%B2%E5%90%8E%E6%B2%A1%E6%9C%89%E6%97%A5%E5%8E%86%E9%82%AE%E4%BB%B6%E7%AD%89%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>在公司内部服务器上搭了一个 <a href="https://nextcloud.com/">Nextcloud</a> 服务，跑起来之后发现没有日历、邮件等应用，且不能打开应用商店，分析了服务日志发现是由于网络问题。</p>
<p>启动服务时加上代理即可正常，比如使用 docker 跑的话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name nextcloud -p 8080:80 -e http_proxy&#x3D;http:&#x2F;&#x2F;192.168.1.100:1081 -e https_proxy&#x3D;http:&#x2F;&#x2F;192.168.1.100:1081 nextcloud</span><br></pre></td></tr></table></figure>

<p>代理相关参数解释：</p>
<ul>
<li>-e http_proxy 为容器内 NC 服务设置 http 代理地址和端口</li>
<li>-e https_proxy 同上</li>
</ul>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>nextcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>osx bash completion 补全</title>
    <url>/2019/10/31/osx-bash-completion-%E8%A1%A5%E5%85%A8/</url>
    <content><![CDATA[<p>在 linux 下补全的配置一般发行版都给默认配了，原本以为在 OSX 下用 brew 装个 bash-completion 包，再在 bashrc 下贴两行配置也就搞定了，没想到不行，OSX 下 bash-completion 包有两个，另一个是 <code>bash-completion@2</code>，这两个包分别对应 bash 的两个版本，具体可以用 brew info <code>bash-completion@2</code> 来看。</p>
<p>而且 <code>bash-completion@2</code> 跟 <code>bash-completion</code> 相比还要多一行配置，总之就是需要下面两行配置才行，原因是大多软件包都只提供了旧版本的 completion 文件，新版的没有提供支持，所以下面的第一行就是声明要兼容下旧的补全文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export BASH_COMPLETION_COMPAT_DIR&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;bash_completion.d&quot;</span><br><span class="line">[[ -r &quot;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;profile.d&#x2F;bash_completion.sh&quot; ]] &amp;&amp; . &quot;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;profile.d&#x2F;bash_completion.sh&quot;</span><br></pre></td></tr></table></figure>

<p>除此之外还有个问题，我自己设置了很多别名 alias，但是这些自定义的别名默认是不支持参数补全的，想要如丝般顺滑就要用另一个项目：<a href="https://github.com/cykerway/complete-alias">https://github.com/cykerway/complete-alias</a>，具体的使用方法就不赘述了，可以去项目里看看怎么配置。</p>
<p>经过实践发现这个项目也不支持旧版的 <code>bash-completion</code> 包，会提示 _completion_loader 找不到的错误，改装 <code>bash-completion@2</code> 就好了。</p>
]]></content>
      <categories>
        <category>osx</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>completion</tag>
        <tag>_completion_loader</tag>
      </tags>
  </entry>
  <entry>
    <title>perl-学习小记</title>
    <url>/2020/03/30/perl-%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>因工作需要，学习了原本十分抗拒的 perl 语言，不过整体看下来后发现 perl 也有其自身的特点与优势，看来每个语言都不可小觑。</p>
<p>由于时间比较急，所以在网上找了一篇速读文章学习，教程很棒，读完后对各种奇葩语法有了一定的认识，链接如下：</p>
<p><a href="https://qntm.org/perl_cn">https://qntm.org/perl_cn</a></p>
<p>下面是一些小笔记：</p>
<p><strong>获取数组长度，前面的 scalar 表示在 scalar 上下文中求 @array 的值，此时即为求数组长度</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scalar @array</span><br></pre></td></tr></table></figure>

<p><strong>获取数组最大有效索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$#array</span><br></pre></td></tr></table></figure>

<p><strong>引用（可以理解为指针）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@array &#x3D; (1,2,3,4)</span><br><span class="line">$array_ref &#x3D; \@array</span><br></pre></td></tr></table></figure>

<p><strong>匿名结构（也是引用）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$array_ref &#x3D; [1,2,3,4] # 与上一个 array_ref 一样，都是一个包含四个 scalar 的 array 的引用，但引用的对象不同</span><br><span class="line">$hash_ref &#x3D; &#123;1 &#x3D;&gt; 2, 3 &#x3D;&gt; 4&#125; # hash_ref 是一个包含两个键值对的 hash 的引用</span><br></pre></td></tr></table></figure>

<p><strong>引用取值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$array_ref -&gt; [0] # 获取第一个 scalar 1</span><br><span class="line">$hash_ref -&gt; &#123;1&#125; # 获取 1 对应的值 2</span><br></pre></td></tr></table></figure>

<p><strong>解引用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@&#123; $array_ref &#125; # 等价于 @$array_ref</span><br><span class="line">%&#123; $hash_ref &#125; # 等价于 %$hash_ref</span><br></pre></td></tr></table></figure>

<p><strong>解引用后取值就是正常取值操作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@$array_ref[0] # 获取第一个 scalar 1</span><br><span class="line">%$hash_ref&#123;1&#125; # 获取 1 对应的值 2</span><br></pre></td></tr></table></figure>

<p><strong>原地修改 array</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop, push, shift, unshift # 移除或新增 array 的开头或结尾</span><br><span class="line">splice # 修改 array 任意位置</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>python 中函数传参是值传递还是引用传递</title>
    <url>/2020/05/29/python-%E4%B8%AD%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>这个问题网上众说纷纭，有的答案不完全正确，有的答案没有解释清楚。</p>
<p>这里先说我认为正确的答案：</p>
<p>如果学习过 cpp 的话,说传值或者传引用都不准确，直接理解为传地址（指针）就好了，不管可变对象还是不可变对象都是传地址。</p>
<p>详细解释，在函数内：</p>
<ul>
<li>对传入参数的赋值操作，是创建新的对象，可以理解为声明新的变量，自然不会影响到函数外变量</li>
<li>对传入参数所指对象的修改操作，如 list 的 append，由于是指针，因此修改了函数外变量，注意在 python 中不可变对象类型是不包含可以修改对象的接口的，即便有些接口看起来像修改了，也是返回了新的对象，而不是对原对象的修改，即不是原地修改</li>
<li>这也解释了当传递复杂类型参数：a = tuple(b = list(), 1, 2, 3) 这种数据时，虽然 a 是不可变类型，但通过 a[0].append() 依然可以成功修改 b，也意味着修改了 a，且函数外变量会也会被修改的原因</li>
</ul>
<p>综上所述，也可以理解为传引用，但要注意，这里的“引用”二字是广义的，不要狭义得理解为是 cpp 中的引用，两者是不同的，在 cpp 中对函数内传入的引用参数执行赋值操作，将会影响到函数外的变量。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>传参</tag>
        <tag>传值</tag>
        <tag>传引用</tag>
      </tags>
  </entry>
  <entry>
    <title>python 生成器与协程的关系和区别</title>
    <url>/2020/09/22/python-%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>部分摘录自官方中文文档，python 版本 <code>3.7.4</code></p>
<p>注意概念区分：生成器函数，生成器，协程函数，协程，异步生成器函数，异步生成器</p>
<p>主要是学习笔记，没有进行过多整理</p>
<ul>
<li><p>使用 async def 语法定义的函数总是为协程函数，即使它们不包含 await 或 async 关键字，另外 await，async for 以及 async with 只能在协程函数体中使用（注：以普通函数调用方式调用协程函数时，将返回协程对象，而不是运行协程）</p>
</li>
<li><p>在一个函数体内使用 yield 表达式会使这个函数变成一个生成器，并且在一个 async def 定义的函数体（注：协程函数）内使用 yield 表达式会让协程函数变成异步的生成器（注：以普通函数调用方式调用生成器函数时，将返回生成器对象，而不是运行生成器；以普通函数调用方式调用异步生成器函数时，将返回异步生成器对象，而不是运行异步生成器）</p>
</li>
<li><p>生成器函数与协程（注：函数）非常相似，它们 yield 多次，它们具有多个入口点，并且它们的执行可以被挂起。唯一的区别是生成器函数不能控制在它在 yield 后交给哪里继续执行，控制权总是转移到生成器的调用者</p>
</li>
<li><p>当使用 yield from <expr> 时，它会将所提供的表达式视为一个子迭代器，这个子迭代器产生的所有值都直接被传递给当前生成器方法的调用者</p>
</li>
<li><p>启动一个生成器的方法有两种，注意，这两种调用都有返回值，返回的是生成器 yield 的值：</p>
<ul>
<li>使用内建的 next() 函数，继续使用 next() 函数将继续运行生成器</li>
<li>使用生成器的 send() 方法，但启动时必须传参 None，继续调用 send() 方法将继续运行生成器，此时可以向生成器传入任意值</li>
</ul>
</li>
<li><p>启动一个协程的方法：导入 asyncio 包，使用 asyncio.run() 函数执行一个协程，注意，需要传入协程对象作为参数，而不是协程函数</p>
</li>
<li><p>注意，await 语句返回指定协程 return 的值（与生成器的 yeild 有区别）</p>
</li>
<li><p>如果只有一个协程在运行的话，代码执行流程与普通函数一样，因为协程函数中的 await &lt;指定协程&gt; 语句将会挂起（阻塞）当前协程，去执行 await 语句指定的协程，直到指定协程执行结束返回后才恢复当前协程</p>
</li>
<li><p>可以使用 asyncio.gather() 函数并发执行多个协程</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>生成器</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>python的库文件在哪儿</title>
    <url>/2017/07/20/python%E7%9A%84%E5%BA%93%E6%96%87%E4%BB%B6%E5%9C%A8%E5%93%AA%E5%84%BF/</url>
    <content><![CDATA[<blockquote>
<p>当前操作系统: deepin基于debian</p>
</blockquote>
<h1 id="模块管理器pip"><a href="#模块管理器pip" class="headerlink" title="模块管理器pip"></a>模块管理器pip</h1><p>默认的命令pip可能是来自pip2也可能是pip3, 这取决于安装pip2和pip3的顺序,<br>安装pip2或pip3时会覆盖原有pip可执行文件, 所以在使用pip安装python模块时,<br>最好明确指出使用pip2还是pip3, 而不是直接使用pip命令, 这样可以避免明明要安装python3的模块库, 下载安装的却是python2的模块库.</p>
<h1 id="安装模块-库"><a href="#安装模块-库" class="headerlink" title="安装模块(库)"></a>安装模块(库)</h1><p>使用pip命令安装模块时, 是否使用sudo提权会影响安装路径.</p>
<h2 id="使用sudo提权"><a href="#使用sudo提权" class="headerlink" title="使用sudo提权"></a>使用sudo提权</h2><p>会安装模块到以下路径:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/lib/python*(版本不同,具体目录不同)</span><br><span class="line"><span class="comment"># python自带的一些模块文件在这个路径下.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/lib/python*(版本不同,具体目录不同)</span><br><span class="line"><span class="comment"># 用户自行安装的模块一般在这个路径下.</span></span><br></pre></td></tr></table></figure>

<h2 id="没有使用sudo提权"><a href="#没有使用sudo提权" class="headerlink" title="没有使用sudo提权"></a>没有使用sudo提权</h2><p>会安装模块到以下路径:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">~/.local/lib/python*(版本不同,具体目录不同)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>qprocess参数设置</title>
    <url>/2018/09/24/qprocess%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>QProcess用于启动一个外部程序，并提供了与之通信的接口。<br>使用setProgram来设置要启动的外部程序，setArguments来设置要传递给这个外部程序的参数。<br>setArguments需要一个QStringList类型的参数，在构造这个参数的时候要注意不能把外部程序需要的参数作为一整个字符串。<br>举个例子：要用QProcess执行<code>find -name abc.txt</code></p>
<figure class="highlight qt"><table><tr><td class="code"><pre><span class="line">QProcess process;</span><br><span class="line">process.setProgram(<span class="string">&quot;find&quot;</span>);</span><br><span class="line">process.setArguments(QStringList(<span class="string">&quot;-name abc.txt&quot;</span>)); <span class="comment">// 这是错误的</span></span><br><span class="line">process.setArguments(QStringList() &lt;&lt; <span class="string">&quot;-name&quot;</span> &lt;&lt; <span class="string">&quot;abc.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>qtcreator-fakevim-小企鹅输入法自动切换到英文</title>
    <url>/2018/11/04/qtcreator-fakevim-%E5%B0%8F%E4%BC%81%E9%B9%85%E8%BE%93%E5%85%A5%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E5%88%B0%E8%8B%B1%E6%96%87/</url>
    <content><![CDATA[<p>qtcreator 的 fakevim 不支持原生 vim 的插件，所以就用不了 fcitx.vim 这个好用的插件了，所以只能自食其力喽。根据 fcitx 支持 dbus 通信的原理，实现了在 INSERT 模式下按 <code>ESC</code> 键回到 NORMAL 模式时自动切换到英文状态。<br>由于 fakevim 支持的特性过于简陋，目前只实现了这个，并不能像 fcitx.vim 插件一样记住 INSERT 模式下的中英文状态，等下次进入 INSERT 模式时再自动切回去，不过这样也舒服了很多了，将下面的配置放到 qtcreator fakevim 插件的配置文件中即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot; 从insert模式按esc回到normal模式时自动关闭小企鹅输入法</span><br><span class="line">inoremap &lt;ESC&gt; &lt;ESC&gt;:!dbus-send --type&#x3D;method_call --dest&#x3D;org.fcitx.Fcitx &#x2F;inputmethod org.fcitx.Fcitx.InputMethod.InactivateIM&lt;CR&gt;</span><br></pre></td></tr></table></figure>

<p>在 qtcreator 的设置里有 fakevim 设置项，里面有一项是设置 fakevim 启动时要加载的配置文件的路径。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>qtcreator</tag>
        <tag>fakevim</tag>
        <tag>vim</tag>
        <tag>fcitx</tag>
      </tags>
  </entry>
  <entry>
    <title>qtcreator qDebug 没有打印输出</title>
    <url>/2021/08/14/qtcreator-qDebug-%E6%B2%A1%E6%9C%89%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>前段时间遇到个奇怪的问题，在 qtcreator 中 <code>qDebug</code> 语句的打印内容一直出不来，解决方法是在构建工具链设置中新增一个环境变量：<code>QT_ASSUME_STDERR_HAS_CONSOLE=1</code></p>
<p>具体步骤（英文菜单）：<br>点击 qtcreator 工具栏，依次点击 <code>Tools</code> &gt; <code>Options</code> &gt; <code>Kits</code>，之后选择正在使用的 <code>Kits</code>，滚动找到 <code>Environment</code>, 点击 <code>Change</code> 然后新增上面提到的环境变量即可。</p>
<p>参考链接：<a href="https://stackoverflow.com/questions/41425530/qtcreator-qdebug-messages-not-shown">https://stackoverflow.com/questions/41425530/qtcreator-qdebug-messages-not-shown</a></p>
]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>qtcreator</tag>
        <tag>qt</tag>
        <tag>qdebug</tag>
      </tags>
  </entry>
  <entry>
    <title>qt中的QPointer QSharedPointer等智能指针</title>
    <url>/2018/11/24/qt%E4%B8%AD%E7%9A%84QPointer-QSharedPointer%E7%AD%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="QPointer"><a href="#QPointer" class="headerlink" title="QPointer"></a>QPointer</h1><p>QPointer在用法上跟普通的指针没有什么区别, 可以将它当做是一个普通指针一样使用. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barFunc</span><span class="params">(QLabel *label)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QPointer&lt;QLabel&gt; pointer;</span><br><span class="line">pointer = <span class="keyword">new</span> QLabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接将pointer作为QLabel类型的指针传入barFunc函数作为参数</span></span><br><span class="line">barFunc(pointer);</span><br></pre></td></tr></table></figure>

<p><strong>主要作用:</strong></p>
<p>QPointer的主要功能是避免<code>悬空指针</code>的出现, <strong>悬空指针是指: 指针不为空, 但是其指向的对象已经不在了.</strong> 也就是说当对象在其他地方被delete了, 而我们所持有的指向这个对象的指针依然指向那块内存地址, 而没有被置为空, 此时如果使用这个指针就会出错. 下面的QSharedPointer也有避免悬空指针的功能.</p>
<p><strong>使用场景:</strong></p>
<p>在多个不同地方的指针指向同一个对象, 当一个地方delete了这个对象后, 其他地方依然会使用指向这个对象的指针, 此时如果没有使用QPointer封装, <code>if (pointer)</code>返回的是<code>true</code>, 而如果使用QPointer封装, QPointer检测到对象被销毁那么<code>if (pointer)</code>返回的是<code>false</code>.</p>
<p><strong>场景举例:</strong></p>
<ul>
<li>我需要将我的一个对象以指针的形式暴露出去, 而且我会在某些情况下<code>delete</code>这个对象, 那我暴露出去的指针就应该使用QPointer封装一下.</li>
<li>(上面情况的另一个视角)我接收了一个指针, 但指针指向的对象会在别的地方被销毁, 那我接收这个指针时就应该使用QPointer封装一下.</li>
</ul>
<h1 id="QSharedPointer"><a href="#QSharedPointer" class="headerlink" title="QSharedPointer"></a>QSharedPointer</h1><p>QSharedPointer提供了对引用计数的共享指针实现.<br>引用计数即: 每当创建一个QSharedPointer副本时, 其引用计数加1, 每当一个QSharedPointer副本被销毁时, 其引用计数减1, 当引用计数为0时, 则销毁其封装或指向的对象.</p>
<p><strong>主要作用:</strong><br>使用QSharedPointer时不需要再时刻牢记delete对象以避免内存泄漏, 因为当QSharedPointer超出其作用域被销毁时, 如果没有其他QSharedPointer引用这个对象时, 即当引用计数为0时, 就会销毁其封装或指向的对象.</p>
<p><strong>使用场景:</strong></p>
<ul>
<li>如果不想手动删除new出来的对象就可以使用QSharedPointer封装它</li>
<li>一个对象有很多地方在使用, 而且有可能不小心删除(不应该被删除)</li>
</ul>
<h1 id="QWeakPointer"><a href="#QWeakPointer" class="headerlink" title="QWeakPointer"></a>QWeakPointer</h1><p>主要用途跟QPointer差不多, 但却不如QPointer好用, 因为要创建它只能通过一个已有的QSharedPointer对象来创建, 而且也不能将它看做其追踪的指针对象直接进行操作, 还要先将其转到QSharedPointer才行, 但是既然有这类, 就应该有其道理, 只是我还没碰到使用它的场景. 总之, 目前感觉这个类没用.</p>
<h1 id="QScopedPointer"><a href="#QScopedPointer" class="headerlink" title="QScopedPointer"></a>QScopedPointer</h1><p>从名字可以看出来, 这是一个跟作用域有关的智能指针, 一般只将其声明为栈对象但封装一个堆对象, 它只做一件事, 就是当QScopedPointer对象(栈对象)超出其作用域要被销毁时, 在它的析构函数里删除追踪的对象(堆对象). 注意这里并不会检查这个对象是否应该删除, 或者是否有其他指针依然引用/指向这个对象, 而是直接删除它. 这也是QScopedPointer和QSharedPointer在自动销毁对象这一作用上的区别.</p>
<h1 id="QSharedDataPointer"><a href="#QSharedDataPointer" class="headerlink" title="QSharedDataPointer"></a>QSharedDataPointer</h1><p>QSharedDataPointer主要用来结合QSharedData实现<code>隐式共享数据类</code>, <code>隐式共享</code>即写时拷贝机制, 当修改一个对象时才将其数据拷贝一份到自己名下, 否则大家公用一份数据, 读取一份数据, 从智能指针的角度来看这个类并不主要为指针服务, 因此如果不是为了实现自己的隐式共享不需要深入了解这个类. 其具体作用和详细用法可以在qt的文档中查看.</p>
<h1 id="QExplicitlySharedDataPointer"><a href="#QExplicitlySharedDataPointer" class="headerlink" title="QExplicitlySharedDataPointer"></a>QExplicitlySharedDataPointer</h1><p>QExplicitlySharedDataPointer用来实现<code>显示共享数据类</code>, <code>显示共享</code>与<code>隐式共享</code>是相反的, 隐式共享会自动调用QSharedDataPointer的<code>detach()</code>方法实现写时拷贝, 而显示共享则需要手动明确调用<code>detach()</code>方法来进行数据的拷贝, 如果没有明确调用<code>detach()</code>方法则会直接修改共享的数据, 如果一直没有明确调用<code>detach()</code>方法则这个类的行为与QSharedPointer一样.</p>
]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>智能指针</tag>
        <tag>QPointer</tag>
        <tag>QSharedPointer</tag>
      </tags>
  </entry>
  <entry>
    <title>qt中翻译静态成员变量中的字符串</title>
    <url>/2018/11/04/qt%E4%B8%AD%E7%BF%BB%E8%AF%91%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>在 qt 中要翻译一个字符串很简单，只需要使用 <code>tr</code> 函数包裹住字符串即可。后来发现这一方法对于静态变量无效，经同事提醒原来静态数据初始化时，程序还没有加载翻译数据，也就是一般写在 main 函数中的 QTranslator::load() / app.installTranslator() 类似代码。</p>
<p>经过一番搜索和阅读 qt 文档，找到了解决方法，原来 qt 早已有应对之策：<code>QT_TR_NOOP</code> 这个宏，或者说这类宏，因为类似的还有 <code>QT_TR_NOOP_UTF8</code> <code>QT_TRANSLATE_NOOP</code>，这里只是简要说一下其大概用法，想要了解更多可以查阅 qt 相关文档。下面只介绍 <code>QT_TR_NOOP</code> 这个宏的用法：</p>
<p>这个宏跟 <code>tr</code> 函数的原理不同，<code>tr</code> 函数中的字符串会在程序加载时被替换为翻译后的文本，可以理解为这是一种类似宏展开的过程，因此这是一种静态的翻译，而 <code>QT_TR_NOOP</code> 这个宏则是动态翻译，传给这个宏的字符串将会被标记为需要动态翻译的内容，何为动态翻译，也就是说在程序加载时不会被修改/替换字符串( tr() 函数的过程)，而是在真正使用时再进行翻译，拿 qt 文档中的例子来看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">FriendlyConversation::greeting</span><span class="params">(<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *greeting_strings[] = &#123;</span><br><span class="line">  QT_TR_NOOP(<span class="string">&quot;Hello&quot;</span>),</span><br><span class="line">  QT_TR_NOOP(<span class="string">&quot;Goodbye&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> tr(greeting_strings[type]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中数组 <code>greeting_strings</code> 的成员是两个被标记为需要动态翻译的字符串，下面 return 就是真正要使用的地方，同样是用到了 <code>tr</code> 函数，将数据的成员传入即可。</p>
<p>如果静态字符串数据是一个 QMap 或者 QList 那使用时就要将成员转化为 c 风格的字符串或byte数组，还是上面的代码，稍加修改为 QList 类型的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">FriendlyConversation::greeting</span><span class="params">(<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> QList *greeting_string_list = &#123;</span><br><span class="line">  QT_TR_NOOP(<span class="string">&quot;Hello&quot;</span>),</span><br><span class="line">  QT_TR_NOOP(<span class="string">&quot;Goodbye&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> tr(greeting_string_list[type].toUtf8());</span><br><span class="line"><span class="comment">// 或者：greeting_string_list[type].toLocal8Bit() 之类的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>static</tag>
        <tag>qt</tag>
        <tag>tr</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>the menu is gone in qt on mac osx</title>
    <url>/2018/01/06/the-menu-is-gone-in-qt-on-mac-osx/</url>
    <content><![CDATA[<p>在osx系统下, qt程序菜单项的名字如果是“quit”,”about”(不区分大小写), 这个菜单项就会消失, 如果这个菜单只包含这些会消失的菜单项, 那么这个菜单也会消失.<br>猜测: 这应该是由于跟osx系统默认给程序提供了一些菜单项有冲突的关系.</p>
<p>问题示例代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SimpleMenu::SimpleMenu(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent) &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 只要菜单项的名字不是“Quit”或“quit”就可以正常显示</span></span><br><span class="line">  QAction *quit = <span class="keyword">new</span> QAction(<span class="string">&quot;&amp;Quit&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 只要菜单项的名字不是“About”或“about”就可以正常显示</span></span><br><span class="line">  QAction *about = <span class="keyword">new</span> QAction(<span class="string">&quot;&amp;about&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  QMenu *file;</span><br><span class="line">  file = menuBar()-&gt;addMenu(<span class="string">&quot;&amp;File&quot;</span>);</span><br><span class="line">  file-&gt;addAction(quit);</span><br><span class="line">  file-&gt;addAction(about);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">connect</span>(quit, &amp;QAction::triggered, qApp, QApplication::quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>menu</tag>
        <tag>disappear</tag>
      </tags>
  </entry>
  <entry>
    <title>tilda开机启动不透明</title>
    <url>/2016/05/01/tilda%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E4%B8%8D%E9%80%8F%E6%98%8E/</url>
    <content><![CDATA[<blockquote>
<p>当前系统,archlinux+xfce4</p>
</blockquote>
<h1 id="tilda简介"><a href="#tilda简介" class="headerlink" title="tilda简介"></a>tilda简介</h1><p>tilda有一个非常方便的功能,那就是绑定一个按键,来切换tilda这个终端模拟器的显示和隐藏,<br>注意是显示和隐藏而不是开启和关闭,它在切换的期间不会影响终端中所执行的命令,<br>如果用过deepin linux的话应该就知道dde自带的终端有个特殊的模式叫雷神模式,<br>原理就跟tilda一样</p>
<h1 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h1><p>设置tilda开机启动很简单,就是在’~/.config/autostart/‘下放一个tilda的desktop文件就行了,<br>也可以把系统的链接过去:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/share/applications/tilda.desktop ~/.config/autostart/</span><br></pre></td></tr></table></figure>

<h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>可是当你开机后按’F1’(tilda默认绑定的按键)打开tilda后,如果你设置了tilda的背景为透明,<br>你会发现透明没有生效,而是黑色的背景,此时按’CTRL-SHIFT-q’退出tilda,再重新打开,<br>发现透明又生效了,经过再三校验tilda的配置文件的确正确后,只能猜测是xfce4桌面环境在<br>刚启动的时候,透明化这个功能暂时还没有初始化完成,而此时tilda已经启动了,所以就造成上述结果</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>既然tilda的透明化需要等待系统初始化完毕,那么让tilda暂停一会儿再启动就行了<br>所以上面开机启动一段在’~/.config/autostart/‘下的tilda.desktop文件就不要了,删掉后自己新建一个</p>
<p>总共需要两个文件,为了方便管理,都放在’~/.config/autostart/‘下<br>第一个文件,tilda.desktop:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Type=Application</span><br><span class="line">Name=startTilda</span><br><span class="line">Comment=start tilda terminal</span><br><span class="line">Exec=sh ~/.config/autostart/tilda.sh</span><br><span class="line">Icon=</span><br><span class="line">Path=</span><br><span class="line">Terminal=<span class="literal">false</span></span><br><span class="line">StartupNotify=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>第二个文件,tilda.sh:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">sleep 10</span><br><span class="line">tilda</span><br></pre></td></tr></table></figure>
<p>分别复制上面的两段代码到两个文件中,并把两个文件放到’~/.config/autostart/‘下,<br>为了确保完成,赋予两个文件可执行权限:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod a+x ~/.config/autostart/*</span><br></pre></td></tr></table></figure>
<p>第一个desktop文件的作用是:桌面环境启动时会执行这个文件中’Exec=’之后的命令<br>而这里的命令则是调用tilda.sh文件,<br>第二个sh文件,也就是tilda.sh文件中之后两行命令,第一行暂停10秒,第二行就是启动tilda了,<br>可以根据自己需要修改暂停的时间,不过我这里5秒偶尔会出现依然不透明的情况</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tilda</tag>
        <tag>不透明</tag>
      </tags>
  </entry>
  <entry>
    <title>typedef 函数别名</title>
    <url>/2019/10/22/typedef-%E5%87%BD%E6%95%B0%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<p>在 c/cpp 中可以使用 <code>typedef</code> 来给一个类型搞个别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int myint;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面 a 和 b 的类型都可以说是 int</span><br><span class="line">int a;</span><br><span class="line">myint b;</span><br></pre></td></tr></table></figure>

<p>而函数别名的语法有些不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int max(int, int);</span><br><span class="line">typedef int (* max_func_t)(int, int);</span><br><span class="line"></span><br><span class="line">max_func_t max_alias;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面的两个调用是等价的</span><br><span class="line">max(1, 2);</span><br><span class="line">max_alias(1, 2);</span><br></pre></td></tr></table></figure>

<p>将函数指针作为参数时，使用函数别名可以大大提高代码的可读性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int max(int, int);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不使用别名，接收一个函数指针并调用</span><br><span class="line">void test(int (* max_func)(int, int)) &#123;</span><br><span class="line">    max_func(1, 2);</span><br><span class="line">&#125;</span><br><span class="line">test(max);</span><br><span class="line"></span><br><span class="line">typedef int (* max_func_t)(int, int);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用别名，接收一个函数指针并调用</span><br><span class="line">void test(max_func_t max_func) &#123;</span><br><span class="line">    max_func(1, 2);</span><br><span class="line">&#125;</span><br><span class="line">test(max);</span><br></pre></td></tr></table></figure>

<p>函数别名的语法一直让我很奇怪写着也很难受，今天又碰到要将函数作为参数传递的情况，于是谷歌了一下，其实可以这样理解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确语法</span><br><span class="line">typedef int (*max_func_t)(int, int);</span><br><span class="line">&#x2F;&#x2F;       ^        ^          ^</span><br><span class="line">&#x2F;&#x2F;    返回类型   别名        参数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误语法，但有助于理解（强行理解）</span><br><span class="line">typedef int (*) (int, int) max_func_t;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>typedef</tag>
        <tag>function</tag>
        <tag>别名</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu16.04 安装 python3.8 以及对应版本的 pip</title>
    <url>/2021/08/10/ubuntu16-04-%E5%AE%89%E8%A3%85-python3-8-%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84-pip/</url>
    <content><![CDATA[<p>ubuntu 系统 16.04 版本中，最新版本的 python 是 3.5，从系统源中找不到更新版本的 python，本文介绍一种安装 python3.8 的方法，以及安装对应版本的 pip。</p>
<h2 id="安装-python3-8"><a href="#安装-python3-8" class="headerlink" title="安装 python3.8"></a>安装 python3.8</h2><p>执行如下命令增加 ppa 仓库，并更新源数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:deadsnakes&#x2F;ppa</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>如果提示找不到 <code>add-apt-repository</code> 命令，执行如下命令安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install software-properties-common</span><br></pre></td></tr></table></figure>

<p>更新完成源数据之后，就可以安装 ppa 仓库中的包了，这个仓库中不止是包含 python3.8，还包含其他版本的 python 包，详细情况可查看链接：</p>
<p><a href="https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa">https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa</a></p>
<p>执行以下命令安装 python3.8 相关的包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install python3.8 python3.8-dev python3.8-distutils python3.8-venv</span><br></pre></td></tr></table></figure>

<p>安装完成后，当需要使用 3.8 版本的 python 时，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3.8 --version</span><br></pre></td></tr></table></figure>

<h2 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h2><p>当需要使用 pip 时，由于系统源里的 pip 是 python3.5 对应的，所以针对 python3.8 并不能正常工作，比如使用 virtualenv 创建 python3.8 的虚拟环境时就会报错，可以执行如下命令查看 pip 是对应哪个 python 版本的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 --version</span><br><span class="line"></span><br><span class="line"># 可能的输出如下，注意最后括号里的内容</span><br><span class="line">pip 8.1.1 from &#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages (python 3.5)</span><br></pre></td></tr></table></figure>

<p>前面新增的 ppa 仓库中，只有 python 的包，没有 pip 的，所以需要额外的安装方法，参考 pip 官方安装教程：<a href="https://pip.pypa.io/en/stable/installation/%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%A6%82%E4%B8%8B%E6%96%B9%E6%B3%95%E5%AE%89%E8%A3%85">https://pip.pypa.io/en/stable/installation/，使用如下方法安装</a> python3.8 对应的 pip：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O &#x2F;tmp&#x2F;get-pip.py https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py</span><br><span class="line">python3.8 &#x2F;tmp&#x2F;get-pip.py</span><br></pre></td></tr></table></figure>

<p>上面的两个命令是，下载 pip 官方安装脚本，然后使用 python3.8 执行安装脚本，执行完成后就安装好了 python3.8 对应的 pip，执行如下命令检验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip --version</span><br><span class="line">pip3 --verison</span><br><span class="line">pip3.8 --version</span><br></pre></td></tr></table></figure>

<p>注意！按照此方法安装 pip 后，系统中的默认 pip 将会是最新安装的 pip3.8，可执行程序位于 /usr/local/bin 目录下。</p>
<p>系统默认源中的 python3-pip 包（如果之前安装过），也就是 python3.5 对应的 pip，如果丢失了，可通过执行如下命令重新安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install --reinstall python3-pip</span><br></pre></td></tr></table></figure>

<p>需要使用这个版本的 pip 时，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;pip --version</span><br></pre></td></tr></table></figure>

<p>虽然重新安装了 python3.5 版本的 pip 但系统默认的 pip 仍然是 python3.8 的，因为 python3.8 的 pip 可执行程序位于 <code>/usr/local/bin/pip</code>，这个路径在环境变量中优先级一般更高。</p>
<p>如果想让 python3.5 版本的 pip 作为默认 pip 使用，可以执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -sf &#x2F;usr&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip</span><br><span class="line">sudo ln -sf &#x2F;usr&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3</span><br></pre></td></tr></table></figure>

<p>这样当需要使用 python3.8 版本的 pip 时，就需要使用命令 pip3.8 了。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>uefi-gpt-linux修复grub rescue</title>
    <url>/2016/04/23/uefi-gpt-linux%E4%BF%AE%E5%A4%8Dgrub-rescue/</url>
    <content><![CDATA[<p>搜了点网上的资料、发现都是修复MBR分区的、我的电脑是GPT分区+UEFI、虽然不同、但也大同小异、<br>出现grub rescue模式一般是硬盘分区出现变动、导致旧的grub找不到启动文件而出现的、</p>
<h1 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h1><p>今天开机是出现了这样的提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error:file<span class="string">&#x27;/grub/x86_64-efi/normal.mod&#x27;</span>not found</span><br><span class="line">entering rescue mode...</span><br><span class="line">grub rescue&gt;</span><br></pre></td></tr></table></figure>

<p>大概意思是那个路径下normal.mod文件找不到、从而进入了grub rescue模式<br>那么在grub rescue 模式下应该怎么修复呢？<br>首先使用set 命令只看当前错误的grub变量、下面是我的电脑的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回信息是：</span></span><br><span class="line">cmdpath=(hd0,gpt1)/EFI/Deepin 2014.2</span><br><span class="line">prefix=(hd0,gpt10)/grub</span><br><span class="line">root=hd0,gpt10</span><br></pre></td></tr></table></figure>

<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>那么我们开分析下这些数据、首先cmdpath指向的是UEFI的启动文件、<br>这个应该不会错、因为硬盘第一分区一般都是EFI分区、并且目录“Deepin 2014.2”也不会出错</p>
<p>所以就应该是prefix和root变量出错了、并且是”gpt10”这个指向的分区出错了、<br>这就好办了、只要找到并修改为正确的分区应该就行了</p>
<p>接着使用ls命令来查看当前硬盘上有哪些分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line"></span><br><span class="line">//返回信息是：</span><br><span class="line">hd0,gpt1 hd0,gpt2 hd0,gpt3 hd0,gpt4 hd0,gpt* .......</span><br></pre></td></tr></table></figure>
<p>接下来就该测试到底那个分区才是正确的启动分区、<font color=red><strong>我的linux的boot分区是单独挂出来的</strong></font><br>我们先往上看那个prefix变量、它指向一个分区下的grub目录、<br>那么我们就用这个目录来测试看那个分区中包含grub目录、<br>只要包含这个目录那么基本上就可以确定那个分区就是正确的启动分区了、也就是boot分区</p>
<h1 id="查找正确分区"><a href="#查找正确分区" class="headerlink" title="查找正确分区"></a>查找正确分区</h1><p>使用<code>ls (hd0,gpt*)/grub</code>这个命令来逐一查看分区、注意命令中的<code>*</code>号、要用数字来代替<br>因为我可以确定前几个分区是windows分区、所以我就从(hd0,gpt10)附近的分区开始测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls (hd0,gpt11)/grub</span><br></pre></td></tr></table></figure>
<p>返回信息是提示错误、找不到、或者提示unknown systemfile也就是未知的文件系统<br>所以这个分区：gpt11并不是我们要找的分区</p>
<p>接着:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls (hd0,gpt9)/grub</span><br></pre></td></tr></table></figure>
<p>返回了一些找到的文件夹和文件、其中就包含<font color=red>**”x86_64-efi”**</font>目录、<br>所以这个”gpt9”应该就是正确的启动分区</p>
<h1 id="设置正确变量"><a href="#设置正确变量" class="headerlink" title="设置正确变量"></a>设置正确变量</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> prefix=(hd0,gpt9)/grub</span><br><span class="line"><span class="built_in">set</span> root=hd0,gpt9</span><br></pre></td></tr></table></figure>

<p>注意、这里我把原来错误的gpt10改为了gpt9<br>为什么不设置cmdpath呢？前面已经说了、这个变量一般是不会出错的<br>设置好了之后使用下面的命令来加载模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod  (hd0,gpt9)/grub/x86_64-efi/normal.mod</span><br></pre></td></tr></table></figure>
<p>或者使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod normal</span><br></pre></td></tr></table></figure>
<p>最好使用第一种方法、因为它使用的是完整的路径、<br>可以保证不出错、前提是你找对了分区、</p>
<p>加载好之后<code>grub rescue&gt;</code>这个提示符应该就会发生变化了</p>
<p>然后使用: <code>normal</code><br>这个命令、就出启动到正常的grub启动菜单并正常进入linux了</p>
<h1 id="真正解决问题"><a href="#真正解决问题" class="headerlink" title="真正解决问题"></a>真正解决问题</h1><p>到这里并没有完全搞定、<br>如果你进入linux后重启的话就会发现又出现grub rescue模式了</p>
<p>因为grub rescue模式只是应急、它并没有真正把grub修改为正确的数据</p>
<p>所以要在终端中手动重新修改下grub</p>
<p>进入终端输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line"><span class="comment">#无错误返回、那么接着：</span></span><br><span class="line">sudo grub-install /dev/sda9</span><br></pre></td></tr></table></figure>
<p>这里的sda9是你的boot分区、如果不确定可以再开一个终端<br>使用<code>mount</code>命令来查看你的boot分区挂载到了哪儿</p>
<p>到这里才算是真正修复了</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>grub</tag>
        <tag>uefi</tag>
        <tag>rescue</tag>
        <tag>gpt</tag>
      </tags>
  </entry>
  <entry>
    <title>vim+ycm+eclim+javacomplete解决冲突</title>
    <url>/2016/05/04/vim-ycm-eclim-javacomplete%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<p>四个主角各自的作用:<br>vim:编辑器一枚<br>ycm:自动补全插件(也就是不用按ctrl+x ctrl+o来调用vim的omni全能补全)<br>eclim:让vim可以有部分eclipse的功能,也可以管理eclipse里的项目<br>javacomplete:一个java的补全插件(这里说的是增强版的)</p>
<p>各自网址:<br><a href="https://github.com/Valloric/YouCompleteMe">ycm:https://github.com/Valloric/YouCompleteMe</a><br><a href="http://eclim.org/">eclim:http://eclim.org/</a><br><a href="https://github.com/artur-shaik/vim-javacomplete2">javacomplete:https://github.com/artur-shaik/vim-javacomplete2</a></p>
<p>这篇文章的主要目的不是如何安装和使用这些插件,而是解决eclim和javacomplete之间的冲突</p>
<p>在说冲突之前先说下eclim和javacomplete的生效条件:<br>eclim:编辑的java类型的文件必须是eclipse中的一个项目中的文件<br>javacomplete:只要是java类型的文件都可以补全</p>
<p>什么冲突呢?<br>ycm可以使用vim的omnifunc提供的数据来完成java的自动补全,主要依据在当前打开的java文件的buffer中,<br>执行:<code>set omnifunc</code>返回的结果来确认到底用eclim还是javacomplete提供的补全数据<br>冲突就是如果同时使用这两个插件,那么只要打开java类型的文件,那么就会被自动命令设置成javacomplete的<br>补全,即便是打开eclipse项目中的文件也不会是eclim的补全</p>
<p>解决方法:<br>判断打开的java文件是否是eclipse项目中的文件就行了,判断方法是调用eclim插件的一个方法,<br>当是项目文件时,就不设置javacomplete的补全,如果不是,就设置omnifunc为javacomplete的补全,<br>讲下面的东西粘贴到vimrc中,另外不要在其他地方设置java的omnifunc:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; vim-javacomplete2</span></span><br><span class="line"><span class="comment">&quot; java的omni全能补全(insert模式下ctrl-x-ctrl-o调用),ycm将会自动调用</span></span><br><span class="line"><span class="comment">&quot; 与eclim的自动补全冲突,所以先判断当前文件是否是项目文件</span></span><br><span class="line"><span class="comment">&quot; 如果不是项目文件才使用vim-javacomplete2进行全能补全</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">IsProjectFile</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">let</span> projectName = eclim#project#util#GetCurrentProjectName()</span><br><span class="line">    <span class="keyword">if</span> projectName == <span class="string">&#x27;&#x27;</span></span><br><span class="line">         <span class="keyword">setlocal</span> omnifunc=javacomplete#Complete</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">autocmd</span> FileType java <span class="keyword">call</span> IsProjectFile()</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; eclim/eclimd</span></span><br><span class="line"><span class="comment">&quot; 需要自行安装,不在vim-plug插件管理器管理列表之中</span></span><br><span class="line"><span class="comment">&quot; eclimd读取$ECLIPSE_HOME/configuration/config.ini</span></span><br><span class="line"><span class="comment">&quot; 还读取~/eclimrc配置文件</span></span><br><span class="line"><span class="comment">&quot; 日志级别,日志文件默认在workspace/eclimd.log</span></span><br><span class="line"><span class="comment">&quot; 除了默认的info,还有trace,debug,warning,error,off</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:EclimLogLevel</span> = <span class="string">&#x27;info&#x27;</span></span><br><span class="line"><span class="comment">&quot; 设置浏览器,firefox,mozilla,opera,iexplore</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:EclimBrowser</span> = <span class="string">&#x27;firefox&#x27;</span></span><br><span class="line"><span class="comment">&quot; 让eclim配合ycm实现java等语言的自动补全</span></span><br><span class="line"><span class="comment">&quot; 编辑的文件必须是eclipse的一个项目中的文件才会自动补全</span></span><br><span class="line"><span class="comment">&quot; 这个变量的作用是(仅举例java文件):set omnifunc=eclim#java#complete#CodeComplete</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:EclimCompletionMethod</span> = <span class="string">&#x27;omnifunc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>javacomplete和eclim都需要自己安装具体如何安装可以去上面提供的网址去查看和下载,<br>不会因为添加了这几行配置就可以实现java的补全了,本文中使用的插件管理器是:<code>vim-plug</code></p>
<p>另外推荐一份vim的配置,使用简单,配置文件结构清晰,注释明了,很适合不熟悉vim配置的人入手学习: <a href="https://github.com/wklken/k-vim">k-vim</a></p>
<p>再附上自己的一份配置,借鉴了上面的kvim,但后来觉得不舍和自己,就从零开始自己配置了: <a href="https://github.com/listenerri/ri-vim">ri-vim</a></p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>ycm</tag>
        <tag>eclim</tag>
        <tag>javacomplete</tag>
        <tag>youcompleteme</tag>
      </tags>
  </entry>
  <entry>
    <title>vim-ycm-qt自动补全问题</title>
    <url>/2017/12/21/vim-ycm-qt%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>更新：<br>可以使用<a href="https://github.com/rdnetto/YCM-Generator">rdnetto/YCM-Generator</a>插件来自动生成<code>.ycm_extra_conf.py</code></p>
</blockquote>
<blockquote>
<p>当前操作系统: osx 10.13<br/><br>使用brew安装的qt5</p>
</blockquote>
<p>qt安装目录在哪里不需要管, 因为使用brew更新qt后安装目录会随着版本变动而变动, 但不管哪个版本brew都会在<code>/usr/local/opt/</code>创建一个链接指向真正的目录, 我只安装了qt5, 所以上述目录下有两个链接, qt和qt5, 这两个目录都指向qt5的安装目录, 任选一个路径用于下面的命令即可, 这里使用这个路径:<code>/usr/local/opt/qt</code>.</p>
<p>执行一个命令来找到所有需要的库的路径:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F; -name &quot;Headers&quot; | grep &quot;framework\&#x2F;Headers&quot; &gt; ~&#x2F;headers</span><br></pre></td></tr></table></figure>
<p>执行完毕后会在HOME下生成<code>headers</code>文件, 文件的内容就是qt5所有的库的路径(头文件), 接下来就是将这些路径添加到ycm的配置文件<code>.ycm_extra_conf.py</code>里了, 下面是我修改好的, 保存为:<code>.ycm_extra_conf.py</code>放到项目目录下(或上级目录), ycm就会自动读取了.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from distutils.sysconfig import get_python_inc</span><br><span class="line">import platform</span><br><span class="line">import os</span><br><span class="line">import ycm_core</span><br><span class="line"></span><br><span class="line"># These are the compilation flags that will be used in case there&#39;s no</span><br><span class="line"># compilation database set (by default, one is not set).</span><br><span class="line"># CHANGE THIS LIST OF FLAGS. YES, THIS IS THE DROID YOU HAVE BEEN LOOKING FOR.</span><br><span class="line">flags &#x3D; [</span><br><span class="line">&#39;-Wall&#39;,</span><br><span class="line">&#39;-Wextra&#39;,</span><br><span class="line">&#39;-Werror&#39;,</span><br><span class="line">&#39;-Wno-long-long&#39;,</span><br><span class="line">&#39;-Wno-variadic-macros&#39;,</span><br><span class="line">&#39;-fexceptions&#39;,</span><br><span class="line">&#39;-DNDEBUG&#39;,</span><br><span class="line"># You 100% do NOT need -DUSE_CLANG_COMPLETER in your flags; only the YCM</span><br><span class="line"># source code needs it.</span><br><span class="line">&#39;-DUSE_CLANG_COMPLETER&#39;,</span><br><span class="line"># THIS IS IMPORTANT! Without the &#39;-x&#39; flag, Clang won&#39;t know which language to</span><br><span class="line"># use when compiling headers. So it will guess. Badly. So C++ headers will be</span><br><span class="line"># compiled as C headers. You don&#39;t want that so ALWAYS specify the &#39;-x&#39; flag.</span><br><span class="line"># For a C project, you would set this to &#39;c&#39; instead of &#39;c++&#39;.</span><br><span class="line">&#39;-x&#39;,</span><br><span class="line">&#39;c++&#39;,</span><br><span class="line">&#39;-isystem&#39;,</span><br><span class="line">&#39;..&#x2F;BoostParts&#39;,</span><br><span class="line">&#39;-isystem&#39;,</span><br><span class="line">get_python_inc(),</span><br><span class="line">&#39;-isystem&#39;,</span><br><span class="line">&#39;..&#x2F;llvm&#x2F;include&#39;,</span><br><span class="line">&#39;-isystem&#39;,</span><br><span class="line">&#39;..&#x2F;llvm&#x2F;tools&#x2F;clang&#x2F;include&#39;,</span><br><span class="line">&#39;-I&#39;,</span><br><span class="line">&#39;.&#39;,</span><br><span class="line">&#39;-I&#39;,</span><br><span class="line">&#39;.&#x2F;ClangCompleter&#39;,</span><br><span class="line">&#39;-isystem&#39;,</span><br><span class="line">&#39;.&#x2F;tests&#x2F;gmock&#x2F;gtest&#39;,</span><br><span class="line">&#39;-isystem&#39;,</span><br><span class="line">&#39;.&#x2F;tests&#x2F;gmock&#x2F;gtest&#x2F;include&#39;,</span><br><span class="line">&#39;-isystem&#39;,</span><br><span class="line">&#39;.&#x2F;tests&#x2F;gmock&#39;,</span><br><span class="line">&#39;-isystem&#39;,</span><br><span class="line">&#39;.&#x2F;tests&#x2F;gmock&#x2F;include&#39;,</span><br><span class="line">&#39;-isystem&#39;,</span><br><span class="line">&#39;.&#x2F;benchmarks&#x2F;benchmark&#x2F;include&#39;,</span><br><span class="line"># for qt5 which installed by brew in mac</span><br><span class="line">&#39;-I&#39;, &#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;include&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DAnimation.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DCore.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DExtras.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DInput.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DLogic.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DQuick.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DQuickAnimation.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DQuickExtras.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DQuickInput.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DQuickRender.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DQuickScene2D.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;Qt3DRender.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtBluetooth.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtCharts.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtConcurrent.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtCore.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtDataVisualization.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtDBus.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtDesigner.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtDesignerComponents.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtGamepad.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtGui.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtHelp.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtLocation.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtMacExtras.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtMultimedia.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtMultimediaQuick_p.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtMultimediaWidgets.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtNetwork.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtNetworkAuth.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtNfc.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtOpenGL.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtPositioning.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtPrintSupport.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtPurchasing.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtQml.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtQuick.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtQuickControls2.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtQuickParticles.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtQuickTemplates2.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtQuickTest.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtQuickWidgets.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtRemoteObjects.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtRepParser.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtScript.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtScriptTools.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtScxml.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtSensors.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtSerialBus.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtSerialPort.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtSql.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtSvg.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtTest.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtTextToSpeech.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtUiPlugin.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtWebChannel.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtWebEngine.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtWebEngineCore.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtWebEngineWidgets.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtWebSockets.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtWebView.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtWidgets.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtXml.framework&#x2F;Headers&#39;,</span><br><span class="line">&#39;-I&#39;,&#39;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;qt&#x2F;lib&#x2F;QtXmlPatterns.framework&#x2F;Headers&#39;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># Clang automatically sets the &#39;-std&#x3D;&#39; flag to &#39;c++14&#39; for MSVC 2015 or later,</span><br><span class="line"># which is required for compiling the standard library, and to &#39;c++11&#39; for older</span><br><span class="line"># versions.</span><br><span class="line">if platform.system() !&#x3D; &#39;Windows&#39;:</span><br><span class="line">  flags.append( &#39;-std&#x3D;c++11&#39; )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Set this to the absolute path to the folder (NOT the file!) containing the</span><br><span class="line"># compile_commands.json file to use that instead of &#39;flags&#39;. See here for</span><br><span class="line"># more details: http:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;JSONCompilationDatabase.html</span><br><span class="line">#</span><br><span class="line"># You can get CMake to generate this file for you by adding:</span><br><span class="line">#   set( CMAKE_EXPORT_COMPILE_COMMANDS 1 )</span><br><span class="line"># to your CMakeLists.txt file.</span><br><span class="line">#</span><br><span class="line"># Most projects will NOT need to set this to anything; you can just change the</span><br><span class="line"># &#39;flags&#39; list of compilation flags. Notice that YCM itself uses that approach.</span><br><span class="line">compilation_database_folder &#x3D; &#39;&#39;</span><br><span class="line"></span><br><span class="line">if os.path.exists( compilation_database_folder ):</span><br><span class="line">  database &#x3D; ycm_core.CompilationDatabase( compilation_database_folder )</span><br><span class="line">else:</span><br><span class="line">  database &#x3D; None</span><br><span class="line"></span><br><span class="line">SOURCE_EXTENSIONS &#x3D; [ &#39;.cpp&#39;, &#39;.cxx&#39;, &#39;.cc&#39;, &#39;.c&#39;, &#39;.m&#39;, &#39;.mm&#39; ]</span><br><span class="line"></span><br><span class="line">def DirectoryOfThisScript():</span><br><span class="line">  return os.path.dirname( os.path.abspath( __file__ ) )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def IsHeaderFile( filename ):</span><br><span class="line">  extension &#x3D; os.path.splitext( filename )[ 1 ]</span><br><span class="line">  return extension in [ &#39;.h&#39;, &#39;.hxx&#39;, &#39;.hpp&#39;, &#39;.hh&#39; ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def GetCompilationInfoForFile( filename ):</span><br><span class="line">  # The compilation_commands.json file generated by CMake does not have entries</span><br><span class="line">  # for header files. So we do our best by asking the db for flags for a</span><br><span class="line">  # corresponding source file, if any. If one exists, the flags for that file</span><br><span class="line">  # should be good enough.</span><br><span class="line">  if IsHeaderFile( filename ):</span><br><span class="line">    basename &#x3D; os.path.splitext( filename )[ 0 ]</span><br><span class="line">    for extension in SOURCE_EXTENSIONS:</span><br><span class="line">      replacement_file &#x3D; basename + extension</span><br><span class="line">      if os.path.exists( replacement_file ):</span><br><span class="line">        compilation_info &#x3D; database.GetCompilationInfoForFile(</span><br><span class="line">          replacement_file )</span><br><span class="line">        if compilation_info.compiler_flags_:</span><br><span class="line">          return compilation_info</span><br><span class="line">    return None</span><br><span class="line">  return database.GetCompilationInfoForFile( filename )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def FlagsForFile( filename, **kwargs ):</span><br><span class="line">  if not database:</span><br><span class="line">    return &#123;</span><br><span class="line">      &#39;flags&#39;: flags,</span><br><span class="line">      &#39;include_paths_relative_to_dir&#39;: DirectoryOfThisScript()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  compilation_info &#x3D; GetCompilationInfoForFile( filename )</span><br><span class="line">  if not compilation_info:</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">  # Bear in mind that compilation_info.compiler_flags_ does NOT return a</span><br><span class="line">  # python list, but a &quot;list-like&quot; StringVec object.</span><br><span class="line">  final_flags &#x3D; list( compilation_info.compiler_flags_ )</span><br><span class="line"></span><br><span class="line">  # NOTE: This is just for YouCompleteMe; it&#39;s highly likely that your project</span><br><span class="line">  # does NOT need to remove the stdlib flag. DO NOT USE THIS IN YOUR</span><br><span class="line">  # ycm_extra_conf IF YOU&#39;RE NOT 100% SURE YOU NEED IT.</span><br><span class="line">  try:</span><br><span class="line">    final_flags.remove( &#39;-stdlib&#x3D;libc++&#39; )</span><br><span class="line">  except ValueError:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    &#39;flags&#39;: final_flags,</span><br><span class="line">    &#39;include_paths_relative_to_dir&#39;: compilation_info.compiler_working_dir_</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>vim</tag>
        <tag>ycm</tag>
      </tags>
  </entry>
  <entry>
    <title>vim中javacomplete2与syntastic一点使用心得</title>
    <url>/2017/02/12/vim%E4%B8%ADjavacomplete2%E4%B8%8Esyntastic%E4%B8%80%E7%82%B9%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="插件简介"><a href="#插件简介" class="headerlink" title="插件简介"></a>插件简介</h1><h2 id="javacomplete2"><a href="#javacomplete2" class="headerlink" title="javacomplete2"></a>javacomplete2</h2><ul>
<li>提供java语言的补全</li>
<li>便捷的import,extends,implement等</li>
<li>快速插入setter,getter方法,等等</li>
<li>插件地址: <a href="https://github.com/artur-shaik/vim-javacomplete2">https://github.com/artur-shaik/vim-javacomplete2</a></li>
</ul>
<h2 id="syntastic"><a href="#syntastic" class="headerlink" title="syntastic"></a>syntastic</h2><ul>
<li>支持大量语言的语义检测</li>
<li>插件地址: <a href="https://github.com/vim-syntastic/syntastic">https://github.com/vim-syntastic/syntastic</a></li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>当使用javacomplete2(以下简称jc2)补全非项目java文件时,<br>也就是说编辑的文件不是eclipse,gradle,maven等管理的项目中的文件,<br>这时如果是单个文件还没有什么问题,但如果是两个或两个以上,<br>相互关联的文件(如:A文件中new到了B文件中定义的类),jc2就会力不从心,<br>因为jc2不知道所有源文件的位置,以及CLASSPATH应该如何设置,<br>如果是项目文件jc2可以利用项目的配置文件来处理上述问题.</p>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><blockquote>
<p><strong><em>这个问题已经在最新版本中解决了!</em></strong></p>
</blockquote>
<p>当项目中的java文件没有在某个包中时,也就是文件头部没有”package”语句,<br>在eclipse中这叫”default package”,这时jc2也无法处理好多个类文件之间的关系.</p>
<h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p>syntastic在进行java的语法检查时,如果你当前目录不是特定的位置,<br>也会发生找不到某个类的情况.</p>
<h1 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h1><h2 id="处理1"><a href="#处理1" class="headerlink" title="处理1"></a>处理1</h2><p>当使用eclipse等IDE时也就不会使用vim了,但如果不使用IDE时呢?<br>那就用gradle或maven吧,我现在是用的gradle,用gradle可以方便的创建一个项目,<br>而且项目的配置文件简单,甚至不用配置.<br>使用如下命令就可以轻松创建一个项目:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gradle init --type java-library</span><br></pre></td></tr></table></figure>
<p>执行完毕后当前目录结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build.gradle</span><br><span class="line">settings.gradle    (不重要)</span><br><span class="line">gradle&#x2F;wrapper&#x2F;gradle-wrapper.jar    (不重要)</span><br><span class="line">gradle&#x2F;wrapper&#x2F;gradle-wrapper.properties    (不重要)</span><br><span class="line">gradlew    (不重要)</span><br><span class="line">gradlew.bat    (不重要)</span><br><span class="line">src&#x2F;main&#x2F;java&#x2F;Library.java    (创建的默认类)</span><br><span class="line">src&#x2F;test&#x2F;java&#x2F;LibraryTest.java    (创建的默认测试类,不重要)</span><br></pre></td></tr></table></figure>

<p>如上这个项目只是测试一个小问题或者什么的,<br>那么被标记’不重要’的就是可以删除掉的了,这样就只剩下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build.gradle</span><br><span class="line">src&#x2F;main&#x2F;java&#x2F;</span><br></pre></td></tr></table></figure>
<p>简单明了,把java文件创建到”src/main/java/“下就行了.<br>但这样还不够,请看问题2.</p>
<h2 id="处理2"><a href="#处理2" class="headerlink" title="处理2"></a>处理2</h2><p>问题2说了jc2需要有package语句,那就是说需要创建包目录,<br>比如需要创建<code>com.listenerri.test</code>包,那么就在src/main/java/目录下执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p com&#x2F;listenerri&#x2F;test&#x2F;</span><br></pre></td></tr></table></figure>
<p>这样就创建了这个包目录,现在目录结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src&#x2F;main&#x2F;java&#x2F;com&#x2F;listenerri&#x2F;test&#x2F;</span><br></pre></td></tr></table></figure>
<p>这时就可以在test/目录下创建java文件了,而且要文件头部声明包:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.listenerri.test;</span><br></pre></td></tr></table></figure>
<p>现在就可以完整的使用jc2的补全功能,游走在多个类文件之间了.<br>如果你有使用syntastic插件,那就往下看,否则就可以去测试了.</p>
<h2 id="处理3"><a href="#处理3" class="headerlink" title="处理3"></a>处理3</h2><p>在上面问题3中提到syntastic需要在特定的目录下才能正常检测java语法,<br>在本例中那个特定的目录就是<code>src/main/java/</code>,只需要在这个目录下打开<br>java文件就可以了,如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim com&#x2F;listenerri&#x2F;test&#x2F;HelloWorld.java</span><br></pre></td></tr></table></figure>
<p>其实这个问题也跟java中间中声明的package语句有关,当声明包为:</p>
<p><code> package com.listenerri.test;</code><br>包的起始目录为com,那么就要在com目录的上层目录打开java文件,<br>也就是要确保当前的工作目录下有完整的包目录.</p>
<p><strong>Over  : )</strong></p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>vim</tag>
        <tag>javacomplete2</tag>
        <tag>syntastic</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode vim 在 mac osx 和 linux 下输入法自动切换</title>
    <url>/2019/10/24/vscode-vim-%E5%9C%A8-mac-osx-%E5%92%8C-linux-%E4%B8%8B%E8%BE%93%E5%85%A5%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<p>目前 vscode 的 vim 插件支持在不同输入模式下自动切换输入法，可是 vscode 的配置目前不支持判断操作系统， 所以关于输入法切换的相关配置不能在 mac osx 和 linux 下通用，但是又不想因为这个问题维护两份 vscode 的配置文件，所以就想办法在 linux 使用 shell 脚本模仿了一个 im-select 的命令。</p>
<p>关于 vscode vim 插件输入法相关的配置可以到下面的链接中查看：</p>
<p><a href="https://github.com/VSCodeVim/Vim#input-method">https://github.com/VSCodeVim/Vim#input-method</a></p>
<p>按照上面的链接在 mac osx 下安装 im-select 并在 vscode 中进行如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;vim.autoSwitchInputMethod.enable&quot;: true,</span><br><span class="line">&quot;vim.autoSwitchInputMethod.defaultIM&quot;: &quot;com.apple.keylayout.ABC&quot;,</span><br><span class="line">&quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;: &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;im-select&quot;,</span><br><span class="line">&quot;vim.autoSwitchInputMethod.switchIMCmd&quot;: &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;im-select &#123;im&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>关于 <code>vim.autoSwitchInputMethod.defaultIM</code>，我在 mac osx 下用的英文输入法是 <code>com.apple.keylayout.ABC</code>，也可能是其他选项如：<code>com.apple.keylayout.US</code>，这个要根据具体情况来设置。</p>
<p><strong>需要注意的是这个选项的值关系到下面脚本的内容，需要保持一致。</strong></p>
<p>上面的配置在 linux 下会报错，因为上面在 mac osx 下安装的 im-select 没有提供对 linux 的支持，im-select 项目里建议直接使用 fcitx-remote 命令，链接如下：</p>
<p><a href="https://github.com/daipeihust/im-select#fcitx">https://github.com/daipeihust/im-select#fcitx</a></p>
<p>鉴于不想维护两份 vscode 配置文件的原因，分析了一下 vscode 调用 im-select 的情况，在 linux 使用 shell 实现了一个仿冒 mac osx 下 im-select 的脚本，脚本内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env bash</span><br><span class="line"></span><br><span class="line"># this script in order to fake the im-select in mac osx for fcitx in linux</span><br><span class="line"></span><br><span class="line">IM_EN&#x3D;&quot;com.apple.keylayout.ABC&quot;</span><br><span class="line">IM_CN&#x3D;&quot;2&quot;</span><br><span class="line"></span><br><span class="line">FCITX_CMD&#x3D;&#x2F;usr&#x2F;bin&#x2F;fcitx-remote</span><br><span class="line"></span><br><span class="line"># there is no arguments that means query the current im</span><br><span class="line">if [[ -z $@ ]]; then</span><br><span class="line">    if [[ &quot;1&quot; &#x3D;&#x3D; $($FCITX_CMD) ]]; then</span><br><span class="line">        echo &quot;$IM_EN&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;$IM_CN&quot;</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    if [[ &quot;$@&quot; &#x3D;&#x3D; &quot;$IM_EN&quot; ]]; then</span><br><span class="line">        $FCITX_CMD -c</span><br><span class="line">    elif [[ &quot;$@&quot; &#x3D;&#x3D; &quot;$IM_CN&quot; ]]; then</span><br><span class="line">        $FCITX_CMD -o</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>注意根据实际情况修正脚本中 <code>IM_EN</code> 变量的值，将脚本内容复制并保存到 <code>/usr/local/bin/im-select</code> 文件中即可，记得给文件增加可执行权限。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>osx</tag>
        <tag>vim</tag>
        <tag>fctix</tag>
        <tag>vscode</tag>
        <tag>im-select</tag>
      </tags>
  </entry>
  <entry>
    <title>vscodevim 在 wsl 远程开发模式下无法自动切换输入法</title>
    <url>/2023/06/26/vscodevim-%E5%9C%A8-wsl-%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%BE%93%E5%85%A5%E6%B3%95/</url>
    <content><![CDATA[<p>vscode 下的 vim 扩展插件(<a href="https://github.com/VSCodeVim/Vim">vscodevim</a>) 在 windows 下使用 wsl/ssh 远程开发时，设置的自动切换 windows 输入法无效，分析了下源码发现跟自动切换输入法相关的几个设置项，其 scope 被设置为了 machine：</p>
<p><a href="https://github.com/VSCodeVim/Vim/blob/15dbe0b415f269a5be14dc74651a69b9334fba14/package.json#L1064">https://github.com/VSCodeVim/Vim/blob/15dbe0b415f269a5be14dc74651a69b9334fba14/package.json#L1064</a></p>
<p>涉及到的设置项有：</p>
<ul>
<li>vim.autoSwitchInputMethod.defaultIM</li>
<li>vim.autoSwitchInputMethod.switchIMCmd</li>
<li>vim.autoSwitchInputMethod.obtainIMCmd</li>
</ul>
<p>翻阅 vscode 插件开发文档后了解到，当某个配置项的 scope 属性被设置为 machine 时，这意味着此配置项只在 vscode 核心具体工作的那台机器上生效，本地开发时自然是读取正常，但当进行 wsl/ssh 远程开发时，vscode 真正的核心(vscode-server)是在远程主机里工作的，本地可见的 vscode 只是个客户端或者说个空外壳，所以上述几个配置应该在远程主机中设置。</p>
<p>同时 vim 扩展插件的插件类型(extensionKind)被设置为了 ui 类，也就是说 vim 插件只工作 vscode UI 所在的地方，即只工作在客户端/空外壳上。</p>
<p>综上所述，进行远程开发时，vim 插件(其他插件也是这样)中提供的配置项，scope 属性为 machine 的配置需要在远程主机中设置，vscode 提供了这种操作的界面，如下图所示：</p>
<p><img src="./remote-vim-settings.png" alt="remote-vim-settings"></p>
<p>需要注意的是，设置项的值应该跟在 windows 本地做开发的值是一样的，因为 vim 插件只工作在本地，只是需要从远程主机上读取这些配置(这一点设计的很奇怪)。</p>
<p>另外吐槽几句，vscodevim 这个插件目前是 vscode 中提供 vim 功能最完整的插件了，但是感觉 github 上的项目管理者对 PR 的审核很草率，经常引入进来新的 bug，让人头大。</p>
<p>而且感觉项目没什么人维护了，也不发布新版本，前端时间我提了个修复 bug 的 PR，来解决启用自动切换输入法功能时，按 s 或 c 键修改光标下的文本后，没有立即进入 insert 模式的问题，这导致继续输入后会有非预期的文本被替换掉，PR 早就合并了，但已经过去很长时间了，也没有新的 release 出来，上一个 release 版本是在 3 月初发布的，距今已经将近 4 个月。</p>
<p>github 上遗留了一大堆 issue 无人处理，已发布版本中各种小 bug 也没人修复，唉。</p>
<p>除了 vscodevim 另一个风评不错的 vim 插件是 vscode-neovim，安装体验了一把，着实还欠缺火候，不推荐使用。</p>
]]></content>
  </entry>
  <entry>
    <title>windows 下 vscode 使用 msys2 mingw64 作为默认 shell 时识别路径失败</title>
    <url>/2023/06/25/windows-%E4%B8%8B-vscode-%E4%BD%BF%E7%94%A8-msys2-mingw64-%E4%BD%9C%E4%B8%BA%E9%BB%98%E8%AE%A4-shell-%E6%97%B6%E8%AF%86%E5%88%AB%E8%B7%AF%E5%BE%84%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p>这两天遇到一个 vscode 下 vim 插件的问题（另写一篇文章详述），按照 <a href="https://github.com/VSCodeVim/Vim/blob/master/.github/CONTRIBUTING.md#first-time-setup">vscodevim</a> 扩展的构建文档尝试本地调试时，发现无法编译，报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正在执行任务: node_modules\.bin\gulp.cmd build-dev</span><br><span class="line">bash: node_modules.bingulp.cmd: 未找到命令</span><br><span class="line">终端进程“C:\msys64\usr\bin\bash.exe &#39;--login&#39;, &#39;-i&#39;, &#39;-c&#39;, &#39;node_modules\.bin\gulp.cmd build-dev&#39;”已终止，退出代码: 127。</span><br></pre></td></tr></table></figure>

<p>可以看出来是命令找不到，但第二行的报错很奇怪，丢失了 windows 风格路径分隔符 <code>\</code>，查看 vscode 的终端配置发现，我把默认集成终端设置成了 msys2，那么问题很明确了，是因为 msys2 中的 bash 命令不支持 windows 风格的路径分隔符，将其解析为了转义符导致的。</p>
<p>在网上几番搜索皆无果，没有优雅的解决方案，还趁着这个机会认真学习了 vscode 的 launch.json, tasks.json, task provider 等文档，对问题有了一个更深入的了解。</p>
<p>我目前遇到的问题是因为 vscode 自带的 gulp task provider 导致的，当其发现 vscode 在 windows 下运行时，就生成 windows 风格的 gulp 命令路径参数，这在 vscode 使用 cmd 或 powershell 作为默认集成终端时没有问题，但对使用了 bash 作为 shell 的情况就会导致出错了，vscode 的 github 仓库里有几个类似、相关的，已经被关闭并锁定了的 issues:</p>
<p><a href="https://github.com/microsoft/vscode/issues/35593">https://github.com/microsoft/vscode/issues/35593</a></p>
<p><a href="https://github.com/microsoft/vscode/issues/48149">https://github.com/microsoft/vscode/issues/48149</a></p>
<p><a href="https://github.com/microsoft/vscode/issues/40954">https://github.com/microsoft/vscode/issues/40954</a></p>
<p>无意间从 <a href="https://stackoverflow.com/a/49779607/7059407">这篇回答中找到了灵感</a>，所以有了如下解决方案，修改 vscode 的配置文件 settings.json，在对集成终端的配置中添加一个自定义终端配置，并将其设置为默认终端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;terminal.integrated.profiles.windows&quot;: &#123;</span><br><span class="line">    &quot;bash (MINGW64-MSYS2)&quot;: &#123;</span><br><span class="line">        &quot;path&quot;: &quot;C:\\msys64\\usr\\bin\\bash.exe&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;--login&quot;,</span><br><span class="line">            &quot;-i&quot;,</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;if [ -z \&quot;$@\&quot; ]; then bash; else eval \&quot;$(cygpath \&quot;$@\&quot;)\&quot;; fi&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;env&quot;: &#123;</span><br><span class="line">            &quot;CHERE_INVOKING&quot;: &quot;1&quot;,</span><br><span class="line">            &quot;MSYSTEM&quot;: &quot;MINGW64&quot;,</span><br><span class="line">            &quot;MSYS2_PATH_TYPE&quot;: &quot;inherit&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; other terminal profiles</span><br><span class="line">    &#x2F;&#x2F; ....</span><br><span class="line">&#125;,</span><br><span class="line">&quot;terminal.integrated.defaultProfile.windows&quot;: &quot;bash (MINGW64-MSYS2)&quot;,</span><br></pre></td></tr></table></figure>

<p>主要是使用了 msys2 中的 cygpath 命令，将文件路径转换为 unix 风格后再继续执行，如果使用 WSL 也可以比葫芦画瓢，但将 cygpath 命令替换为 WSL 中的 wslpath 命令。</p>
<p>这个方法目前我测试用着还行，但还没有长时间使用，不确定是否会带来其他问题，暂且用着吧，如果发现有问题我回来更新此博客。</p>
<p>另外我也在 vscode github 仓库中新建了一个 issue 分享此方法，主要也是希望与别人讨论下此方法是否会带来其他问题：</p>
<p><a href="https://github.com/microsoft/vscode/issues/186119">https://github.com/microsoft/vscode/issues/186119</a></p>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>vscode</tag>
        <tag>msys2</tag>
        <tag>mingw64</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark-filter-Manual-Page</title>
    <url>/2022/10/30/wireshark-filter-Manual-Page/</url>
    <content><![CDATA[<h1 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h1><p>wireshark-filter - Wireshark display filter 显示过滤器语法手册</p>
<h1 id="SYNOPSIS"><a href="#SYNOPSIS" class="headerlink" title="SYNOPSIS"></a>SYNOPSIS</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wireshark [other options] [ -Y &quot;display filter expression&quot; | --display-filter &quot;display filter expression&quot; ]</span><br><span class="line"></span><br><span class="line">tshark [other options] [ -Y &quot;display filter expression&quot; | --display-filter &quot;display filter expression&quot; ]</span><br></pre></td></tr></table></figure>


<h1 id="DESCRIPTION"><a href="#DESCRIPTION" class="headerlink" title="DESCRIPTION"></a>DESCRIPTION</h1><p>Wireshark 和 TShark 共享一个强大的过滤引擎，有助于从数据包列表中去除“噪音”，只看到您感兴趣的数据包。如果一个数据包符合你的过滤器中表达的要求，那么它就会显示在数据包列表中。显示过滤器可让您将协议中的字段与特定值进行比较，将字段与字段进行比较，并检查指定字段或协议是否存在。</p>
<p>过滤器也被其他功能所使用，如统计数据的生成和数据包列表的着色（后者只对Wireshark有效）。本手册页描述了它们的语法。可以在 Wireshark 和 <a href="https://www.wireshark.org/docs/dfref/">https://www.wireshark.org/docs/dfref/</a> 的显示过滤器参考中找到过滤器字段的全部参考文档。</p>
<h1 id="FILTER-语法"><a href="#FILTER-语法" class="headerlink" title="FILTER 语法"></a>FILTER 语法</h1><h2 id="判断一个字段或者协议是否存在"><a href="#判断一个字段或者协议是否存在" class="headerlink" title="判断一个字段或者协议是否存在"></a>判断一个字段或者协议是否存在</h2><p>最简单的过滤器允许您检查协议或字段是否存在。如果您想查看所有包含 IP 协议的数据包，过滤器将是 <code>ip</code>。要查看包含 Token-Ring RIF 字段的所有数据包，请使用 <code>tr.rif</code>。</p>
<p>每当一个协议或字段作为过滤器中一个函数的参数出现时，该协议或字段的存在运算符就会隐含地出现。即该参数表示对应的协议或字段是否存在。</p>
<h2 id="值和运算符"><a href="#值和运算符" class="headerlink" title="值和运算符"></a>值和运算符</h2><p>每个字段都有一个值，该值可用于具有可比性的操作（可能是字面值、其他字段或函数结果）。字段的值不一定在 Wireshark 中显示或在 TShark 的输出中。例如，一个协议在语义上等同于它所跨越的字节序列，而不是它在协议树中显示的文本。</p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较运算符可以通过类似英语的缩写或类似 C 的符号来表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eq, &#x3D;&#x3D;    相等</span><br><span class="line">ne, !&#x3D;    不等</span><br><span class="line">gt, &gt;     大于</span><br><span class="line">lt, &lt;     小于</span><br><span class="line">ge, &gt;&#x3D;    大于等于</span><br><span class="line">le, &lt;&#x3D;    小于等于</span><br></pre></td></tr></table></figure>

<p>比较通常取决于值类型（例如，字符串的字典序和整数的算术。）一个字段可能在给定的帧中出现不止一次。在这种情况下，运算符是严格的，比如相等，则所有字段必须匹配条件，或不相等，任何字段都不匹配条件。不等式是等式的逻辑否定。下表包含所有相等运算符，它们的别名和含义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eq, any_eq, &#x3D;&#x3D;    Any field must be equal 任何字段都相等</span><br><span class="line">ne, all_ne, !&#x3D;    All fields must be not equal 所有字段都不等</span><br><span class="line">    all_eq, &#x3D;&#x3D;&#x3D;   All fields must be equal 所有字段都相等</span><br><span class="line">    any_ne, !&#x3D;&#x3D;   Any fields must be not equal 任何字段都不等</span><br></pre></td></tr></table></figure>

<p>运算符 <code>any</code> 或 <code>all</code> 可以与任何比较运算符一起使用，以使测试匹配任何或所有字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">all tcp.port &gt; 1024</span><br><span class="line">any ip.addr !&#x3D; 1.1.1.1</span><br></pre></td></tr></table></figure>

<p><code>any</code> 或 <code>all</code> 修饰符优先于比较运算符，例如 <code>===</code> 和 <code>any_eq</code> 。</p>
<h2 id="搜索和匹配运算符"><a href="#搜索和匹配运算符" class="headerlink" title="搜索和匹配运算符"></a>搜索和匹配运算符</h2><p>其他运算符仅以英语表示，而不是类似 C 的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contains     协议、字段或切片是否包含某值</span><br><span class="line">matches, ~   字符串是否匹配给定的不区分大小写的 Perl 兼容正则表达式</span><br></pre></td></tr></table></figure>

<p><code>contains</code> 运算符允许过滤器搜索以字符串表示的字符序列或以字节数组表示的字节。在任何隐式或显式转换之后，<code>contains</code> 运算符左侧的类型必须与右侧的类型相当。</p>
<p>例如，要在捕获中搜索给定的 HTTP URL，可以使用以下过滤器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http contains &quot;https:&#x2F;&#x2F;www.wireshark.org&quot;</span><br></pre></td></tr></table></figure>

<p><code>contains</code> 运算符不能用于原子字段，例如数字或 IP 地址。</p>
<p><code>matches</code> 或 <code>~</code> 运算符允许过滤器应用于指定的 Perl 兼容正则表达式 (PCRE2)。正则表达式必须是双引号字符串。<code>matches</code> 运算符的左侧必须是字符串，可以是非字符串字段，可以隐式或显式转换为字符串。默认情况下，<code>matches</code> 不区分大小写。例如，要搜索给定的 WAP WSP User-Agent，您可以编写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsp.header.user_agent matches &quot;cldc&quot;</span><br></pre></td></tr></table></figure>

<p>这将匹配 cldc、CLDC、cLdC 或任何其他大小写字母组合。</p>
<p>您可以使用强制区分大小写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wsp.header.user_agent matches &quot;(?-i)cldc&quot;</span><br></pre></td></tr></table></figure>

<p>这是 PCRE2 的 <code>(?option)</code> 构造的一个示例。 <code>(?-i)</code> 执行区分大小写的模式匹配，但也可以指定其他选项。更多信息可以在 <a href="https://www.pcre.org/current/doc/html/pcre2pattern.html">https://www.pcre.org/current/doc/html/pcre2pattern.html</a> 手册页中找到。</p>
<h2 id="Functions-函数"><a href="#Functions-函数" class="headerlink" title="Functions 函数"></a>Functions 函数</h2><p>过滤器语言具有以下函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upper(string-field) - 将参数（字符串字段）转为大写</span><br><span class="line">lower(string-field) - 将参数（字符串字段）转为小写</span><br><span class="line">len(field)          - 返回参数（字符串或字节字段）的长度</span><br><span class="line">count(field)        - 返回参数（字段）在一个 frame 帧中出现的次数</span><br><span class="line">string(field)       - 将参数（非字符串字段）转为字符串</span><br><span class="line">max(f1,...,fn)      - 返回参数（字段）中的最大值</span><br><span class="line">min(f1,...,fn)      - 返回参数（字段）中的最小值</span><br><span class="line">abs(field)          - 返回参数（数值字段）的绝对值</span><br></pre></td></tr></table></figure>

<p><code>upper()</code> 和 <code>lower()</code> 可用于执行不区分大小写的字符串比较。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upper(ncp.nds_stream_name) contains &quot;MACRO&quot;</span><br><span class="line">lower(mount.dump.hostname) &#x3D;&#x3D; &quot;angel&quot;</span><br></pre></td></tr></table></figure>

<p><code>string()</code> 将字段值转换为字符串，适合与 <code>matches</code> 或 <code>contains</code> 等运算符一起使用。整数字段被转换为其十进制表示。它可以与 IP/Ethernet 地址（以及其他地址）一起使用，但不能与字符串或字节字段一起使用。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string(frame.number) matches &quot;[13579]$&quot;</span><br></pre></td></tr></table></figure>

<p>可以得到所有的序号为奇数的包。</p>
<p><code>max()</code> 和 <code>min()</code> 接受任意数量的参数并返回一个值，分别为最大/最小。参数必须都具有相同的类型。</p>
<h2 id="Protocol-field-types-协议字段类型"><a href="#Protocol-field-types-协议字段类型" class="headerlink" title="Protocol field types 协议字段类型"></a>Protocol field types 协议字段类型</h2><p>每个协议字段都有类型。类型有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ASN.1 object identifier, plain or relative</span><br><span class="line">AX.25 address</span><br><span class="line">Boolean</span><br><span class="line">Byte sequence</span><br><span class="line">Character string</span><br><span class="line">Character, 1 byte</span><br><span class="line">Date and time</span><br><span class="line">Ethernet or other MAC address</span><br><span class="line">EUI64 address</span><br><span class="line">Fibre Channel WWN</span><br><span class="line">Floating point, single or double precision</span><br><span class="line">Frame number</span><br><span class="line">Globally Unique Identifier</span><br><span class="line">IEEE-11073 floating point, 16 or 32 bits</span><br><span class="line">IPv4 address</span><br><span class="line">IPv6 address</span><br><span class="line">IPX network number</span><br><span class="line">Label</span><br><span class="line">OSI System-ID</span><br><span class="line">Protocol</span><br><span class="line">Signed integer, 1, 2, 3, 4, or 8 bytes</span><br><span class="line">Time offset</span><br><span class="line">Unsigned integer, 1, 2, 3, 4, or 8 bytes</span><br><span class="line">VINES address</span><br></pre></td></tr></table></figure>

<p>整数可以用十进制、八进制、十六进制或二进制表示法表示，也可以表示为 C 风格的字符常量。以下七个显示过滤器是等效的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame.len &gt; 10</span><br><span class="line">frame.len &gt; 012</span><br><span class="line">frame.len &gt; 0xa</span><br><span class="line">frame.len &gt; 0b1010</span><br><span class="line">frame.len &gt; &#39;\n&#39;</span><br><span class="line">frame.len &gt; &#39;\x0a&#39;</span><br><span class="line">frame.len &gt; &#39;\012&#39;</span><br></pre></td></tr></table></figure>

<p>Boolean 布尔值表示真或假。在使用布尔字段值的显示过滤器表达式中，真 表示为单词 True 或 TRUE 或任何非零数字。 假 表示为 False 或 FALSE 或数字零。例如，token-ring 数据包的 source route 字段是布尔值。要查找任何 source route 为 真 的数据包，显示过滤器将是以下任何一种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tr.sr &#x3D;&#x3D; 1</span><br><span class="line">tr.sr &#x3D;&#x3D; True</span><br><span class="line">tr.sr &#x3D;&#x3D; TRUE</span><br></pre></td></tr></table></figure>

<p>反之则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tr.sr &#x3D;&#x3D; 0</span><br><span class="line">tr.sr &#x3D;&#x3D; False</span><br><span class="line">tr.sr &#x3D;&#x3D; FALSE</span><br></pre></td></tr></table></figure>

<p>Ethernet 以太网地址和字节数组由十六进制数字表示。十六进制数字可以用冒号、句点或连字符分隔：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eth.dst eq ff:ff:ff:ff:ff:ff</span><br><span class="line">aim.data &#x3D;&#x3D; 0.1.0.d</span><br><span class="line">fddi.src &#x3D;&#x3D; aa-aa-aa-aa-aa-aa</span><br><span class="line">echo.data &#x3D;&#x3D; 7a</span><br></pre></td></tr></table></figure>

<p>IPv4 地址可以用点分十进制表示法或使用主机名表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip.src &#x3D;&#x3D; 192.168.1.1</span><br><span class="line">ip.dst eq www.mit.edu</span><br></pre></td></tr></table></figure>

<p>IPv4 地址可以用与数字相同的逻辑关系进行比较：eq、ne、gt、ge、lt 和 le。IPv4 地址按主机顺序存储，因此在显示过滤器中使用 IPv4 地址时不必担心它的字节顺序。</p>
<p>无类域间路由 (CIDR) 表示法可用于测试 IPv4 地址是否在某个子网中。例如，此显示过滤器将查找 129.111 网络中的所有数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip.addr &#x3D;&#x3D; 129.111.0.0&#x2F;16</span><br></pre></td></tr></table></figure>

<p>斜线后面的数字表示用于表示网络的位数。 CIDR 表示法也可以与主机名一起使用，例如在与 sneezy 相同的网络上查找 IP 地址的示例中（要求 sneezy 解析为 IP 地址以使过滤器有效）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip.addr eq sneezy&#x2F;24</span><br></pre></td></tr></table></figure>

<p>CIDR 表示法只能用于 IP 地址或主机名，不能用于变量名。因此，像 <code>ip.src/24 == ip.dst/24</code> 这样的显示过滤器无效。</p>
<p>Transaction 和其他 ID 通常由无符号 16 或 32 位整数表示，并格式化为带有“0x”前缀的十六进制字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(dhcp.id &#x3D;&#x3D; 0xfe089c15) || (ip.id &#x3D;&#x3D; 0x0373)</span><br></pre></td></tr></table></figure>

<p>字符串要用双引号括起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.request.method &#x3D;&#x3D; &quot;POST&quot;</span><br></pre></td></tr></table></figure>

<p>在双引号内，您可以使用反斜杠嵌入双引号或以八进制或十六进制表示的任意字节。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">browser.comment &#x3D;&#x3D; &quot;An embedded \&quot; double-quote&quot;</span><br></pre></td></tr></table></figure>

<p>使用十六进制查找 “HEAD”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.request.method &#x3D;&#x3D; &quot;\x48EAD&quot;</span><br></pre></td></tr></table></figure>

<p>使用八进制查找“HEAD”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.request.method &#x3D;&#x3D; &quot;\110EAD&quot;</span><br></pre></td></tr></table></figure>

<p>这意味着您必须在双引号内使用反斜杠转义反斜杠。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smb.path contains &quot;\\\\SERVER\\SHARE&quot;</span><br></pre></td></tr></table></figure>

<p>在 <code>smb.path</code> 中查找 ``\SERVER\SHARE`。这可以更方便地写成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smb.path contains r&quot;\\SERVER\SHARE&quot;</span><br></pre></td></tr></table></figure>

<p>以 ‘r’ 为前缀的字符串文字称为“原始字符串”。此类字符串将反斜杠视为文字字符。双引号仍然可以用反斜杠转义，但请注意反斜杠始终保留在结果中。</p>
<p>下表列出了字符串和字符常量支持的所有转义序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&#39;          single quote</span><br><span class="line">\&quot;          double quote</span><br><span class="line">\\          backslash</span><br><span class="line">\a          audible bell</span><br><span class="line">\b          backspace</span><br><span class="line">\f          form feed</span><br><span class="line">\n          line feed</span><br><span class="line">\r          carriage return</span><br><span class="line">\t          horizontal tab</span><br><span class="line">\v          vertical tab</span><br><span class="line">\NNN        arbitrary octal value</span><br><span class="line">\xNN        arbitrary hexadecimal value</span><br><span class="line">\uNNNN      Unicode codepoint U+NNNN</span><br><span class="line">\UNNNNNNNN  Unicode codepoint U+NNNNNNNN</span><br></pre></td></tr></table></figure>

<p>日期和时间值可以采用 ISO 8601 格式或使用传统的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;2020-07-04T12:34:56&quot;</span><br><span class="line">&quot;Sep 26, 2004 23:18:04.954975&quot;</span><br></pre></td></tr></table></figure>

<p>ISO 8601 中的“T”分隔符可以省略。 ISO 8601 支持时区指示符为 UTC 或与 UTC 的偏移量。传统格式可以在末尾附加值“UTC”以指定协调世界时的时间。否则，日期和时间值将被解释为本地时间。</p>
<h2 id="The-slice-operator-切片运算符"><a href="#The-slice-operator-切片运算符" class="headerlink" title="The slice operator 切片运算符"></a>The slice operator 切片运算符</h2><p>如果字段是文本字符串或字节数组，您可以获取字段的切片。例如，您可以过滤以太网地址的 vendor 部分（前三个字节），如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eth.src[0:3] &#x3D;&#x3D; 00:00:83</span><br></pre></td></tr></table></figure>

<p>另一个例子是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.content_type[0:4] &#x3D;&#x3D; &quot;text&quot;</span><br></pre></td></tr></table></figure>

<p>您也可以在协议名称上使用切片运算符。 <code>frame</code> 协议可能很有用，它包含 Wireshark 或 TShark 捕获的一个数据包的所有数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">token[0:5] ne 0.0.0.1.1</span><br><span class="line">llc[0] eq aa</span><br><span class="line">frame[100-199] contains &quot;wireshark&quot;</span><br></pre></td></tr></table></figure>

<p>以下是切片语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[i:j]    i &#x3D; start_offset, j &#x3D; length</span><br><span class="line">[i-j]    i &#x3D; start_offset, j &#x3D; end_offset, inclusive. 包含 j 指定的位置</span><br><span class="line">[i]      i &#x3D; start_offset, length &#x3D; 1</span><br><span class="line">[:j]     start_offset &#x3D; 0, length &#x3D; j</span><br><span class="line">[i:]     start_offset &#x3D; i, end_offset &#x3D; end_of_field</span><br></pre></td></tr></table></figure>

<p>Offsets 可以是负数，在这种情况下，它们表示距字段末尾的偏移量。倒数第一个字节的偏移量是 -1，倒数第二个字节的偏移量是 -2，依此类推。以下是检查帧的最后四个字节的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame[-4:4] &#x3D;&#x3D; 0.1.2.3</span><br><span class="line"></span><br><span class="line">frame[-4:] &#x3D;&#x3D; 0.1.2.3</span><br></pre></td></tr></table></figure>

<p>切片可以与字符串或字节序列进行比较。上面 <code>0.1.2.3</code> 是字节序列的一种十六进制表示方法，还可以等价写为 <code>0:1:2:3</code> <code>0-1-2-3</code>。</p>
<p>切片可以组合。您可以使用逗号运算符连接它们：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ftp[1,3-5,9:] &#x3D;&#x3D; 01:03:04:05:09:0a:0b</span><br></pre></td></tr></table></figure>

<p>这会将偏移量 1、偏移量 3-5 和偏移量 9 到末尾 的数据连接在一起。</p>
<h2 id="The-layer-operator-层运算符"><a href="#The-layer-operator-层运算符" class="headerlink" title="The layer operator 层运算符"></a>The layer operator 层运算符</h2><p>可以使用层运算符 (#) 将字段限制到协议栈中的某个层，后跟一个十进制数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip.addr#2 &#x3D;&#x3D; 192.168.30.40</span><br></pre></td></tr></table></figure>

<p>仅匹配数据包中的内（第二）层。层使用简单的堆叠语义，协议层从 1 开始顺序计数。例如，在包含两个 IPv4 标头的数据包中，外部（第一层）源地址可以与“ip.src#1”匹配，内部（第二层）源地址可以匹配“ip.src#2”。</p>
<p>对于更复杂的范围，切片的语法是有效的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp.port#[2-4]</span><br></pre></td></tr></table></figure>

<p>表示第 2、3 或 4 层（含）。注意需要使用中括号。</p>
<h2 id="The-membership-operator-成员关系运算符"><a href="#The-membership-operator-成员关系运算符" class="headerlink" title="The membership operator 成员关系运算符"></a>The membership operator 成员关系运算符</h2><p>可以简单地使用 in 运算符检查字段是在一组值中。例如，您可能会使用以下过滤器在常见的 HTTP/HTTPS 端口上找到流量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp.port in &#123;80,443,8080&#125;</span><br></pre></td></tr></table></figure>

<p>而不是使用更冗长的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp.port &#x3D;&#x3D; 80 or tcp.port &#x3D;&#x3D; 443 or tcp.port &#x3D;&#x3D; 8080</span><br></pre></td></tr></table></figure>

<p>查找 HEAD 或 GET 方法的 HTTP 请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.request.method in &#123;&quot;HEAD&quot;, &quot;GET&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>值集还可以包含范围：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp.port in &#123;443, 4430..4434&#125;</span><br><span class="line">ip.addr in &#123;10.0.0.5 .. 10.0.0.9, 192.168.1.1..192.168.1.9&#125;</span><br><span class="line">frame.time_delta in &#123;10 .. 10.5&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Implicit-type-conversions-隐式类型转换"><a href="#Implicit-type-conversions-隐式类型转换" class="headerlink" title="Implicit type conversions 隐式类型转换"></a>Implicit type conversions 隐式类型转换</h2><p>作为字节序列的字段（包括协议）被隐式转换为字符串，以便与（双引号）文字字符串和原始字符串进行比较。</p>
<p>因此，例如，以下过滤器是等效的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp.payload contains &quot;GET&quot;</span><br><span class="line">tcp.payload contains 47.45.54</span><br></pre></td></tr></table></figure>

<p>如上所述，切片也可以通过任何一种方式进行比较：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame[60:2] gt 50.51</span><br><span class="line">frame[60:2] gt &quot;PQ&quot;</span><br></pre></td></tr></table></figure>

<p>不会发生相反的情况；类字符串字段不会隐式转换为字节数组。（一些运算符允许将类字符串的字段与不带引号的文字进行比较，然后将其视为字符串；这通常不推荐使用，并且 matches 运算符特别不允许。为清楚起见，文字字符串应使用双引号。）</p>
<p>0xff 或更小的十六进制整数（这意味着它适合一个字节）可以隐式转换为字节字符串。这对于大于一个字节的十六进制整数是不允许的，因为这样需要指定多字节整数的字节顺序（端序）。此外，十进制或八进制数也不允许这样做，因为它们会与构成字节字符串文字的十六进制数字混淆。然而，单字节十六进制整数可能很方便：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame[4] &#x3D;&#x3D; 0xff</span><br><span class="line">frame[1:4] contains 0x02</span><br></pre></td></tr></table></figure>


<h2 id="Bitwise-operators-位运算符"><a href="#Bitwise-operators-位运算符" class="headerlink" title="Bitwise operators 位运算符"></a>Bitwise operators 位运算符</h2><p>也可以使用按位运算定义测试。目前支持以下位运算符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitwise_and, &amp;    Bitwise AND</span><br></pre></td></tr></table></figure>

<p>按位 AND 运算允许屏蔽位并测试是否设置了一个或多个位。按位 AND 对整数协议字段和切片进行操作。</p>
<p>在测试 TCP SYN 数据包时，您可以编写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp.flags &amp; 0x02</span><br></pre></td></tr></table></figure>

<p>该表达式将匹配所有包含 <code>tcp.flags</code> 字段且设置了 <code>0x02</code> 位（即 SYN 位）的数据包。</p>
<p>要匹配本地管理的单播以太网地址，您可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eth.addr[0] &amp; 0x0f &#x3D;&#x3D; 2</span><br></pre></td></tr></table></figure>

<p>使用切片时，位掩码必须指定为字节字符串，并且它必须具有与切片本身相同的字节数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip[42:2] &amp; 40:ff</span><br></pre></td></tr></table></figure>


<h2 id="Arithmetic-operators-算术运算符"><a href="#Arithmetic-operators-算术运算符" class="headerlink" title="Arithmetic operators 算术运算符"></a>Arithmetic operators 算术运算符</h2><p>通常的运算符术表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+   Addition</span><br><span class="line">-   Subtraction</span><br><span class="line">*   Multiplication</span><br><span class="line">&#x2F;   Division</span><br><span class="line">%   Modulo (integer remainder)</span><br></pre></td></tr></table></figure>

<p>例如，可以使用如下表达式过滤大于或等于源端口加 1 的 UDP 目标端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">udp.dstport &gt;&#x3D; udp.srcport + 1</span><br></pre></td></tr></table></figure>

<p>可以使用大括号对算术表达式进行分组（注意！！括号不适用于此）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp.dstport &gt;&#x3D; 4 * &#123;tcp.srcport + 3&#125;</span><br></pre></td></tr></table></figure>

<p>不要将大括号的这种用法与集合成员资格混淆。</p>
<p>注意！！过滤器语法中的一个不幸的怪癖是减法运算符必须以空格字符开头，因此 <code>A-B</code> 必须写为 <code>A -B</code> 或 <code>A - B</code>。</p>
<h2 id="Protocol-field-references-协议字段引用"><a href="#Protocol-field-references-协议字段引用" class="headerlink" title="Protocol field references 协议字段引用"></a>Protocol field references 协议字段引用</h2><p>使用 <code>$&#123;some.proto.field&#125;</code> 形式的变量称为字段引用。字段引用是从 GUI 中当前选定的帧中读取的字段值。这对于构建动态过滤器很有用，例如从最后五分钟到所选帧的帧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame.time_relative &gt;&#x3D; $&#123;frame.time_relative&#125; - 300</span><br></pre></td></tr></table></figure>

<p>字段引用与宏共享类似的符号，但在过滤器语言中是不同的语法元素。</p>
<h2 id="Logical-expressions-逻辑表达式"><a href="#Logical-expressions-逻辑表达式" class="headerlink" title="Logical expressions 逻辑表达式"></a>Logical expressions 逻辑表达式</h2><p>可以使用逻辑表达式组合测试。这些也可以用类似 C 的语法或类似英语的缩写来表达。下表列出了从最高到最低优先级的逻辑运算符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">not, !    Logical NOT   (right-associative)</span><br><span class="line">and, &amp;&amp;   Logical AND   (left-associative)</span><br><span class="line">or,  ||   Logical OR    (left-associative)</span><br></pre></td></tr></table></figure>

<p>计算总是从左到右进行。表达式也可以按括号分组。表达式 <code>A and B or not C or D and not E or F</code> 被解释为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(A and B) or (not C) or (D and (not E)) or F</span><br></pre></td></tr></table></figure>

<p>通常最好明确地使用括号进行分组。以下都是有效的显示过滤器表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp.port &#x3D;&#x3D; 80 and ip.src &#x3D;&#x3D; 192.168.2.1</span><br><span class="line">not llc</span><br><span class="line">http and frame[100-199] contains &quot;wireshark&quot;</span><br><span class="line">(ipx.src.net &#x3D;&#x3D; 0xbad &amp;&amp; ipx.src.node &#x3D;&#x3D; 0.0.0.0.0.1) || ip</span><br></pre></td></tr></table></figure>

<p>请记住，每当表达式中出现协议或字段名称时，都会隐式调用 <code>exists</code> 运算符。 <code>exists</code> 运算符具有最高优先级。这意味着第一个过滤器表达式必须被读作“显示 tcp.port 存在且等于 80 且 ip.src 存在且等于 192.168.2.1 的数据包”。第二个过滤器表达式的意思是“显示不存在 llc 的数据包”，因此将匹配所有不包含 llc 协议的数据包。第三个过滤器表达式包含偏移量 199 必须存在的约束，也就是说帧长度最少也是 200。</p>
<p>每个 比较 对任何字段值都有一个隐式 存在 测试。使用显示过滤器从数据包列表中去除不需要的数据包时必须小心。例如，你想过滤掉所有发送到 224.1.2.3 地址的 IP 组播数据包，使用如下表达式可能过于严格：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip.dst ne 224.1.2.3</span><br></pre></td></tr></table></figure>

<p>这和下面的写法一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip.dst and ip.dst ne 224.1.2.3</span><br></pre></td></tr></table></figure>

<p>过滤器仅选择具有 <code>ip.dst</code> 字段的帧。不会显示任何其他帧，包括所有非 IP 数据包。要同时显示非 IP 数据包，您可以使用以下两个表达式之一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">not ip.dst or ip.dst ne 224.1.2.3</span><br><span class="line">not ip.dst eq 224.1.2.3</span><br></pre></td></tr></table></figure>

<p>第一个过滤器使用 <code>not ip.dst</code> 来包含所有非 IP 数据包，然后让 <code>ip.dst ne 224.1.2.3</code> 过滤掉不需要的 IP 数据包。第二个过滤器也否定隐式存在测试，因此是第一个过滤器更短的方法。</p>
<h1 id="FILTER-FIELD-REFERENCE-过滤器字段参考"><a href="#FILTER-FIELD-REFERENCE-过滤器字段参考" class="headerlink" title="FILTER FIELD REFERENCE 过滤器字段参考"></a>FILTER FIELD REFERENCE 过滤器字段参考</h1><p>显示过滤器的整个列表太大，无法在此处列出。您可以在以下位置找到参考资料和示例：</p>
<ul>
<li>在线显示过滤器参考：<a href="https://www.wireshark.org/docs/dfref/">https://www.wireshark.org/docs/dfref/</a></li>
<li>View:Internals:Supported Protocols in Wireshark</li>
<li>tshark -G fields on the command line</li>
<li>The Wireshark wiki: <a href="https://gitlab.com/wireshark/wireshark/-/wikis/DisplayFilters">https://gitlab.com/wireshark/wireshark/-/wikis/DisplayFilters</a></li>
</ul>
<h1 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h1><p>The wireshark-filter(4) manpage is part of the Wireshark distribution. The latest version of Wireshark can be found at <a href="https://www.wireshark.org/">https://www.wireshark.org</a>.</p>
<p>Regular expressions in the “matches” operator are provided by the PCRE2 library. See <a href="https://www.pcre.org/">https://www.pcre.org/</a> for more information.</p>
<p>This manpage does not describe the capture filter syntax, which is different. See the manual page of <a href="https://www.tcpdump.org/manpages/pcap-filter.7.html">pcap-filter(7)</a> or, if that doesn’t exist, <a href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump(8)</a>, or, if that doesn’t exist, <a href="https://gitlab.com/wireshark/wireshark/-/wikis/CaptureFilters">https://gitlab.com/wireshark/wireshark/-/wikis/CaptureFilters</a> for a description of capture filters.</p>
<p>Display Filters are also described in the User’s Guide: <a href="https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html">https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html</a></p>
<h1 id="SEE-ALSO"><a href="#SEE-ALSO" class="headerlink" title="SEE ALSO"></a>SEE ALSO</h1><p>wireshark(1), tshark(1), editcap(1), pcap(3), pcap-filter(7) or tcpdump(8) if it doesn’t exist.</p>
<h1 id="AUTHORS"><a href="#AUTHORS" class="headerlink" title="AUTHORS"></a>AUTHORS</h1><p>See the list of authors in the Wireshark man page for a list of authors of that code.</p>
]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper 小记</title>
    <url>/2019/12/04/zookeeper-%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="zookeeper-崩溃恢复过程中两个关键性问题"><a href="#zookeeper-崩溃恢复过程中两个关键性问题" class="headerlink" title="zookeeper 崩溃恢复过程中两个关键性问题"></a>zookeeper 崩溃恢复过程中两个关键性问题</h1><p>Q1：leader 提交事务 A 后崩溃，follower 没有收到提交事务 A 的消息，再次选举 leader 时如何确保事务 A 被应用？</p>
<p>A1：既然 leader 已经在本地提交了事务 A，那么说明事务 A 肯定已经经过了多数 follower 的确认，即多数 follower 上都有事务 A 的记录，leader 崩溃后，重新选举出的新 leader 肯定包含未提交的事务 A，因为事务 A 的事务 ID 最大，新 leader 会继续提交事务 A。</p>
<hr>
<p>Q2：leader 在还未将事务 B 广播到集群中时崩溃，在重新选举 leader 并在旧 leader 恢复正常后如何处理事务 B？</p>
<p>A2：事务 B 将会被删除，不会被提交。leader 在接收到一个请求，并将其转化为事务 B 后崩溃，此时还没有将事务 B 广播到集群中，即此事务只存在于 leader 机器上，经过新一轮的 leader 选举后，旧 leader 恢复正常并加入集群，此时会发现事务 B 的事务 ID 所使用的 epoch 号与新 leader 的对不上，那么事务 B 就会被删除。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>把握好 zookeeper 的主要特性就可以将其应用在多种多样的场景下。主要特性如下：</p>
<ul>
<li>节点<ul>
<li>树结构</li>
<li>持久节点</li>
<li>持久顺序节点</li>
<li>临时节点</li>
<li>临时顺序节点</li>
<li>节点只能被注册一次</li>
</ul>
</li>
<li>watcher</li>
</ul>
<p>在《从 Paxos 到 Zookeeper》一书中提到的应用场景以及我认为场景所应用到的主要特性如下：</p>
<ul>
<li>数据发布/订阅（配置中心）<ul>
<li>watcher</li>
</ul>
</li>
<li>DNS 服务负载均衡<ul>
<li>树结构</li>
<li>watcher</li>
</ul>
</li>
<li>命名服务<ul>
<li>持久顺序节点</li>
</ul>
</li>
<li>分布式协调/通知<ul>
<li>临时节点</li>
<li>临时顺序节点</li>
<li>watcher</li>
</ul>
</li>
<li>集群管理<ul>
<li>临时节点</li>
<li>watcher</li>
</ul>
</li>
<li>Master 选举<ul>
<li>节点只能被注册一次</li>
<li>watcher</li>
</ul>
</li>
<li>分布式锁<ul>
<li>节点只能被注册一次（排他锁/写锁/独占锁）</li>
<li>临时顺序节点（共享锁/读锁）</li>
<li>watcher</li>
</ul>
</li>
<li>分布式队列<ul>
<li>临时顺序节点</li>
<li>watcher</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>一些关于Fragment的笔记</title>
    <url>/2016/05/04/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8EFragment%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>注意:<br>android3.0以及之后的版本支持fragment技术，低版本要想使用fragment技术需要android.support.v4.app包<br>获取fragmentManager的方法不同：<br>3.0以下：getSupportFragmentManager()<br>3.0以上：getFragmentManager()</p>
</blockquote>
<h1 id="fragment以及activity生命周期"><a href="#fragment以及activity生命周期" class="headerlink" title="fragment以及activity生命周期"></a>fragment以及activity生命周期</h1><p>附上图片一张:<br><img src="fragment-activity.jpg" alt="fragment-activity"></p>
<h1 id="学习fragment时碰到的几个名词："><a href="#学习fragment时碰到的几个名词：" class="headerlink" title="学习fragment时碰到的几个名词："></a>学习fragment时碰到的几个名词：</h1><h2 id="FragmentActivity："><a href="#FragmentActivity：" class="headerlink" title="FragmentActivity："></a>FragmentActivity：</h2><p>一个android.support.v4.app中的一个继承了Activity的类，如果你要在3.0以下使用fragment就需要让页面继承FragmentActivity而不是Activity，FragmentActivity中包含了3.0以下操作fragment的方法，使用方法同3.0以上一样，只是获取Manager的方法不同</p>
<h2 id="FragmentPagerAdapter"><a href="#FragmentPagerAdapter" class="headerlink" title="FragmentPagerAdapter"></a>FragmentPagerAdapter</h2><p>可以作为ViewPager的适配器</p>
<h2 id="ListFragment"><a href="#ListFragment" class="headerlink" title="ListFragment"></a>ListFragment</h2><p>列表样式， 自带一个默认的包含ListView控件的布局文件，无需手动重写onCreateView()使用inflat()方法加载自定义布局文件，只需要重写onCreate()方法，在其中用setListAdapter()方法绑定适配器，在绑定适配器的时候给item设置一个布局文件就行了。<br>若想修改ListView，可以在onCreateView(LayoutInflater, ViewGroup, Bundle)中进行修改，需要注意在自定义的ListFragment对应的布局文件中，必须指定一个 android:id 为 “@android:id/list” 的ListView控件!<br>当然，用户也可以在ListFragment对应的布局中包含其它的控件。<br>显示：在主activity中使用new关键字获取对象的引用</p>
<h2 id="DialogFragment"><a href="#DialogFragment" class="headerlink" title="DialogFragment"></a>DialogFragment</h2><p>Android官方推荐使用DialogFragment创建对话框，可以避免屏幕旋转导致的问题。<br>重写onCreateView()则用定义的xml布局文件展示Dialog或者重写onCreateDialog()则需要利用AlertDialog或者Dialog创建出Dialog，在主activity中使用DialogFragment对象的show()方法，显示对话框。<br>显示：在主activity中使用new关键字获取对象的引用</p>
<h2 id="FragmentTabHost"><a href="#FragmentTabHost" class="headerlink" title="FragmentTabHost"></a>FragmentTabHost</h2><p>用来代替已废弃的TabHost，个人感觉和前两个ListFragment以及DialogFragment有些不同，你可以把FragmentTabHost看作是一个普通控件正常使用，也就是个TabHost使用方法一样。<br>需要主页面的布局文件中添加控件，然后通过findViewById()来获取控件，需要注意的是布局文件中控件使用的标记名称是<code>&lt;android.support.v4.app.FragmentTabHost&gt;</code>，id：<code>@android:id/tabhost</code>(id可以随便写)<br>需要包含三个子标记<font color=red>(经过测试，只用一个id：tabhost(也就是上面那个控件)和一个id：realtabconten也可以(真正的容器FrameLayout)</font>：<br>1、Tab标签容器TabWidget，id：<code>@android:id/tabs</code>(id必须是这个)<br>2、Tab内容容器FrameLayout，id：<code>@android:id/tabcontent</code>(id必须是这个)，注意：这里属性中宽高皆为0dp<br>3、Tab内容容器FrameLayout，id：<code>@+id/RealTabContent</code>(id可以随便写)，注意：这个才是真正的内容容器</p>
<p>FragmentTabHost可以在布局文件中定义标签容器在内容容器的下面，调动RealTabContent的位置到tabhost的上面就行了，此时RealTabContent的属性最好是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:id&#x3D;&quot;@+id&#x2F;RealTabContent&quot;</span><br><span class="line">android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">android:layout_height&#x3D;&quot;0dp&quot;</span><br><span class="line">android:layout_weight&#x3D;&quot;1&quot;</span><br></pre></td></tr></table></figure>
<p>相关链接：<a href="http://blog.csdn.net/wklbeta/article/details/11329207">《关于FragmentTabHost中TabWidget不能移到屏幕下面的Bug》</a></p>
<p>然后，在主activity中使用findViewById()获取控件后，必须先使用使用控件对象的setup()方法之后才能用addTab()方法来添加标签，这点和TabHost一样，不过使用的具体方法有区别，FragmentTabHost应该用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setup():</span></span><br><span class="line">setup(Context context, FragmentManager manager, <span class="keyword">int</span> containerId)</span><br><span class="line"><span class="comment">//参数解释：</span></span><br><span class="line"><span class="comment">//context：上下文</span></span><br><span class="line"><span class="comment">//manager：使用getSupportFragmentManager()</span></span><br><span class="line"><span class="comment">//containerId:容器id</span></span><br><span class="line"><span class="comment">//×××××××××××××××××××××××××××××××××××××××××</span></span><br><span class="line"><span class="comment">//add()</span></span><br><span class="line">addTab(TabSpec arg0, Class&lt;?&gt; arg1, Bundle arg2)</span><br><span class="line"><span class="comment">//参数解释：</span></span><br><span class="line"><span class="comment">//arg0：FragmentTabHost对象的newTabSpec()方法获取，并且需要使用获取到的TabSpec对象的setIndicator()方法设置标题属性</span></span><br><span class="line"><span class="comment">//arg1：具体的fragment类(不是new出来的)</span></span><br><span class="line"><span class="comment">//arg2：null即可</span></span><br></pre></td></tr></table></figure>
<p>详细的FragmentHostTab与HostTab之间的区别请看：<a href="http://blog.csdn.net/listener_ri/article/details/46935601">TabHost 和 FragmentTabHost </a></p>
<h1 id="笼统的Fragment的使用："><a href="#笼统的Fragment的使用：" class="headerlink" title="笼统的Fragment的使用："></a>笼统的Fragment的使用：</h1><blockquote>
<p>只是单纯的Fragment，不含：ListFragment，DialogFragment，FragmentTabHost等，不过基本一样</p>
</blockquote>
<h2 id="fragment继承类和其布局文件"><a href="#fragment继承类和其布局文件" class="headerlink" title="fragment继承类和其布局文件"></a>fragment继承类和其布局文件</h2><p>一个fragment由一个布局文件和一个继承了fragment的子类组成，由这个子类处理布局文件产生的的各种事件</p>
<p>使用时需要让子类关联到其布局文件，关联方法：<br>1、重写fragment类的onCreateView()生命周期方法，<br>2、然后在onCreateView()中调用方法的传入参数inflater的inflate()方法并返回获得的View对象来加载对应的布局文件</p>
<p>当fragment继承类和其布局文件关联后就可以显示到页面上了，显示方法：<br><font color=red>注意：并不是直接把fragment的布局文件或其中的控件显示到页面上</font><br>而是在主页面的布局文件中使用fragment标记，要注意标记的android:name属性，由这个属性的值关联到fragment继承类，进而通过fragment继承类加载到相应的fragment布局文件</p>
<h2 id="具体显示到页面上有两种方式："><a href="#具体显示到页面上有两种方式：" class="headerlink" title="具体显示到页面上有两种方式："></a>具体显示到页面上有两种方式：</h2><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p>也就是直接把一个或多个fragment显示到页面上，这样做就相当与把一个fragment看作是一个普通控件(由一个或多个控件组成的控件)来添加到页面上<br>只不过这个“控件“(fragment)产生的事件由对应的继承了fragment的类处理，<br>而不是像平时那样在主页面中为某个控件findViewById然后添加监听器，这一步写在了继承了fragment的类中</p>
<p>具体步骤：<br>1、fragment的布局文件，就像平时的布局文件一样<br>2、继承了fragment的类，重写fragment类的onCreateView()生命周期方法，<br>在onCreateView()中调用方法的传入参数inflater的inflate()方法并返回获得的View对象来加载对应的布局文件<br>3、主页面布局文件中依次写入需要显示的fragment标记，通过标记的name属性关联到继承了fragment的类</p>
<h3 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h3><p>动态的意思就是可以在不切换activity的前提下，通过某个点击事件，在同一个区域显示不同的fragment<br>要实现这个效果，需要一个FragmentManager管理类和一个FragmentTransaction事务类，还需要一个承载不同fragment的容器，一般是在主页面中使用一个FrameLayout帧布局来充当这个容器，<br>也就是让一个个fragment在FrameLayout中显示，<font color=red>但不需要在FrameLayout内写fragment子标记</font><br>如何切换不同的fragment的方法由事务类操作实现</p>
<p>具体步骤：<br>前两步与静态一样，写几个fragment的布局文件和类并一一对应的关联起来<br>3、在主页面的布局文件中，需要动态显示fragment的地方，放一个FrameLayout帧布局<br>4、在主页面的activity类中，通过getFragmentManager()方法获取到FragmentManager<br>并通过FragmentManager的beginTransaction()开始并获取到一个事务FragmentTransaction<br>5、通过获取到的FragmentTransaction对象的就可以控制fragment显示显示或隐藏到FrameLayout帧布局</p>
<p>部分控制方法有：<br>add(),hide(),remove(),replace(),show()等，这些方法都需要fragment对象，也就是要显示的fragment<br>通过addToBackStack()方法可以将当前fragment添加到FragmentManager的回退栈，当点击返回键时可以恢复状态<br>当操作完成后还必须使用commit()方法提交，提交之后才会真正生效</p>
<blockquote>
<p>总结：<br>个人表示刚接触fragment，不容易懂或者说不容易记的地方是fragment的类和对应的布局文件的关联，以及如何显示到页面</p>
</blockquote>
<blockquote>
<p>大概记忆顺序(中间的连接符可以理解为关联、对应)：<br><strong>静态：</strong><font color=red>一个</font>主页面布局文件中的<code>&lt;fragment&gt;</code>标记——<font color=red>一个</font>fragment的继承类——<font color=red>一个</font>fragment布局文件<br><strong>动态：</strong><font color=red>一个</font>主页面布局文件中的<code>&lt;FrameLayout&gt;</code>标记——<font color=red>承载多个</font>fragment的继承类——<font color=red>各自对应的多个</font>fragment布局文件</p>
<p>虽然理解时的顺序是这样的，但实际写代码的时候的顺序确实反过来的</p>
</blockquote>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>FragmentPagerAdapter</tag>
        <tag>fragment</tag>
        <tag>FragmentActivity</tag>
        <tag>ListFragment</tag>
        <tag>DialogFragment</tag>
        <tag>FragmentTabHost</tag>
      </tags>
  </entry>
  <entry>
    <title>不通过GooglePlay下载其中的app</title>
    <url>/2016/05/04/%E4%B8%8D%E9%80%9A%E8%BF%87GooglePlay%E4%B8%8B%E8%BD%BD%E5%85%B6%E4%B8%AD%E7%9A%84app/</url>
    <content><![CDATA[<p>非常简单的一个方法：<a href="http://apps.evozi.com/apk-downloader/">飞机直达</a><br>进入上面的网址,如果你进不去,那就想想自己为什么进不了google,<br>里面就一个输入框,把Google play里你想下的apk的网页链接填进去<br>点下面的按钮,马上就出来一个绿色按钮,点击即可直接用浏览器下载这个apk</p>
<p>转自：<a href="http://daxiaamu.com/">大侠阿木</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>GooglePlay</tag>
      </tags>
  </entry>
  <entry>
    <title>为自己的网站启用 https</title>
    <url>/2019/10/28/%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99%E5%90%AF%E7%94%A8-https/</url>
    <content><![CDATA[<p>使用 let’s encrypt 证书颁发机构的免费证书，如果想看官方的文档访问下面的链接，官方文档提供了各种方案来启用 https，我使用是推荐的 Certbot 方案。</p>
<p><a href="https://letsencrypt.org/zh-cn/getting-started/">https://letsencrypt.org/zh-cn/getting-started/</a></p>
<p>本文摘自的 Certbot 官网的针对 Ubuntu+Nginx 方案的教程，原文链接如下。</p>
<p><a href="https://certbot.eff.org/lets-encrypt/ubuntuxenial-nginx">https://certbot.eff.org/lets-encrypt/ubuntuxenial-nginx</a></p>
<p>如果你的系统不是 Ubuntu 16.04 或者使用的 web 服务不是 nginx 可以去下面的链接重新选择教程。</p>
<p><a href="https://certbot.eff.org/">https://certbot.eff.org</a></p>
<p>正文开始：</p>
<p>使用 ssh 或任何方法登陆到运行 web 服务的服务器，注意账户需要有 root 权限。</p>
<p>使用下面的命令添加 Certbot PPA 到系统中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository universe</span><br><span class="line">sudo add-apt-repository ppa:certbot&#x2F;certbot</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>使用如下命令安装 Certbot：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install certbot python-certbot-nginx</span><br></pre></td></tr></table></figure>

<p>执行如下命令开始一步步安装证书修改 nginx 配置文件，这些都是脚步化自动化的，只需要作出几个选择即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo certbot --nginx</span><br></pre></td></tr></table></figure>

<p>安装步骤很简单，虽说是英文但没什么阅读难度，而且会自动安装 crontab 定期任务，这样就不用考虑证书过期的问题了。</p>
<p>需要注意的是，如果你像我一样有个顶级域名，并且想要只使用这个顶级域名，即把所有对 <a href="http://www.listenerri.com/">www.listenerri.com</a> 域名的访问全部重定向到 listenerri.com，那么 nginx 配置文件就需要包含这两个域名的 server 节配置，在两个 server 节配置中分别使用 server_name 指定两个域名，否则 certbot 脚本只显示一个域名供选择。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>certbot</tag>
        <tag>lets-encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>从arraylist生成String[]数组</title>
    <url>/2016/05/04/%E4%BB%8Earraylist%E7%94%9F%E6%88%90String-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>在使用数组的时候要留意,一定要先完整的创建好数组,再对其操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] commands=<span class="keyword">null</span>;</span><br><span class="line">commands = <span class="keyword">new</span> String[arrayListCommand.size()];</span><br><span class="line">commands = (String[]) arrayListCommand.toArray(commands);</span><br><span class="line"><span class="comment">//可以成功cast到String数组</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] commands=<span class="keyword">null</span>;</span><br><span class="line">commands = (String[]) arrayListCommand.toArray();</span><br><span class="line"><span class="comment">//不能cast到String数组</span></span><br><span class="line"><span class="comment">//这是因为第一句只是声明了commands变量,</span></span><br><span class="line"><span class="comment">//此时它并没有在内存获得存储数据的位置,</span></span><br><span class="line"><span class="comment">//因此无法直接为其赋值</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>toArray</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 quilt 给软件包打补丁</title>
    <url>/2019/03/16/%E4%BD%BF%E7%94%A8-quilt-%E7%BB%99%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%89%93%E8%A1%A5%E4%B8%81/</url>
    <content><![CDATA[<p>quilt 是一个管理补丁的工具，它使用了栈的概念来管理多个补丁，其管理的补丁一般被放在 <strong>patches</strong> 目录下，在这个目录下除了补丁文件还有一个 <strong>series</strong> 文件，这个文件中列出的补丁文件才是真正被打入项目的补丁文件，同时补丁文件在 series 文件中出现的顺序也是它们在栈中的顺序，没有包含在 series 文件中的补丁文件将不会被 quilt 管理，当新增或移除补丁时 quilt 会自动更新 series 文件不需要手动管理。</p>
<p>接触到这个命令是因为要给一个 deb 软件包打上我自己的补丁，但是 quilt 命令的 man 手册比较混乱，没有将相关的子命令放在一起进行介绍，下面将根据子命令之间的相关性总结下用到的和与之相关的子命令。</p>
<h2 id="applied-unapplied"><a href="#applied-unapplied" class="headerlink" title="applied-unapplied"></a>applied-unapplied</h2><ul>
<li>applied：列出包含在 series 文件中且已经应用（生效）了的补丁</li>
<li>unapplied：列出包含在 series 文件中但没有应用（生效）的补丁</li>
</ul>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>指定一个被打过补丁的项目文件并根据其变动生成一个 diff 文件，如果指定了补丁则只把指定补丁对项目文件的改动生成到 diff 文件，当同一个项目文件被多个补丁改动过，这个参数就有用了，如果不指定补丁则默认使用最顶层的补丁，如果被打过补丁的项目文件也没有指定，则将包含指定补丁或最顶层的补丁导致的所有项目文件变动。</p>
<h2 id="files"><a href="#files" class="headerlink" title="files"></a>files</h2><p>列出最顶层的一个或指定的补丁改动了的所有项目文件</p>
<h2 id="patches"><a href="#patches" class="headerlink" title="patches"></a>patches</h2><p>列出所有改动了指定的项目文件的补丁</p>
<h2 id="pop-push"><a href="#pop-push" class="headerlink" title="pop-push"></a>pop-push</h2><ul>
<li>pop：从栈中移除一个或多个已经生效了的补丁，不会修改 series 文件（使补丁不生效）</li>
<li>push：根据 series 文件应用一个或多个补丁，不会修改 series 文件（使补丁生效）</li>
</ul>
<h2 id="import-delete"><a href="#import-delete" class="headerlink" title="import-delete"></a>import-delete</h2><ul>
<li>import：将指定的补丁文件导入到项目的补丁系统中，会修改 series 文件，同时将指定的补丁文件复制到 patches 目录下，但不会将这个补丁应用，因此还需要执行 push 命令来让这个补丁生效</li>
<li>delete：从 series 文件中移除指定或最后一行的补丁文件，会修改 series 文件，也可一起将补丁文件从 patches 目录中删除（默认不会删除），在移除前将取消这个补丁的应用，类似执行 pop 命令</li>
</ul>
<h2 id="add-remove"><a href="#add-remove" class="headerlink" title="add-remove"></a>add-remove</h2><ul>
<li>add：将指定的项目文件添加到指定的或顶层的补丁中，一般是为了要使用下面的 edit 命令修改这个文件</li>
<li>remove：从指定的或最顶层的补丁中移除指定的项目文件，大概是当一个补丁修改了多个文件时，移除一个指定的文件不让这个补丁修改</li>
</ul>
<h2 id="fork-edit-refresh"><a href="#fork-edit-refresh" class="headerlink" title="fork-edit-refresh"></a>fork-edit-refresh</h2><ul>
<li>fork：使用指定的名字复制一个补丁，并使用复制后的补丁覆盖 series 文件中旧的补丁</li>
<li>edit：编辑指定的项目文件，这个项目文件应该先被使用 add 命令添加到当前补丁中</li>
<li>refresh：更新指定的或顶层的补丁</li>
</ul>
<p>fork 通常用于一个补丁应用后又需要被修改，但这个补丁又需要保留这原始内容，这种情况下就可以先复制出来一个副本，然后修改这个副本</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>quilt</tag>
        <tag>patch</tag>
        <tag>deb</tag>
      </tags>
  </entry>
  <entry>
    <title>使用XMLReader接口解析XML</title>
    <url>/2016/05/04/%E4%BD%BF%E7%94%A8XMLReader%E6%8E%A5%E5%8F%A3%E8%A7%A3%E6%9E%90XML/</url>
    <content><![CDATA[<h1 id="如何获取XMLReader接口"><a href="#如何获取XMLReader接口" class="headerlink" title="如何获取XMLReader接口"></a>如何获取XMLReader接口</h1><p>从JDK文档来看，有两种方法：</p>
<h2 id="使用SAXParserFactory-SAXParser-以下简称a方法"><a href="#使用SAXParserFactory-SAXParser-以下简称a方法" class="headerlink" title="使用SAXParserFactory+SAXParser[以下简称a方法]"></a>使用SAXParserFactory+SAXParser<code>[以下简称a方法]</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XMLReader aaa=SAXParserFactory.newInstance().newSAXParser().getXMLReader();</span><br></pre></td></tr></table></figure>

<h2 id="使用XMLReaderFactory-以下简称b方法"><a href="#使用XMLReaderFactory-以下简称b方法" class="headerlink" title="使用XMLReaderFactory[以下简称b方法]"></a>使用XMLReaderFactory<code>[以下简称b方法]</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XMLReader bbb=XMLReaderFactory.createXMLReader();</span><br></pre></td></tr></table></figure>

<h1 id="两种方法不同之处"><a href="#两种方法不同之处" class="headerlink" title="两种方法不同之处"></a>两种方法不同之处</h1><p>在JDK文档a方法中SAXParser类的getXMLReader()方法的注释:</p>
<blockquote>
<p>返回由<font color=red><strong>此类的实现封装</strong></font>的 XMLReader。</p>
</blockquote>
<p>SAXParser类又是由SAXParserFactory的newSAXParser()方法创建而来，其注释：</p>
<blockquote>
<p>使用当前配置的工厂参数创建 SAXParser 的一个新实例。</p>
</blockquote>
<p>而在JDK文档中b方法使用XMLReaderFactory类的createXMLReader()方法有这样一段注释：</p>
<blockquote>
<p>尝试从<font color=red><strong>系统默认值</strong></font>创建一个 XMLReader。</p>
</blockquote>
<p>可以发现，想要获取XMLReader，是需要环境支持的(能力有限，无法分析出具体是哪些环境，相询JDK文档的XMLReaderFactory类)，<br>在a方法中则是从由SAXParserFactory+SAXParser设置好的环境中创建XMLReader，其中主要环境设置工作由SAXParserFactory来做。<br>而在b方法中会直接使用系统默认的环境，但这个环境却不一定可以正常使用，除非你手动设置其创建环境(笔者表示还不会)</p>
<h1 id="SAXParserFactory和SAXParser两个抽象类主要作用"><a href="#SAXParserFactory和SAXParser两个抽象类主要作用" class="headerlink" title="SAXParserFactory和SAXParser两个抽象类主要作用"></a>SAXParserFactory和SAXParser两个抽象类主要作用</h1><p>a方法中的SAXParserFactory在笔者看来，起主要作用应该就是根据当前系统环境，<br>设置一个可以正常创建出XMLReader解析器的环境，并提供创建SAXParser类对象的方法。<br>SAXParser的主要作用应该是根据SAXParserFactory工厂类提供的环境来创建XMLReader解析器，<br>并且它还有一些重要的作用：</p>
<blockquote>
<p>获取SAXParser类的实例之后，将可以从<font color=red><strong>各种输入源</strong></font>解析 XML。这些输入源为 InputStream、File、URL 和 SAX InputSource。<br>它包含一系列的parse(<em>,</em>)方法<br>也即是说SAXParser还定义了将各种源解析为XML并传递给继承自DefaultHandler或HandlerBase(不推荐使用)的对象，以提供给XMLReader解析器来解析</p>
</blockquote>
<p>那么如何获取这两个类呢<br>上文提到这两个类都是抽象类，虽然这两个类都有构造方法，但却都是受保护的protected修饰的<br>并且抽象类也都是无法直接实例化的，也就是无法通过new关键字来获取类的对象</p>
<p>其突破口就在SAXParserFactory抽象类中的，这个类定义了两个静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newInstance() </span><br><span class="line">newInstance(String factoryClassName, ClassLoader classLoader) </span><br></pre></td></tr></table></figure>
<p>从名字就可以看出来是用来获取SAXParserFactory的实例化对象的，<br>有了SAXParserFactory的实例化对象就可以设置一些环境，或让其自动设置，<br>然后就可以用它来创建SAXParser抽象类的对象，使用newSAXParser()方法即可</p>
<blockquote>
<p>newSAXParser()这个方法不是静态方法，所以只能先通过newInstance()静态方法来实例化出SAXParserFactory，<br>然后才能使用SAXParserFactory的非静态方法newSAXParser()来获得SAXParser的对象，因为它们都是抽象类！</p>
</blockquote>
<p>获得了SAXParser的对象后就可以使用其getXMLReader()方法来获取XMLReader解析器了</p>
<blockquote>
<p>另外，XMLReader虽然名为解析器，但具体的解析工作却不是由它来做的，它只是一个框架，<br>具体的解析工作由继承自DefaultHandler或HandlerBase(不推荐使用)的对象来做:<br>XMLReader的setContentHandler(DefaultHandler的子类的对象);<br>DefaultHandler类可用作 SAX2 应用程序的有用基类：<br>它提供四个核心 SAX2 处理程序类中的所有回调的默认实现,也就是它实现了以下四个接口：<br>EntityResolver<br>DTDHandler<br>ContentHandler<br>ErrorHandler </p>
</blockquote>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
        <tag>xmlReader</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 vspd 中的几个模式</title>
    <url>/2023/06/12/%E5%85%B3%E4%BA%8E-vspd-%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>vspd 全称虚拟串口驱动，官方也没有给出很详细的文档，这里仅记录一些自己的理解</p>
<p>测试版本：vspd-v9.0，我主要用来创建虚拟串口以供测试使用</p>
<h2 id="模式-Pairing"><a href="#模式-Pairing" class="headerlink" title="模式 Pairing"></a>模式 Pairing</h2><p>可成对得创建相互连通的虚拟 COM 口，仅能选择新的虚拟 COM 口进行创建，不能使用已存在的 COM 口</p>
<p>举例：<br>创建 COM100 与 COM101 作为 Pairing，使用串口工具打开两个 COM 口，可以互发数据</p>
<h2 id="模式-Split"><a href="#模式-Split" class="headerlink" title="模式 Split"></a>模式 Split</h2><p>将一个真实 COM 串口 split 为多个虚拟 COM 口<br>在这种情况下，被 split 的真实 COM 口接收到的所有数据都会发送到每个 split 出来的虚拟 COM 口<br>反之亦然，即每个 split 出来的虚拟 COM 口接收到的所有数据，都会发送到真实 COM 口</p>
<p>注意，一旦设置生效，则被 split 的真实 COM 口将始终处于被占用状态，其他串口调试工具将无法再次打开它，split 出来的虚拟 COM 口则必须是新创建的，不能是已存在的 COM 口</p>
<p>举例：<br>电脑上存在一个真实 COM 口名为 COM1，将其在 Split 模式下拆分到新的 2 个虚拟 COM 口：COM100 和 COM101，当 COM1 （从外部）接收到数据时，COM100 和 COM101 也都能接收到同样的数据<br>反过来，当 COM100 或 COM101 接收到数据时，COM1 也将接收到同样的数据</p>
<p>注：<br>所以 COM100 和 COM101 都相当于是 COM1 的引用？<br>并发问题？</p>
<h2 id="模式-Join"><a href="#模式-Join" class="headerlink" title="模式 Join"></a>模式 Join</h2><p>与 Split 相反的，可以将多个真实 COM 口合并为一个新的虚拟 COM 口<br>在这种情况下，所有真实 COM 口接收到的所有数据，都会被发送到虚拟 COM 口<br>反之亦然，即虚拟 COM 口收到数据时，每一个 join 了的真实 COM 口也都将收到一份数据</p>
<p>注意，一旦设置生效，则被 join 的真实 COM 口将始终处于被占用状态，其他串口调试工具将无法再次打开它们，join 出来的虚拟 COM 口则必须是新创建的，不能是已存在的 COM 口</p>
<p>举例：<br>电脑上存在两个真实 COM 口名为 COM1 和 COM2，将其在 Join 模式下，合并到一个新的虚拟 COM 口： COM100，当 COM1 或 COM2 收到数据时，COM100 将收到同样的数据<br>反过来，当 COM100 收到数据时，COM1 和 COM2 也将收到同样的数据</p>
<p>注：<br>所以 COM100 相当于同时是 COM1 和 COM2 的引用？<br>并发问题？</p>
<h2 id="模式-Merge"><a href="#模式-Merge" class="headerlink" title="模式 Merge"></a>模式 Merge</h2><p>此模式可以将真实 COM 口和新创建的虚拟 COM 口合并在一起（或仅合并多个真实 COM 口，亦或仅合并多个新创建的虚拟 COM 口），当它们中任意一个 COM 口收到数据时，其他 COM 口都将收到同样的数据。</p>
<p>注意，一旦设置生效，则被 merge 的真实 COM 口将始终处于被占用状态，其他串口调试工具将无法再次打开它们，参与 merge 的虚拟 COM 口必须是新创建的，不能是已存在的 COM 口</p>
<p>举例：<br>电脑上存在一个真实 COM 口名为 COM1，将其在 Merge 模式下与 2 个新虚拟 COM 口：COM100 和 COM101 进行合并，当 COM1 （从外部）接收到数据时，COM100 和 COM101 也都能接收到同样的数据<br>反过来，当 COM100 接收到数据时，COM1 和 COM101 也将接收到同样的数据，同样的，当 COM101 接收到数据时，COM1 和 COM100 也将接收到同样的数据</p>
<p>注：<br>所以 COM1 和 COM100 和 COM101 它们互为另外两方的引用？<br>并发问题？</p>
<h2 id="模式-Switch"><a href="#模式-Switch" class="headerlink" title="模式 Switch"></a>模式 Switch</h2><p>此模式用户将多个真实 COM 口捆绑在一个新创建的虚拟 COM 口上，但同一时刻，只会有一个真实 COM 口与虚拟 COM 口是连通的</p>
<p>这种情况下，应用程序则只与虚拟 COM 口交互数据，不需要了解虚拟 COM 口背后有哪些真实 COM 口，虚拟 COM 口将在被打开时，自动选择一个可用的真实 COM 口</p>
<p>注：<br>反向代理模式？<br>负载均衡模式？</p>
<h2 id="模式-Redirect"><a href="#模式-Redirect" class="headerlink" title="模式 Redirect"></a>模式 Redirect</h2><p>重定向数据，可以将一个真实 COM 口（必须是真实的），与另一个真实或虚拟 COM 进行绑定，就像 Pairing 模式那样，但 Redirect 模式支持使用真实 COM 口</p>
<p>注意，一旦设置生效，被 Redirect 之后的真实 COM 口将一直处于被占用状态</p>
<h2 id="模式-Share"><a href="#模式-Share" class="headerlink" title="模式 Share"></a>模式 Share</h2><p>默认情况下，一个 COM 口只能被 open 一次，即只能被一个应用程序占用，Share 模式可以将一个真实 COM 口设置为可共享的模式，让多个已设置的应用程序同时 open 它，还能设置应用程序的权限</p>
<h1 id="模式-Complex"><a href="#模式-Complex" class="headerlink" title="模式 Complex"></a>模式 Complex</h1><p>未能看懂</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>vspd</tag>
      </tags>
  </entry>
  <entry>
    <title>列表初始化 vs 成员初始化器列表</title>
    <url>/2020/10/29/%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96-vs-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>列表初始化，成员初始化器列表，初始化列表，傻傻搞不清楚</p>
<p>唉，为什么总有刁民乱起名</p>
<h2 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h2><p>(译：<code>花括号初始化器列表</code>)</p>
<p>简介：<br>可以将其理解为类/模板类</p>
<p>备注：<br>这表示一种花括号数据类型 <code>&#123;x, y, ...&#125;</code><br>当然，这也是一种普通的数据类型，其他类型怎么用，它就可以怎么用，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::initializer_list&lt;int&gt; foo &#x3D; &#123;1, 2, 3, 4&#125; &#x2F;&#x2F; 声明此类型数据并赋值</span><br><span class="line">auto foo &#x3D; &#123;1, 2, 3, 4&#125; &#x2F;&#x2F; 同上</span><br><span class="line">void func_bar(std::initializer_list&lt;int&gt; arg_var) &#123;&#125; &#x2F;&#x2F; 声明此类型数据为形参</span><br></pre></td></tr></table></figure>

<p>中英文链接：<br><a href="https://zh.cppreference.com/w/cpp/utility/initializer_list">https://zh.cppreference.com/w/cpp/utility/initializer_list</a><br><a href="https://en.cppreference.com/w/cpp/utility/initializer_list">https://en.cppreference.com/w/cpp/utility/initializer_list</a></p>
<h2 id="List-initialization"><a href="#List-initialization" class="headerlink" title="List initialization"></a>List initialization</h2><p>(译：<code>列表初始化</code>)</p>
<p>简介：<br>Initializes an object from braced-init-list<br>(译：从 <code>花括号初始化器列表</code> 初始化对象)</p>
<p>备注：<br>这是一种语法，一种使用花括号数据初始化 <code>变量</code> 的 <code>语法</code> ，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; mem&#123;1,2,3&#125;; &#x2F;&#x2F; 直接列表初始化</span><br><span class="line">std::vector&lt;int&gt; mem &#x3D; &#123;1,2,3&#125;; &#x2F;&#x2F; 赋值列表初始化</span><br></pre></td></tr></table></figure>

<p>中英文链接：<br><a href="https://zh.cppreference.com/w/cpp/language/list_initialization">https://zh.cppreference.com/w/cpp/language/list_initialization</a><br><a href="https://en.cppreference.com/w/cpp/language/list_initialization">https://en.cppreference.com/w/cpp/language/list_initialization</a></p>
<h2 id="member-initializer-lists"><a href="#member-initializer-lists" class="headerlink" title="member initializer lists"></a>member initializer lists</h2><p>(译：<code>成员初始化器列表</code>)</p>
<p>简介：<br>In the definition of a constructor of a class, member initializer list specifies the initializers for direct and virtual bases and non-static data members<br>(译：在类的构造函数定义中，<code>成员初始化器列表</code> 指定各个直接和虚基类和各个非静态数据成员的初始化器)</p>
<p>备注：<br>这是一种语法，一种使用花括号数据初始化 <code>成员变量</code> 的 <code>语法</code>，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 也可以将 列表初始化 应用到 成员初始化器列表中</span><br><span class="line">    &#x2F;&#x2F;Foo(int i, int j) : m_data_i&#123;i&#125;, m_data_j&#123;j&#125;</span><br><span class="line">    Foo(int i, int j) : m_data_i(i), m_data_j(j)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data_k &#x3D; m_data_i + m_data_j;</span><br><span class="line">    &#125;</span><br><span class="line">    int m_data_i;</span><br><span class="line">    int m_data_j;</span><br><span class="line">    int m_data_k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>似乎很多人都称其为：<code>初始化列表</code>，这很容易与上面提到的<code>列表初始化</code>搞混，我在中文网站 <a href="">https://zh.cppreference.com</a> 翻了很久也没有找到<code>初始化列表</code>这个名词，所以我认为这是对<code>成员初始化器列表</code>的无脑简写。</p>
<p>中英文链接：<br><a href="https://zh.cppreference.com/w/cpp/language/constructor">https://zh.cppreference.com/w/cpp/language/constructor</a><br><a href="https://en.cppreference.com/w/cpp/language/constructor">https://en.cppreference.com/w/cpp/language/constructor</a></p>
<h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                       列表初始化</span><br><span class="line">                     &#x2F;</span><br><span class="line">std::initializer_list</span><br><span class="line">                     \</span><br><span class="line">                       成员初始化器列表 </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
      </categories>
  </entry>
  <entry>
    <title>判断是否是 vscode 内启动的终端</title>
    <url>/2020/04/10/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF-vscode-%E5%86%85%E5%90%AF%E5%8A%A8%E7%9A%84%E7%BB%88%E7%AB%AF/</url>
    <content><![CDATA[<p>由于在 <code>bashrc</code> 中配置了自动 run/attach tmux，因此在 vscode 内启动终端时也会找 tmux，如果想避免这种情况或者类似的情况可以通过修改 vscode 的配置文件，添加自定义环境变量，然后在 <code>bashrc</code> 里进行判断，比如在 vscode 的配置文件中添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; NOTE: 在 deepin linux bash 下经过测试发现，不能使用 VSCODE_ 开头的名字作为变量，否则无效</span><br><span class="line">&quot;terminal.integrated.env.linux&quot;: &#123;</span><br><span class="line">    &quot;IS_VSCODE_INTEGRATED_TERMINAL&quot;: &quot;1&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;terminal.integrated.env.osx&quot;: &#123;</span><br><span class="line">    &quot;IS_VSCODE_INTEGRATED_TERMINAL&quot;: &quot;1&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>表示在 linux/osx 下的 vscode 里，为终端设置值为 1 的环境变量： <code>IS_VSCODE_INTEGRATED_TERMINAL</code></p>
<p>然后在 <code>bashrc</code> 文件中进行检测，如果存在此变量则不启动 tmux：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [[ -z $IS_VSCODE_INTEGRATED_TERMINAL ]]; then</span><br><span class="line">    which tmux &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1\</span><br><span class="line">        &amp;&amp; [[ -z &quot;$TMUX&quot; ]]\</span><br><span class="line">        &amp;&amp; &#123; if ! tmux a; then exec tmux; fi; &#125;</span><br><span class="line">else</span><br><span class="line">    echo &quot;-&gt; disabled tmux &lt;-&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>terminal</tag>
        <tag>bashrc</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>同步安卓源码:Cannot fetch CyanogenMod/android external svox</title>
    <url>/2016/04/23/%E5%90%8C%E6%AD%A5%E5%AE%89%E5%8D%93%E6%BA%90%E7%A0%81-Cannot-fetch-CyanogenMod-android-external-svox/</url>
    <content><![CDATA[<p>同步CM10.1到99%出现错误：<br><code>error: Cannot fetch CyanogenMod/</code><font color=red><strong>Android</strong></font> <code>external svox</code></p>
<p>或者是这样的提示：<br><code>repo sync Repository unavailable due to DMCA takedown</code></p>
<p>解决办法：</p>
<p>repo init后<br>修改 <code>.repo/manifests/default.xml</code><br>把<br><code>&lt;project path=&quot;external/svox&quot; name=&quot;CyanogenMod/android_external_svox&quot;/&gt;</code><br>替换修改为<br><code>&lt;project path=&quot;external/svox&quot; name=&quot;platform/external/svox&quot; remote=&quot;aosp&quot; revision=&quot;refs/tags/android-4.4.4_r2&quot;/&gt;</code></p>
<p>注意红色文字部分、那是你同步的版本号</p>
<p>如果不确定应该改为多少、就搜索aosp、会发现每一个搜索结果中的行里都有一个类似的语句、</p>
<p>把这句里的版本号改为你搜索到的那些版本号就行了</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>repo</tag>
        <tag>Cannot</tag>
        <tag>fetch</tag>
        <tag>external</tag>
        <tag>svox</tag>
      </tags>
  </entry>
  <entry>
    <title>国际域名缩写</title>
    <url>/2019/08/09/%E5%9B%BD%E9%99%85%E5%9F%9F%E5%90%8D%E7%BC%A9%E5%86%99/</url>
    <content><![CDATA[<blockquote>
<p>转自：<a href="">http://www.jctrans.com/tool/gjym.htm</a></p>
</blockquote>
<h1 id="国际域名缩写"><a href="#国际域名缩写" class="headerlink" title="国际域名缩写"></a>国际域名缩写</h1><table>
<thead>
<tr>
<th>国际域名缩写</th>
<th>国家或地区</th>
<th>Countries and Regions</th>
</tr>
</thead>
<tbody><tr>
<td>AD</td>
<td>安道尔共和国</td>
<td>Andorra</td>
</tr>
<tr>
<td>AE</td>
<td>阿拉伯联合酋长国</td>
<td>United Arab Emirates</td>
</tr>
<tr>
<td>AF</td>
<td>阿富汗</td>
<td>Afghanistan</td>
</tr>
<tr>
<td>AG</td>
<td>安提瓜和巴布达</td>
<td>Antigua and Barbuda</td>
</tr>
<tr>
<td>AI</td>
<td>安圭拉岛</td>
<td>Anguilla</td>
</tr>
<tr>
<td>AL</td>
<td>阿尔巴尼亚</td>
<td>Albania</td>
</tr>
<tr>
<td>AM</td>
<td>亚美尼亚</td>
<td>Armenia</td>
</tr>
<tr>
<td>AO</td>
<td>安哥拉</td>
<td>Angola</td>
</tr>
<tr>
<td>AR</td>
<td>阿根廷</td>
<td>Argentina</td>
</tr>
<tr>
<td>AT</td>
<td>奥地利</td>
<td>Austria</td>
</tr>
<tr>
<td>AU</td>
<td>澳大利亚</td>
<td>Australia</td>
</tr>
<tr>
<td>AZ</td>
<td>阿塞拜疆</td>
<td>Azerbaijan</td>
</tr>
<tr>
<td>BB</td>
<td>巴巴多斯</td>
<td>Barbados</td>
</tr>
<tr>
<td>BD</td>
<td>孟加拉国</td>
<td>Bangladesh</td>
</tr>
<tr>
<td>BE</td>
<td>比利时</td>
<td>Belgium</td>
</tr>
<tr>
<td>BF</td>
<td>布基纳法索</td>
<td>Burkina-faso</td>
</tr>
<tr>
<td>BG</td>
<td>保加利亚</td>
<td>Bulgaria</td>
</tr>
<tr>
<td>BH</td>
<td>巴林</td>
<td>Bahrain</td>
</tr>
<tr>
<td>BI</td>
<td>布隆迪</td>
<td>Burundi</td>
</tr>
<tr>
<td>BJ</td>
<td>贝宁</td>
<td>Benin</td>
</tr>
<tr>
<td>BL</td>
<td>巴勒斯坦</td>
<td>Palestine</td>
</tr>
<tr>
<td>BM</td>
<td>百慕大群岛</td>
<td>Bermuda Is.</td>
</tr>
<tr>
<td>BN</td>
<td>文莱</td>
<td>Brunei</td>
</tr>
<tr>
<td>BO</td>
<td>玻利维亚</td>
<td>Bolivia</td>
</tr>
<tr>
<td>BR</td>
<td>巴西</td>
<td>Brazil</td>
</tr>
<tr>
<td>BS</td>
<td>巴哈马</td>
<td>Bahamas</td>
</tr>
<tr>
<td>BW</td>
<td>博茨瓦纳</td>
<td>Botswana</td>
</tr>
<tr>
<td>BY</td>
<td>白俄罗斯</td>
<td>Belarus</td>
</tr>
<tr>
<td>BZ</td>
<td>伯利兹</td>
<td>Belize</td>
</tr>
<tr>
<td>CA</td>
<td>加拿大</td>
<td>Canada</td>
</tr>
<tr>
<td>CF</td>
<td>中非共和国</td>
<td>Central African Republic</td>
</tr>
<tr>
<td>CG</td>
<td>刚果</td>
<td>Congo</td>
</tr>
<tr>
<td>CH</td>
<td>瑞士</td>
<td>Switzerland</td>
</tr>
<tr>
<td>CK</td>
<td>库克群岛</td>
<td>Cook Is.</td>
</tr>
<tr>
<td>CL</td>
<td>智利</td>
<td>Chile</td>
</tr>
<tr>
<td>CM</td>
<td>喀麦隆</td>
<td>Cameroon</td>
</tr>
<tr>
<td>CN</td>
<td>中国</td>
<td>China</td>
</tr>
<tr>
<td>CO</td>
<td>哥伦比亚</td>
<td>Colombia</td>
</tr>
<tr>
<td>CR</td>
<td>哥斯达黎加</td>
<td>Costa Rica</td>
</tr>
<tr>
<td>CS</td>
<td>捷克</td>
<td>Czech</td>
</tr>
<tr>
<td>CU</td>
<td>古巴</td>
<td>Cuba</td>
</tr>
<tr>
<td>CY</td>
<td>塞浦路斯</td>
<td>Cyprus</td>
</tr>
<tr>
<td>CZ</td>
<td>捷克</td>
<td>Czech Republic</td>
</tr>
<tr>
<td>DE</td>
<td>德国</td>
<td>Germany</td>
</tr>
<tr>
<td>DJ</td>
<td>吉布提</td>
<td>Djibouti</td>
</tr>
<tr>
<td>DK</td>
<td>丹麦</td>
<td>Denmark</td>
</tr>
<tr>
<td>DO</td>
<td>多米尼加共和国</td>
<td>Dominica Rep.</td>
</tr>
<tr>
<td>DZ</td>
<td>阿尔及利亚</td>
<td>Algeria</td>
</tr>
<tr>
<td>EC</td>
<td>厄瓜多尔</td>
<td>Ecuador</td>
</tr>
<tr>
<td>EE</td>
<td>爱沙尼亚</td>
<td>Estonia</td>
</tr>
<tr>
<td>EG</td>
<td>埃及</td>
<td>Egypt</td>
</tr>
<tr>
<td>ES</td>
<td>西班牙</td>
<td>Spain</td>
</tr>
<tr>
<td>ET</td>
<td>埃塞俄比亚</td>
<td>Ethiopia</td>
</tr>
<tr>
<td>FI</td>
<td>芬兰</td>
<td>Finland</td>
</tr>
<tr>
<td>FJ</td>
<td>斐济</td>
<td>Fiji</td>
</tr>
<tr>
<td>FR</td>
<td>法国</td>
<td>France</td>
</tr>
<tr>
<td>GA</td>
<td>加蓬</td>
<td>Gabon</td>
</tr>
<tr>
<td>GB</td>
<td>英国</td>
<td>United Kiongdom</td>
</tr>
<tr>
<td>GD</td>
<td>格林纳达</td>
<td>Grenada</td>
</tr>
<tr>
<td>GE</td>
<td>格鲁吉亚</td>
<td>Georgia</td>
</tr>
<tr>
<td>GF</td>
<td>法属圭亚那</td>
<td>French Guiana</td>
</tr>
<tr>
<td>GH</td>
<td>加纳</td>
<td>Ghana</td>
</tr>
<tr>
<td>GI</td>
<td>直布罗陀</td>
<td>Gibraltar</td>
</tr>
<tr>
<td>GM</td>
<td>冈比亚</td>
<td>Gambia</td>
</tr>
<tr>
<td>GN</td>
<td>几内亚</td>
<td>Guinea</td>
</tr>
<tr>
<td>GR</td>
<td>希腊</td>
<td>Greece</td>
</tr>
<tr>
<td>GT</td>
<td>危地马拉</td>
<td>Guatemala</td>
</tr>
<tr>
<td>GU</td>
<td>关岛</td>
<td>Guam</td>
</tr>
<tr>
<td>GY</td>
<td>圭亚那</td>
<td>Guyana</td>
</tr>
<tr>
<td>HK</td>
<td>香港特别行政区</td>
<td>Hongkong</td>
</tr>
<tr>
<td>HN</td>
<td>洪都拉斯</td>
<td>Honduras</td>
</tr>
<tr>
<td>HT</td>
<td>海地</td>
<td>Haiti</td>
</tr>
<tr>
<td>HU</td>
<td>匈牙利</td>
<td>Hungary</td>
</tr>
<tr>
<td>ID</td>
<td>印度尼西亚</td>
<td>Indonesia</td>
</tr>
<tr>
<td>IE</td>
<td>爱尔兰</td>
<td>Ireland</td>
</tr>
<tr>
<td>IL</td>
<td>以色列</td>
<td>Israel</td>
</tr>
<tr>
<td>IN</td>
<td>印度</td>
<td>India</td>
</tr>
<tr>
<td>IQ</td>
<td>伊拉克</td>
<td>Iraq</td>
</tr>
<tr>
<td>IR</td>
<td>伊朗</td>
<td>Iran</td>
</tr>
<tr>
<td>IS</td>
<td>冰岛</td>
<td>Iceland</td>
</tr>
<tr>
<td>IT</td>
<td>意大利</td>
<td>Italy</td>
</tr>
<tr>
<td>JM</td>
<td>牙买加</td>
<td>Jamaica</td>
</tr>
<tr>
<td>JO</td>
<td>约旦</td>
<td>Jordan</td>
</tr>
<tr>
<td>JP</td>
<td>日本</td>
<td>Japan</td>
</tr>
<tr>
<td>KE</td>
<td>肯尼亚</td>
<td>Kenya</td>
</tr>
<tr>
<td>KG</td>
<td>吉尔吉斯坦</td>
<td>Kyrgyzstan</td>
</tr>
<tr>
<td>KH</td>
<td>柬埔寨</td>
<td>Kampuchea (Cambodia )</td>
</tr>
<tr>
<td>KP</td>
<td>朝鲜</td>
<td>North Korea</td>
</tr>
<tr>
<td>KR</td>
<td>韩国</td>
<td>Korea</td>
</tr>
<tr>
<td>KT</td>
<td>科特迪瓦共和国</td>
<td>Republic of Ivory Coast</td>
</tr>
<tr>
<td>KW</td>
<td>科威特</td>
<td>Kuwait</td>
</tr>
<tr>
<td>KZ</td>
<td>哈萨克斯坦</td>
<td>Kazakstan</td>
</tr>
<tr>
<td>LA</td>
<td>老挝</td>
<td>Laos</td>
</tr>
<tr>
<td>LB</td>
<td>黎巴嫩</td>
<td>Lebanon</td>
</tr>
<tr>
<td>LC</td>
<td>圣卢西亚</td>
<td>St.Lucia</td>
</tr>
<tr>
<td>LI</td>
<td>列支敦士登</td>
<td>Liechtenstein</td>
</tr>
<tr>
<td>LK</td>
<td>斯里兰卡</td>
<td>Sri Lanka</td>
</tr>
<tr>
<td>LR</td>
<td>利比里亚</td>
<td>Liberia</td>
</tr>
<tr>
<td>LS</td>
<td>莱索托</td>
<td>Lesotho</td>
</tr>
<tr>
<td>LT</td>
<td>立陶宛</td>
<td>Lithuania</td>
</tr>
<tr>
<td>LU</td>
<td>卢森堡</td>
<td>Luxembourg</td>
</tr>
<tr>
<td>LV</td>
<td>拉脱维亚</td>
<td>Latvia</td>
</tr>
<tr>
<td>LY</td>
<td>利比亚</td>
<td>Libya</td>
</tr>
<tr>
<td>MA</td>
<td>摩洛哥</td>
<td>Morocco</td>
</tr>
<tr>
<td>MC</td>
<td>摩纳哥</td>
<td>Monaco</td>
</tr>
<tr>
<td>MD</td>
<td>摩尔多瓦</td>
<td>Moldova, Republic of</td>
</tr>
<tr>
<td>MG</td>
<td>马达加斯加</td>
<td>Madagascar</td>
</tr>
<tr>
<td>ML</td>
<td>马里</td>
<td>Mali</td>
</tr>
<tr>
<td>MM</td>
<td>缅甸</td>
<td>Burma</td>
</tr>
<tr>
<td>MN</td>
<td>蒙古</td>
<td>Mongolia</td>
</tr>
<tr>
<td>MO</td>
<td>澳门</td>
<td>Macao</td>
</tr>
<tr>
<td>MS</td>
<td>蒙特塞拉特岛</td>
<td>Montserrat Is</td>
</tr>
<tr>
<td>MT</td>
<td>马耳他</td>
<td>Malta</td>
</tr>
<tr>
<td>MU</td>
<td>毛里求斯</td>
<td>Mauritius</td>
</tr>
<tr>
<td>MV</td>
<td>马尔代夫</td>
<td>Maldives</td>
</tr>
<tr>
<td>MW</td>
<td>马拉维</td>
<td>Malawi</td>
</tr>
<tr>
<td>MX</td>
<td>墨西哥</td>
<td>Mexico</td>
</tr>
<tr>
<td>MY</td>
<td>马来西亚</td>
<td>Malaysia</td>
</tr>
<tr>
<td>MZ</td>
<td>莫桑比克</td>
<td>Mozambique</td>
</tr>
<tr>
<td>NA</td>
<td>纳米比亚</td>
<td>Namibia</td>
</tr>
<tr>
<td>NE</td>
<td>尼日尔</td>
<td>Niger</td>
</tr>
<tr>
<td>NG</td>
<td>尼日利亚</td>
<td>Nigeria</td>
</tr>
<tr>
<td>NI</td>
<td>尼加拉瓜</td>
<td>Nicaragua</td>
</tr>
<tr>
<td>NL</td>
<td>荷兰</td>
<td>Netherlands</td>
</tr>
<tr>
<td>NO</td>
<td>挪威</td>
<td>Norway</td>
</tr>
<tr>
<td>NP</td>
<td>尼泊尔</td>
<td>Nepal</td>
</tr>
<tr>
<td>NR</td>
<td>瑙鲁</td>
<td>Nauru</td>
</tr>
<tr>
<td>NZ</td>
<td>新西兰</td>
<td>New Zealand</td>
</tr>
<tr>
<td>OM</td>
<td>阿曼</td>
<td>Oman</td>
</tr>
<tr>
<td>PA</td>
<td>巴拿马</td>
<td>Panama</td>
</tr>
<tr>
<td>PE</td>
<td>秘鲁</td>
<td>Peru</td>
</tr>
<tr>
<td>PF</td>
<td>法属玻利尼西亚</td>
<td>French Polynesia</td>
</tr>
<tr>
<td>PG</td>
<td>巴布亚新几内亚</td>
<td>Papua New Cuinea</td>
</tr>
<tr>
<td>PH</td>
<td>菲律宾</td>
<td>Philippines</td>
</tr>
<tr>
<td>PK</td>
<td>巴基斯坦</td>
<td>Pakistan</td>
</tr>
<tr>
<td>PL</td>
<td>波兰</td>
<td>Poland</td>
</tr>
<tr>
<td>PR</td>
<td>波多黎各</td>
<td>Puerto Rico</td>
</tr>
<tr>
<td>PT</td>
<td>葡萄牙</td>
<td>Portugal</td>
</tr>
<tr>
<td>PY</td>
<td>巴拉圭</td>
<td>Paraguay</td>
</tr>
<tr>
<td>QA</td>
<td>卡塔尔</td>
<td>Qatar</td>
</tr>
<tr>
<td>RO</td>
<td>罗马尼亚</td>
<td>Romania</td>
</tr>
<tr>
<td>RU</td>
<td>俄罗斯</td>
<td>Russia</td>
</tr>
<tr>
<td>SA</td>
<td>沙特阿拉伯</td>
<td>Saudi Arabia</td>
</tr>
<tr>
<td>SB</td>
<td>所罗门群岛</td>
<td>Solomon Is</td>
</tr>
<tr>
<td>SC</td>
<td>塞舌尔</td>
<td>Seychelles</td>
</tr>
<tr>
<td>SD</td>
<td>苏丹</td>
<td>Sudan</td>
</tr>
<tr>
<td>SE</td>
<td>瑞典</td>
<td>Sweden</td>
</tr>
<tr>
<td>SG</td>
<td>新加坡</td>
<td>Singapore</td>
</tr>
<tr>
<td>SI</td>
<td>斯洛文尼亚</td>
<td>Slovenia</td>
</tr>
<tr>
<td>SK</td>
<td>斯洛伐克</td>
<td>Slovakia</td>
</tr>
<tr>
<td>SL</td>
<td>塞拉利昂</td>
<td>Sierra Leone</td>
</tr>
<tr>
<td>SM</td>
<td>圣马力诺</td>
<td>San Marino</td>
</tr>
<tr>
<td>SN</td>
<td>塞内加尔</td>
<td>Senegal</td>
</tr>
<tr>
<td>SO</td>
<td>索马里</td>
<td>Somali</td>
</tr>
<tr>
<td>SR</td>
<td>苏里南</td>
<td>Suriname</td>
</tr>
<tr>
<td>ST</td>
<td>圣多美和普林西比</td>
<td>Sao Tome and Principe</td>
</tr>
<tr>
<td>SV</td>
<td>萨尔瓦多</td>
<td>EI Salvador</td>
</tr>
<tr>
<td>SY</td>
<td>叙利亚</td>
<td>Syria</td>
</tr>
<tr>
<td>SZ</td>
<td>斯威士兰</td>
<td>Swaziland</td>
</tr>
<tr>
<td>TD</td>
<td>乍得</td>
<td>Chad</td>
</tr>
<tr>
<td>TG</td>
<td>多哥</td>
<td>Togo</td>
</tr>
<tr>
<td>TH</td>
<td>泰国</td>
<td>Thailand</td>
</tr>
<tr>
<td>TJ</td>
<td>塔吉克斯坦</td>
<td>Tajikstan</td>
</tr>
<tr>
<td>TM</td>
<td>土库曼斯坦</td>
<td>Turkmenistan</td>
</tr>
<tr>
<td>TN</td>
<td>突尼斯</td>
<td>Tunisia</td>
</tr>
<tr>
<td>TO</td>
<td>汤加</td>
<td>Tonga</td>
</tr>
<tr>
<td>TR</td>
<td>土耳其</td>
<td>Turkey</td>
</tr>
<tr>
<td>TT</td>
<td>特立尼达和多巴哥</td>
<td>Trinidad and Tobago</td>
</tr>
<tr>
<td>TW</td>
<td>台湾省</td>
<td>Taiwan</td>
</tr>
<tr>
<td>TZ</td>
<td>坦桑尼亚</td>
<td>Tanzania</td>
</tr>
<tr>
<td>UA</td>
<td>乌克兰</td>
<td>Ukraine</td>
</tr>
<tr>
<td>UG</td>
<td>乌干达</td>
<td>Uganda</td>
</tr>
<tr>
<td>US</td>
<td>美国</td>
<td>United States of America</td>
</tr>
<tr>
<td>UY</td>
<td>乌拉圭</td>
<td>Uruguay</td>
</tr>
<tr>
<td>UZ</td>
<td>乌兹别克斯坦</td>
<td>Uzbekistan</td>
</tr>
<tr>
<td>VC</td>
<td>圣文森特岛</td>
<td>Saint Vincent</td>
</tr>
<tr>
<td>VE</td>
<td>委内瑞拉</td>
<td>Venezuela</td>
</tr>
<tr>
<td>VN</td>
<td>越南</td>
<td>Vietnam</td>
</tr>
<tr>
<td>YE</td>
<td>也门</td>
<td>Yemen</td>
</tr>
<tr>
<td>YU</td>
<td>南斯拉夫</td>
<td>Yugoslavia</td>
</tr>
<tr>
<td>ZA</td>
<td>南非</td>
<td>South Africa</td>
</tr>
<tr>
<td>ZM</td>
<td>赞比亚</td>
<td>Zambia</td>
</tr>
<tr>
<td>ZR</td>
<td>扎伊尔</td>
<td>Zaire</td>
</tr>
<tr>
<td>ZW</td>
<td>津巴布韦</td>
<td>Zimbabwe</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>在自己的服务器上搭建静态博客</title>
    <url>/2019/03/31/%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>最近 coding 的 pages 服务越来越没法用了，不是自动部署失败就是博客无法访问，而且访问速度很慢，估计再过段时间 coding 就不再提供免费的 pages 服务了。但是如果将域名解析到 github 上，百度又无法抓取(github 不允许)，思来想去还是放在自己的服务器上吧。</p>
<p>不过放在自己的服务器上有两个问题：</p>
<ul>
<li>没有备案不能使用 dnspod 的 301 重定向把 www 的域名重定向到顶级域名</li>
<li>博客更新后不能自动部署</li>
</ul>
<p>我的博客是个基于 hexo 的静态博客，可以使用 nginx 来提供 web 服务，同时 nginx 可以配置根据域名来重定向，这样就解决了第一个问题，博客内容就使用 git 仓库，注意这个仓库不是 markdown 的原始文件，而是经过 hexo 根据生成后的 html 站点，如果之前在 github 上部署过，在 github 上的仓库的名字应该会是 <code>&lt;UserName&gt;.github.io</code> 或者在 coding 上部署过那仓库名则是 coding 下跟用户名相同的仓库。以后更新了博客依然推送到 github 或者 coding 上，在自己的服务器上 clone 下仓库，然后使用 github 或者 coding 的 webhooks 功能更新自己服务器上的仓库，这样就解决了自己服务器上的博客不能自动部署更新的问题。</p>
<p>下面的例子是基于 github 的，coding 的操作类似，不过鉴于 coding 提供的服务不太稳定的问题，建议博客仓库托管也不要放在 coding 上了。</p>
<h1 id="克隆博客仓库到服务器上"><a href="#克隆博客仓库到服务器上" class="headerlink" title="克隆博客仓库到服务器上"></a>克隆博客仓库到服务器上</h1><p>这一步很简单，跟克隆普通 git 仓库一样，我把仓库放在了 <code>/opt/hexo-blog</code> 下，如果不放在这个路径下，那后面的内容中的相应路径也要修改。</p>
<p>以我在 github 下的博客仓库为例，注意执行命令的用户权限，后面的命令都假设服务器上的账户是 root：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:listenerri&#x2F;listenerri.github.io.git &#x2F;opt&#x2F;hexo-blog</span><br></pre></td></tr></table></figure>

<p>这里使用了 ssh 协议的仓库地址，这需要将服务器的 ssh public key 部署在自己的 github 账户中，如果不想部署使用 https 协议的地址也可以，不过可能会需要输入用户名和密码，这会影响到后面 python 脚本中的功能，建议还是用 ssh 协议的地址，部署个 key 又不麻烦。</p>
<h1 id="安装配置-nginx"><a href="#安装配置-nginx" class="headerlink" title="安装配置 nginx"></a>安装配置 nginx</h1><p>在服务器上安装配置 nginx，debian 系的 linux 系统中使用下面的命令就可以安装，其他系统可以在网上找找 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install nginx</span><br></pre></td></tr></table></figure>

<p>安装之后不要急着启动 nginx 服务，要先配置下网站路径和域名相关的东西。</p>
<p>编辑 <code>/etc/nginx/nginx.conf</code> 文件，在 http 块中添加两个 server 块配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        server_name  listenerri.com;</span><br><span class="line">        root         &#x2F;opt&#x2F;hexo-blog;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.listenerri.com;</span><br><span class="line">        return       301 http:&#x2F;&#x2F;listenerri.com$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个 server 块定义了主域名下的网站，也就是博客使用的域名和博客在服务器上的路径(上面克隆仓库时指定的地址)，第二个 server 块则是定义了将 www 的域名 301 重定向的顶级域名的网站下，我比较喜欢不带 www 的地址 :)</p>
<p>接下来启动 nginx 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx start</span><br><span class="line"># 或者如果系统是 systemd 的：</span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>

<h1 id="修改域名解析地址"><a href="#修改域名解析地址" class="headerlink" title="修改域名解析地址"></a>修改域名解析地址</h1><p>上面 nginx 服务启动后就可以使用服务器的 ip 地址(这时还不能使用域名)进行访问了，如果测试没问题就可以修改域名的解析到这个服务器 ip 上了，这一步没什么好说的，就是把自己域名的 A 记录改成服务器的 ip 地址。</p>
<p>改完之后过一会儿使用 dig 命令查看域名是否已经解析到服务器的地址了，如果解析已经生效了就可以访问域名来测试博客是否可以正常访问了。</p>
<p>注意把 www 的域名也解析到服务器 ip 地址上。</p>
<h1 id="启动-github-webhooks"><a href="#启动-github-webhooks" class="headerlink" title="启动 github webhooks"></a>启动 github webhooks</h1><p>在服务器上把下面的代码保存到一个 py 文件中，假设文件路径为 <code>/opt/webhooks.py</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from http.server import BaseHTTPRequestHandler</span><br><span class="line">from http.server import HTTPServer</span><br><span class="line">import os</span><br><span class="line">import subprocess</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class MyBaseHTTPRequestHandler(BaseHTTPRequestHandler):</span><br><span class="line"></span><br><span class="line">    def do_GET(self):</span><br><span class="line">        self.send_response(200)</span><br><span class="line">        self.send_header(&#39;Content-type&#39;, &#39;text&#x2F;html&#39;)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(b&#39;Only handle POST requests.\n&#39;)</span><br><span class="line">        flushLog()</span><br><span class="line"></span><br><span class="line">    def do_POST(self):</span><br><span class="line">        statusCode &#x3D; 403</span><br><span class="line">        responseData &#x3D; b&quot;Reject the request&quot;</span><br><span class="line">        if self.path &#x3D;&#x3D; &quot;&#x2F;pushed&quot;:</span><br><span class="line">            statusCode, responseData &#x3D; self.updateBlog()</span><br><span class="line">        self.send_response(statusCode)</span><br><span class="line">        self.send_header(&#39;Content-type&#39;, &#39;text&#x2F;html&#39;)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(bytes(responseData, &quot;utf-8&quot;))</span><br><span class="line">        flushLog()</span><br><span class="line"></span><br><span class="line">    def updateBlog(self):</span><br><span class="line">        os.chdir(&quot;&#x2F;opt&#x2F;hexo-blog&quot;)</span><br><span class="line">        code, result &#x3D; subprocess.getstatusoutput(&quot;git pull origin master&quot;)</span><br><span class="line">        if code &#x3D;&#x3D; 0:</span><br><span class="line">            code &#x3D; 200</span><br><span class="line">            result &#x3D; &quot;blog updated :)&quot;</span><br><span class="line">        else:</span><br><span class="line">            code &#x3D; 500</span><br><span class="line">            print(result)</span><br><span class="line">            result &#x3D; &quot;blog update failed :(&quot;</span><br><span class="line">        return code, result</span><br><span class="line"></span><br><span class="line">def flushLog():</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    sys.stderr.flush()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    port &#x3D; 2345</span><br><span class="line">    httpd &#x3D; HTTPServer((&quot;&quot;, port), MyBaseHTTPRequestHandler)</span><br><span class="line">    print(&quot;Running on port: %d&quot;%(port))</span><br><span class="line">    flushLog()</span><br><span class="line">    httpd.serve_forever()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>脚本的内容就是启动了一个监听 2345 端口的 http 服务，只接受 <code>/pushed</code> 资源路径的 POST 访问，其他资源路径的 POST 访问全都返回 403，每次接收到正确的 POST 访问后就去 <code>/opt/hexo-blog</code> 路径下更新仓库，也就是从 github 远程仓库下拉取更新，如果更新成功返回 200 状态码，否则返回 500，如果更新失败则打印下命令的输出，以便以后根据日志文件定位问题。</p>
<p>接下来给这个脚本增加可执行权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod a+x &#x2F;opt&#x2F;webhooks.py</span><br></pre></td></tr></table></figure>

<p>启动脚本同时把脚本的输出追加到 <code>/var/log/blog-github-webhooks.log</code> 文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup &#x2F;opt&#x2F;webhooks.py &gt;&gt; &#x2F;var&#x2F;log&#x2F;blog-github-webhooks.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>然后配置下这个脚本开机自启动，如果是 systemd 的系统就写一个 service 文件，将上述命令稍微修改下写入 service 文件中的 <code>EXEC</code> 字段后面，具体的 service 文件怎么写和怎么用可以在网上搜索下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;opt&#x2F;webhooks.py &gt;&gt; &#x2F;var&#x2F;log&#x2F;blog-github-webhooks.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>如果不是 systemd 的系统就把上面的命令复制到 <code>/etc/rc.local</code> 文件中的最后一行，不过 systemd 好像也兼容 <code>/etc/rc.local</code> 文件，直接用第二种方法配置开机自启估计也行。</p>
<h1 id="设置-github-webhooks"><a href="#设置-github-webhooks" class="headerlink" title="设置 github webhooks"></a>设置 github webhooks</h1><p>去 github 网站博客对应的项目页面下，点击 <code>Settings</code> 按钮，再点击新页面左侧导航栏的 <code>Webhooks</code> 按钮：</p>
<p><img src="webhooks.png"></p>
<p>再点击上图右上角的 <code>Add Webhook</code> 按钮：</p>
<p><img src="add-webhooks.png"></p>
<p>在上图 <code>Payload URL</code> 的输入框中填入自己的服务器 ip 或者域名并加上端口 <code>2345</code> 和资源路径 <code>/pushed</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;listenerri.com:2345&#x2F;pushed</span><br></pre></td></tr></table></figure>

<p>然后直接点击下面绿色的 <code>Add webhook</code> 按钮就行了。</p>
<p>github 会发送一个测试的 POST 请求到设置的地址中，点击刚刚添加的 webhook 可以进入这个 webhook 的设置界面，这个界面最下面会后这个 webhook 的最近活动，如果没有意外会有如下图中的带有绿色对勾的一条记录：</p>
<p><img src="recent-activity.png"></p>
<p>当然可以写一遍新博客测试下。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nginx</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序（完全二叉树）最后一个非叶子节点（父节点）的序号是 n/2-1 的原因</title>
    <url>/2021/08/30/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%BA%8F%E5%8F%B7%E6%98%AF-n-2-1-%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>参考并修正了其中的错误：<a href="https://www.cnblogs.com/malw/p/10542557.html">https://www.cnblogs.com/malw/p/10542557.html</a></p>
<p>堆排序是基于完全二叉树实现的，在将一个数组调整成一个堆的时候，关键之一的是确定最后一个非叶子节点的序号，这个序号为 <code>n/2-1</code>，<code>n</code> 为数组的长度。但是为什么呢？</p>
<p>可以分两种情况考虑：</p>
<ol>
<li>堆的最后一个非叶子节点只有左孩子</li>
<li>堆的最后一个非叶子节点有左右两个孩子</li>
</ol>
<p>完全二叉树的性质之一是：如果节点序号为 <code>i</code>，则它的左孩子序号为 <code>2*i+1</code>，右孩子序号为 <code>2*i+2</code>。</p>
<ol>
<li>对于 <code>情况1</code> 左孩子(最后一个元素)的序号为 <code>n-1</code>，则 <code>n-1=2*i+1</code>，推出 <code>i=n/2-1</code>；</li>
<li>对于 <code>情况2</code> 左孩子(倒数第二个元素)的序号为 <code>n-2</code>，则 <code>n-2=2*i+1</code>，推出 <code>i=(n-1)/2-1</code>；右孩子(最后一个元素)的序号为 <code>n-1</code>，则 <code>n-1=2*i+2</code>，推出（这里跟左孩子推出的一样） <code>i=(n-1)/2-1</code>；</li>
</ol>
<p>很显然，当完全二叉树最后一个节点是其父节点的左孩子时，树的节点数（数组元素数）为偶数；当完全二叉树最后一个节点是其父节点的右孩子时（满二叉树），树的节点数（数组元素数）为奇数。</p>
<p>根据一般编程语言的特性，整数除不尽时向下取整，则若 <code>n</code> 为奇数时 <code>(n-1)/2-1=n/2-1</code>。</p>
<p>因此对于 <code>情况2</code> 最后一个非叶子节点的序号也是 <code>n/2-1</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>增大osx启动分区大小</title>
    <url>/2017/11/25/%E5%A2%9E%E5%A4%A7osx%E5%90%AF%E5%8A%A8%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>场景：<br>osx，deepin linux, windows三系统, 需要扩大黑苹果的分区.</p>
<p>osx下的磁盘工具简直不能更难用，有下面几个坑，很重要，要想扩容osx系统分区需要知道这些：</p>
<ul>
<li>不识别空分区，分区必要格式化，否则磁盘工具不识别</li>
<li>必须是系统分区后面的分区才能合并到系统分区里</li>
<li>要合到系统分区的分区必须和系统分区统一格式!!</li>
</ul>
<p>上面三个坑, 尤其是第三个, 搞得我差点重装osx, 磁盘工具竟然不自动格式化分区就直接和osx的系统盘合并了,<br>导致虽然系统盘容量增大了, 但却出现一个分区里却有两块不同格式的磁盘空间, 幸好我记得合并进去的分区是多大,<br>又动手压缩出来了, 然后格式化为osx系统分区格式, 再次合并才成功</p>
<p>osx下的磁盘工具虽然难用, 但是要扩大osx系统分区只能用这个工具, 不像linux或windows可以在livecd或者pe下调整.</p>
<p>正文:<br>草草画了几个图, 当时操作的时候没有截图, 下面这张图是我的硬盘的分区:<br><img src="origin.png" alt="origin"></p>
<p>既然是扩容osx分区, 那就需要从其他分区压缩出来一部分空间, 推荐在linux下使用gparted工具压缩和移动分区,<br>当然windows下也可以, 可以用diskgenius软件操作.<br>我需要从linux分区中压缩出来100G分给osx, 那么我就压缩之后的样子如下图:<br><img src="yasuo.png" alt="yasuo"></p>
<p>虽然压缩出来的空间已经挨着osx的分区了, 但是osx的磁盘工具不能将osx之前的分区合并到osx的系统分区中,<br>所以仅仅是压缩出来是不够的, 还需要将压缩出来的分区移动到osx分区之后, 且紧挨着osx分区, 移动后如下图:<br><img src="yidong.png" alt="yidong"></p>
<p>然后格式化那块压缩出来的空间, 如果gparted或者diskgenius不支持当前osx分区的格式, 那就格式化成fat32格式,<br>格式化完成之后就可以启动到osx系统了, 打开磁盘工具, 将那块压缩出来的分区的格式改成当前osx分区的格式,<br>切记!! 一定要与当前osx分区的格式相同!!<br>然后点击磁盘工具上的‘分区’按钮, 再点击那块格式化好的压缩出来的分区, 再点一下’+‘旁边的’-‘号按钮,<br>也就是删除这个分区, 点击确定就行了, 删除这个分区后磁盘工具就会将其合并到osx的分区了.<br>大功告成, 如下图:<br><img src="zuihou.png" alt="zuihou"></p>
]]></content>
      <categories>
        <category>osx</category>
      </categories>
      <tags>
        <tag>osx</tag>
        <tag>分区</tag>
        <tag>扩容</tag>
      </tags>
  </entry>
  <entry>
    <title>将数据从mysql导入到excel碰到的坑</title>
    <url>/2019/10/10/%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8Emysql%E5%AF%BC%E5%85%A5%E5%88%B0excel%E7%A2%B0%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>记录一些在 windows 下将数据从 mysql 导入到 excel 过程中遇到的坑。首先，这一操作有两种方案：</p>
<ol>
<li>在 navicat 中进行操作，将数据写入到 excel 文件中</li>
<li>在 excel 中进行操作，将数据从 mysql 服务器写入文件</li>
</ol>
<p>第一种方案同事说在数据量很大的时候导出速度很慢，原因不明，我猜测是因为 navicat 使用的 POI 技术实现的功能，没有深究。第二种方案就我进行测试的方案，这种方案至少在速度方面有很明显的提升，下面列一下测试过程中遇到的坑：</p>
<ol>
<li>只能使用 windows 的 office excel，wps 的表格有奇怪的问题无法解决（后来发现是因为系统中没有安装 <code>Visual C++ Redistributable Packages for Visual Studio 2013</code>）</li>
<li>安装 Mysql ODBC 驱动时要注意 excel 的软件位数，如果 excel 是 32 位的，那么 Mysql ODBC 驱动也必须是 32 位的</li>
<li>64 位系统不显示 32 位的 ODBC 驱动，需要手动打开 <code>C:\\Windows\\sysWOW64\\odbcad32.exe</code> 程序添加连接</li>
<li>导入数据时出现错误：<code>MySQL client ran out of memory</code>，调整系统中的数据源(ODBC)中的连接选项，找到并勾选”Do not cache result”之类的选项，应该可以解决</li>
</ol>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类与接口是否可以实例化</title>
    <url>/2016/08/08/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="抽象类与接口简介"><a href="#抽象类与接口简介" class="headerlink" title="抽象类与接口简介"></a>抽象类与接口简介</h1><p>具体的就不说了,直说一下二者的重要的相同点和区别:</p>
<p>相同点:</p>
<ul>
<li>都是抽象的(不能正常实例化的)</li>
<li>都可以有抽象方法</li>
<li>都可以有成员变量</li>
</ul>
<p>区别:</p>
<ul>
<li>抽象类除了不能正常实例化和可以含有抽象方法外其他特性与普通类相同</li>
<li>抽象类既可以有抽象方法也可以有普通的方法,而接口只能包含抽象方法</li>
<li>抽象类可以只声明成员变量而不初始化,接口必须在声明成员方法时初始化</li>
</ul>
<h1 id="不能实例化"><a href="#不能实例化" class="headerlink" title="不能实例化"></a>不能实例化</h1><p>以前我一直认为抽象类和接口是不能被初始化的, 意思就是不能使用<code>new</code>关键字来获取类的实例(接口也算是一个类),如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestInterface inter = <span class="keyword">new</span> TestInterface();</span><br></pre></td></tr></table></figure>
<p>当TestInterface是一个抽象类或者接口时,上述代码将会产生编译时错误.</p>
<p>但是当我在学习鸿洋的一篇关于Android中RecyclerView的博客时发现他对一个接口使用了<code>new</code>关键字<br>原文链接请点击:<a href="http://blog.csdn.net/lmj623565791/article/details/45059587">Android中RecyclerView</a><br>这让我不得不重新思考接口和抽象类到底能否实例化,还是仅仅不能用上述的普通方法来实例化,<br>于是有了下面的一段测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TestInterface inter = <span class="keyword">new</span> TestInterface() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myTestInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;run method myTestInterface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        TestAbstract abs = <span class="keyword">new</span> TestAbstract() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myTestAbstract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;run method myTestAbstract&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        inter.myTestInterface();</span><br><span class="line">        abs.myTestAbstract();</span><br><span class="line">        abs.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       test t = <span class="keyword">new</span> test(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myTestInterface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstract</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">myTestAbstract</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run method print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">run method myTestInterface</span><br><span class="line">run method myTestAbstract</span><br><span class="line">run method print</span><br></pre></td></tr></table></figure>
<p>所以是可以对抽象类和接口使用<code>new</code>关键字的,但是在初始化的时候还是需要去实现抽象类和接口中所定义的抽象方法<br>那么这到底是算是对抽象了和接口实例化了吗?</p>
<h1 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h1><p><strong>以下是个人想法,有待验证,如果错误请指出</strong><br>java之所以不允许以正常方式使用<code>new</code>关键字来实例化抽象类和接口,是因为其中定义了抽象方法,<br>既然有抽象方法,那么即使你获取了抽象类和接口的实例,这些抽象方法也没有具体的实现(方法内容),也是没有意义的.<br>但即使你删除上面测试代码中抽象类所定义的抽象方法<code>myTestAbstract()</code>之后,只保留抽象类的具体方法<code>print()</code>,<br>依然无法对TestAbstract抽象类进行普通实例化,所以java应该是认为只要是抽象类和接口都是不能被正常实例化的.</p>
<p>而上述代码又确实使用<code>new</code>关键字进行了实例化,但是请注意,上述代码在实例化时,<br>实现了抽象类和接口所定义的抽象方法,所以关键字<code>new</code>后面的类型已经不能算是原来的抽象类和接口了,<br>它已经是一个具体的类了,而不是抽象的了,因为原来的抽象类和接口里的抽象方法是没有方法体的,<br>也就是没有具体内容的, 当你在一个”类”中实现了这些抽象方法,那么这个类就已经不是原来的”类”了.<br>所以上述代码之所以能够正常运行,是因为<code>new</code>关键字所获取的类的实例并不是抽象类或接口的实例.<br><strong>因而”抽象类和接口不能被实例化”这句话是正确的</strong><br>所以按照上面测试中的方法对抽象类和接口使用<code>new</code>关键字与上面这句话并不冲突.</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>abstract</tag>
        <tag>iterface</tag>
        <tag>抽象类</tag>
        <tag>接口</tag>
        <tag>实例化</tag>
      </tags>
  </entry>
  <entry>
    <title>指定 git 使用的 ssh 秘钥</title>
    <url>/2019/03/23/%E6%8C%87%E5%AE%9A-git-%E4%BD%BF%E7%94%A8%E7%9A%84-ssh-%E7%A7%98%E9%92%A5/</url>
    <content><![CDATA[<p>目前我遇到的两种需要指定 git 使用的 ssh 秘钥的场景是：</p>
<ul>
<li>git 服务地址不同（一个公司，一个 github）</li>
<li>同一个git 服务地址但账户不同</li>
</ul>
<p>下面分开介绍。</p>
<h1 id="服务地址不同"><a href="#服务地址不同" class="headerlink" title="服务地址不同"></a>服务地址不同</h1><p>这估计是大多数人遇到的场景，同一个笔记本电脑，有时需要向公司的 git 服务推送代码，有时要向 github 推送代码，当然也可选择在两个不同的服务器上部署自己相同的公钥，但当无法做到这一情况时就要给 git 或者说给 ssh 命令指定哪个服务地址使用哪个秘钥。</p>
<p>首先生成两套秘钥即四个文件，两对公、私秘钥，具体的生成方法这里就不赘述了，不过要注意在生成第二套私钥时需要指定文件名称，否则将覆盖默认秘钥，一般秘钥文件存储在 <code>~/.ssh</code> 目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id_rsa</span><br><span class="line">id_rsa.pub</span><br><span class="line">id_rsa_company</span><br><span class="line">id_rsa_company.pub</span><br></pre></td></tr></table></figure>

<p>以 <code>.pub</code> 结尾的文件为公钥，需要将其部署在服务端，比如 <code>id_rsa.pub</code> 部署在 github 上，<code>id_rsa_company.pub</code> 部署在公司的服务上，<code>id_rsa</code> 则是 ssh 命令也是 git 命令使用的默认的私钥，当秘钥文件生成完成后使用以下命令将用于公司的<strong>私钥</strong>添加到 ssh-agent 中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_ras_company</span><br></pre></td></tr></table></figure>

<p>添加完成后可以查看已经添加过的私钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure>

<p>如果默认私钥没有被添加进来则手动按照上面的命令添加。</p>
<p>现在私钥已经在本地部署了，接着配置 ssh 让其针对不同的服务器使用不同的私钥进行认证，在 <code>~/.ssh</code>目录下创建或编辑 <code>config</code> 文件，假设公司的 git 服务地址为 <code>git.company.com</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host git.company.com</span><br><span class="line">   User git</span><br><span class="line">   IdentityFile ~&#x2F;.ssh&#x2F;id_ras_company</span><br><span class="line">   IdentitiesOnly yes</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">   User git</span><br><span class="line">   IdentityFile ~&#x2F;.ssh&#x2F;id_ras</span><br><span class="line">   IdentitiesOnly yes</span><br></pre></td></tr></table></figure>

<p>内容很简单，分为两组第一组用于公司的 git 服务，第二组用于 github 的 git 服务。</p>
<h1 id="账户不同"><a href="#账户不同" class="headerlink" title="账户不同"></a>账户不同</h1><p>网上搜到的大多数配置 git 使用的秘钥的文章都是在说上面的那种情况，现假设我在 github 上有两个账户，同一个公钥文件无法同时部署在两个账户上，这就要用这个方法了，不过需要注意的是这种方法只是针对项目或者说本地仓库配置的，还是类似与上一个情况，在 <code>~/.ssh</code> 目录下生成两套秘钥：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id_rsa</span><br><span class="line">id_rsa.pub</span><br><span class="line">id_rsa_other</span><br><span class="line">id_rsa_other.pub</span><br></pre></td></tr></table></figure>

<p>同样要将这两套秘钥添加到 ssh-agent 中，具体方法参见上一场景的介绍。</p>
<p>第一套 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 中的公钥假设已经在 github 主账户上使用了，现在我有了另一个账户 <code>other</code>，<code>id_rsa_other</code> 和 <code>id_rsa_other.pub</code> 给 <code>other</code> 账户使用，首先将公钥 <code>id_rsa_other.pub</code> 部署在 other 这个账户下。</p>
<p>主账户的配置自不必说，主账户的本地仓库不做任何配置，依旧使用默认的那套秘钥，要做的是在 other 账户的本地仓库中进行配置，例如 other 账户有一个本地仓库 <code>other-repo</code>,在仓库目录下编辑 <code>other-repo/.git/config</code> 文件，注意是仓库目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">    sshCommand &#x3D; ssh -i &#x2F;home&#x2F;ri&#x2F;.ssh&#x2F;id_rsa_other</span><br></pre></td></tr></table></figure>

<p>即在 <code>[core]</code> 这一组配置中，添加一个配置项：<code>sshCommand</code>，其目的是指定 git 命令使用的 ssh 命令，ssh 命令可以使用 <code>-i</code> 参数指定要使用的私钥，这里使用加上了 <code>-i</code> 参数的 ssh 命令代替默认的 ssh 命令，配置到这里就结束了。</p>
<h1 id="配置-git-本地账户"><a href="#配置-git-本地账户" class="headerlink" title="配置 git 本地账户"></a>配置 git 本地账户</h1><p>网上关于指定 git 使用的秘钥的文章都会提到使用如下命令配置一下 git 本地账户的名字和邮件地址，其实这个不是必须的，这个只是在 git commit 历史中显示的账户，当然，在 github 上也会关联到相应的 github 账户，如果你想要两套秘钥的提交历史显示的是同一个账户所做的提交就不用单独配置本地 git 账户和邮件地址，使用默认的即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在某个仓库目录下执行，只设置单个仓库中的本地账户</span><br><span class="line"># 配置文件在仓库目录下的 .git&#x2F;config</span><br><span class="line">git config user.name UserName</span><br><span class="line">git config user.email User@email.com</span><br><span class="line"></span><br><span class="line"># 在任意位置执行，加上 --global 参数即会设置默认本地账户</span><br><span class="line"># 配置文件在 HOME 目录下的 ~&#x2F;.git&#x2F;config 也可在 ~&#x2F;.config&#x2F;git&#x2F;config</span><br><span class="line">git config --global user.name UserName</span><br><span class="line">git config --global user.email User@email.com</span><br></pre></td></tr></table></figure>

<p>如果需要在特定的仓库中使用不用于默认本地账户的账户，则使用上述命令中的第一组命令，在特定仓库目录下执行即可。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>key</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>搞明白android中layout_weight的用法</title>
    <url>/2017/09/15/%E6%90%9E%E6%98%8E%E7%99%BDandroid%E4%B8%ADlayout-weight%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>本文是学习这篇博客所得的收获:<br><a href="http://mobile.51cto.com/abased-375428.htm"> Android：Layout_weight的深刻理解</a></p>
</blockquote>
<p>当子控件有<code>layout_weight</code>属性时, 系统将先按照<code>layout_width</code>或<code>layout_hight</code>属性<br>先把子控件放到父控件中, 之后才解析<code>layout_weight</code>属性, 然后计算父控件中的剩余空间,<br>最后按比例分配剩余空间给子控件.</p>
<p>看一下处理<code>layout_weight</code>时所用到的公式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 实际尺寸: 子控件最终展示出来的尺寸</span><br><span class="line"># 当前尺寸: 子控件刚被放到布局中, 系统还没有解析其weight属性时的尺寸</span><br><span class="line"># weight比例: 子控件在所有有&#96;layout_weight&#96;属性的控件中所占的比例</span><br><span class="line">#             (例: 三个子控件, 第一个比重为1, 第二个为2, 第三个为2,</span><br><span class="line">#              那么第一个所占比例为1&#x2F;5, 第二个为2&#x2F;5, 第三个为2&#x2F;5)</span><br><span class="line"># 剩余空间: 子控件刚被放到父控件中, 系统还没有解析其weight属性时父控件还有多少剩余空间</span><br><span class="line"></span><br><span class="line">剩余空间 &#x3D; 父控件尺寸 - 子控件1尺寸 - 子控件2尺寸 - 子控件3尺寸...</span><br><span class="line">实际尺寸 &#x3D; 当前尺寸 + weight比例 * 剩余空间尺寸</span><br></pre></td></tr></table></figure>
<p>当控件的<code>layout_width</code>以及<code>layout_hight</code>的值为<code>0</code>或者<code>wrap_content</code>时,<br><code>layout_weight</code>属性很容易预测最终效果, 它们会按照自己的<code>weight比例</code>去<br>分配<code>剩余空间尺寸</code>.</p>
<p>需要留意的是当控件的<code>layout_width</code>或<code>layout_hight</code>的值为<code>fill_parent</code>的时候,<br>此时每个子控件在刚被放到父控件中, 且系统还没有解析子控件的<code>layout_weight</code>时,<br>父控件就已经没有剩余空间了,<br><font color=red><br>因为此时所有子控件的当前尺寸都等于父控件的尺寸, 且第一个子控件就已经占满了父控件!<br></font></p>
<p>那么套用上述公式, 计算子控件最终实际尺寸的过程如下:</p>
<blockquote>
<p>下面假设一个父控件中有三个子控件, 其比重为1 : 2 : 3,<br>则子控件的<code>weight比例</code>依次为<code>1/6</code>, <code>2/6</code>, <code>3/6</code></p>
</blockquote>
<p>剩余空间的计算如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">剩余空间 &#x3D; 父控件尺寸 - 子控件1当前尺寸 - 子控件2当前尺寸 - 子控件3当前尺寸</span><br><span class="line"># 上述等同于:</span><br><span class="line">剩余空间 &#x3D; 父控件尺寸 - 父控件尺寸 - 父控件尺寸 - 父控件尺寸</span><br><span class="line"># 则(注意是负2):</span><br><span class="line">剩余空间 &#x3D; -2 * 父控件尺寸</span><br></pre></td></tr></table></figure>

<p>子控件最终实际尺寸的计算如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实际尺寸 &#x3D; 当前尺寸 + weight比例 * 剩余空间尺寸</span><br><span class="line"># 子控件1:</span><br><span class="line">实际尺寸 &#x3D; 父控件尺寸 + 1&#x2F;6 * (-2 * 父控件尺寸)</span><br><span class="line">        &#x3D; 父控件尺寸 - 2&#x2F;6 * 父控件尺寸</span><br><span class="line">        &#x3D; 4&#x2F;6 * 父控件尺寸</span><br><span class="line">        &#x3D; 2&#x2F;3 * 父控件尺寸</span><br><span class="line"></span><br><span class="line"># 子控件2:</span><br><span class="line">实际尺寸 &#x3D; 父控件尺寸 + 2&#x2F;6 * (-2 * 父控件尺寸)</span><br><span class="line">        &#x3D; 父控件尺寸 - 4&#x2F;6 * 父控件尺寸</span><br><span class="line">        &#x3D; 2&#x2F;6 * 父控件尺寸</span><br><span class="line">        &#x3D; 1&#x2F;3 * 父控件尺寸</span><br><span class="line"></span><br><span class="line"># 子控件3:</span><br><span class="line">实际尺寸 &#x3D; 父控件尺寸 + 3&#x2F;6 * (-2 * 父控件尺寸)</span><br><span class="line">        &#x3D; 父控件尺寸 - 6&#x2F;6 * 父控件尺寸</span><br><span class="line">        &#x3D; 父控件尺寸 - 父控件尺寸</span><br><span class="line">        &#x3D; 0</span><br></pre></td></tr></table></figure>
<p><strong><em>所以此时子控件3将会消失, 不会显示在屏幕上.</em></strong></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>layout_weight</tag>
        <tag>linearlayout</tag>
      </tags>
  </entry>
  <entry>
    <title>水平与垂直 拆分与扩展 数据库与分布式</title>
    <url>/2020/09/24/%E6%B0%B4%E5%B9%B3%E4%B8%8E%E5%9E%82%E7%9B%B4-%E6%8B%86%E5%88%86%E4%B8%8E%E6%89%A9%E5%B1%95-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<p>标题写出来后发现覆盖面有点大，其实要说的只是字面意义上的一点学习小结：</p>
<p>数据库优化：<br>水平分库，水平分表，使各个库/表的<strong>结构相同，但内容不同</strong><br>垂直分库，垂直分表，使各个库/表的<strong>结构不同，且内容不同</strong><br>库的结构可以理解为包含了哪些表<br>表的结构可以理解为包含了哪些字段<br>在垂直拆分的基础上，可以进一步水平拆分</p>
<p>分布式优化：<br>水平扩展，增加更多节点以达到整体性能增强<br>垂直扩展，增强单机配置以达到单点性能增强，进而达到整体性能增强<br>水平扩展优点更多，使用得当的话，对整个系统的可用性，负载均衡都有益处</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>测试网站是否能被百度蜘蛛抓取</title>
    <url>/2016/07/01/%E6%B5%8B%E8%AF%95%E7%BD%91%E7%AB%99%E6%98%AF%E5%90%A6%E8%83%BD%E8%A2%AB%E7%99%BE%E5%BA%A6%E8%9C%98%E8%9B%9B%E6%8A%93%E5%8F%96/</url>
    <content><![CDATA[<p>只需要使用curl命令配合一些参数就可以测试了,看返回内容就知道能否抓取了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用PC的UA来抓取</span></span><br><span class="line">curl -A <span class="string">&quot;Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&quot;</span> http://listenerri.com</span><br><span class="line"><span class="comment"># 用移动UA来抓取</span></span><br><span class="line">curl -A <span class="string">&quot;Mozilla/5.0 (Linux;u;Android 4.2.2;zh-cn;) AppleWebKit/534.46 (KHTML,like Gecko) Version/5.1 Mobile Safari/10600.6.3 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html）&quot;</span> http://listenerri.com</span><br></pre></td></tr></table></figure>
<p>下面两张图是我测试正常的,第一张是上述命令返回的开始部分,第二张是上述命令返回的结束部分:<br><img src="spider1.png" alt="开始"><br><img src="spider2.png" alt="结束"></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>seo</tag>
        <tag>蜘蛛</tag>
        <tag>百度</tag>
      </tags>
  </entry>
  <entry>
    <title>源码构建qtcreator记录</title>
    <url>/2019/02/24/%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BAqtcreator%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>在 deepin linux 系统下编译 qtcreator 4.8.0 版本，可是按照官方 README 却始终编译不通过，遇到了以下几个问题，并列出了相关解决方案。当然官方的 README 上所说的编译依赖还是要装上的。</p>
<h1 id="问题0"><a href="#问题0" class="headerlink" title="问题0"></a>问题0</h1><blockquote>
<p>这个可能不是必须的</p>
</blockquote>
<p><strong>不要在源码目录下建立 build/build-debug/build-release 之类的构建目录, 否则会出现一些奇奇怪怪的问题, 导致编译失败</strong></p>
<p>只需要直接在源码根目录下执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 仅供参考</span><br><span class="line">qmake</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -Wl,-z,origin &#39;-Wl,-rpath,$ORIGIN:$ORIGIN&#x2F;..:$ORIGIN&#x2F;..&#x2F;lib&#x2F;qtcreator&#39; -Wl,--no-undefined -Wl,-z,origin -Wl,-rpath,&#x2F;usr&#x2F;lib&#x2F;llvm-7&#x2F;lib -Wl,--exclude-libs,ALL -Wl,-O1 -shared -Wl,-soname,libClangFormat.so -o libClangFormat.so .obj&#x2F;release-shared&#x2F;clangformatconfigwidget.o .obj&#x2F;release-shared&#x2F;clangformatindenter.o .obj&#x2F;release-shared&#x2F;clangformatplugin.o .obj&#x2F;release-shared&#x2F;clangformatutils.o .obj&#x2F;release-shared&#x2F;moc_clangformatconfigwidget.o .obj&#x2F;release-shared&#x2F;moc_clangformatplugin.o  -L&#x2F;home&#x2F;ri&#x2F;coding&#x2F;qt-creator&#x2F;lib&#x2F;qtcreator -L&#x2F;home&#x2F;ri&#x2F;coding&#x2F;qt-creator&#x2F;lib&#x2F;qtcreator&#x2F;plugins -lCppTools -lProjectExplorer -lTextEditor -lCore -lCPlusPlus -lQtcSsh -lAggregation -lExtensionSystem -lUtils -L&#x2F;usr&#x2F;lib&#x2F;llvm-7&#x2F;lib -lclangFormat -lclangToolingInclusions -lclangToolingCore -lclangRewrite -lclangLex -lclangBasic -lLLVM-7 -lQt5Widgets -lQt5Gui -lQt5Concurrent -lQt5Network -lQt5Core -lGL -lpthread  </span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ld: 找不到 -lclangToolingInclusions</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make[3]: *** [Makefile:286：..&#x2F;..&#x2F;..&#x2F;lib&#x2F;qtcreator&#x2F;plugins&#x2F;libClangFormat.so] 错误 1</span><br></pre></td></tr></table></figure>

<p>报错里提到找不到 <code>clangToolingInclusions</code> 这个库文件, 根据 <code>-L/usr/lib/llvm-7/lib</code> 可知构建系统要在这个目录下找, 尝试了以下三个方法:</p>
<ol>
<li>手动进入此目录搜索的确没有找到</li>
<li>故而又在 <code>/usr/lib</code> 目录搜索依然没有</li>
<li>接着使用 <code>apt-file search clangToolingInclusions</code> 命令搜索看是不是因为某个包没装, 结果依然没有</li>
</ol>
<p>这就奇怪了, 难道是 debian 系的系统中没有这个库文件吗? 被改名了?</p>
<p>ag clangToolingInclusions</p>
<p>src/shared/clang/clang_installation.pri 文件中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!isEmpty(LLVM_VERSION) &#123;</span><br><span class="line">    versionIsAtLeast($$LLVM_VERSION, 7, 0, 0): &#123;</span><br><span class="line">        CLANGFORMAT_LIBS&#x3D;-lclangFormat -lclangToolingInclusions -lclangToolingCore -lclangRewrite -lclangLex -lclangBasic</span><br><span class="line">        win32:CLANGFORMAT_LIBS +&#x3D; -lversion</span><br><span class="line">    &#125; else:versionIsAtLeast($$LLVM_VERSION, 6, 0, 0): &#123;</span><br><span class="line">        CLANGFORMAT_LIBS&#x3D;-lclangFormat -lclangToolingCore -lclangRewrite -lclangLex -lclangBasic</span><br><span class="line">        win32:CLANGFORMAT_LIBS +&#x3D; -lversion</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除7.0 clang llvm</p>
<p>创建6.0链接</p>
<p>  Reading /home/ri/coding/qt-creator/src/plugins/clangformat/clangformat.pro<br>sh: 1: llvm-config: not found<br>Project WARNING: Cannot determine clang version. Set LLVM_INSTALL_DIR to build the Clang Code Model<br>Project file(clangformat.pro) not recursed because all requirements not met:<br>    !isEmpty(CLANGFORMAT_LIBS)</p>
<p>搞完才发现:</p>
<blockquote>
<h3 id="Get-LLVM-Clang-for-the-Clang-Code-Model"><a href="#Get-LLVM-Clang-for-the-Clang-Code-Model" class="headerlink" title="Get LLVM/Clang for the Clang Code Model"></a>Get LLVM/Clang for the Clang Code Model</h3><p>The Clang Code Model depends on the LLVM/Clang libraries. The currently supported LLVM/Clang version is 6.0.</p>
</blockquote>
<h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In file included from source&#x2F;collectbuilddependencyaction.h:28:0,</span><br><span class="line">                 from source&#x2F;collectbuilddependencytoolaction.h:28,</span><br><span class="line">                 from source&#x2F;builddependencycollector.cpp:28:</span><br><span class="line">source&#x2F;collectbuilddependencypreprocessorcallbacks.h:88:10: error: ‘void ClangBackEnd::CollectBuildDependencyPreprocessorCallbacks::InclusionDirective(clang::SourceLocation, const clang::Token&amp;, llvm::StringRef, bool, clang::CharSourceRange, const clang::FileEntry*, llvm::StringRef, llvm::StringRef, const clang::Module*, clang::SrcMgr::CharacteristicKind)’ marked ‘override’, but does not override</span><br><span class="line">     void InclusionDirective(clang::SourceLocation hashLocation,</span><br></pre></td></tr></table></figure>

<p>目录: qt-creator/src/tools/clangpchmanagerbackend</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InclusionDirective(clang::SourceLocation hashLocation,</span><br><span class="line">                        const clang::Token &amp; &#x2F;*includeToken*&#x2F;,</span><br><span class="line">                        llvm::StringRef &#x2F;*fileName*&#x2F;,</span><br><span class="line">                        bool &#x2F;*isAngled*&#x2F;,</span><br><span class="line">                        clang::CharSourceRange &#x2F;*fileNameRange*&#x2F;,</span><br><span class="line">                        const clang::FileEntry *file,</span><br><span class="line">                        llvm::StringRef &#x2F;*searchPath*&#x2F;,</span><br><span class="line">                        llvm::StringRef &#x2F;*relativePath*&#x2F;,</span><br><span class="line">                        const clang::Module * &#x2F;*imported*&#x2F;,</span><br><span class="line">                        clang::SrcMgr::CharacteristicKind fileType) override</span><br></pre></td></tr></table></figure>

<p>移除 override</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>qtcreator</tag>
        <tag>build</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树-区间树-范围树-二叉索引树</title>
    <url>/2020/04/02/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%8C%BA%E9%97%B4%E6%A0%91-%E8%8C%83%E5%9B%B4%E6%A0%91-%E4%BA%8C%E5%8F%89%E7%B4%A2%E5%BC%95%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>原文：<a href="https://stackoverflow.com/a/17504505">https://stackoverflow.com/a/17504505</a></p>
</blockquote>
<p>中英对照：</p>
<ul>
<li>Segment tree 线段树</li>
<li>Interval tree 区间树</li>
<li>Range tree 范围树</li>
<li>Binary indexed tree 二叉索引树</li>
</ul>
<p>主要用于解决的问题：</p>
<ul>
<li>Segment tree 存储区间，查询哪些区间包含给定的点</li>
<li>Interval tree 存储区间，查询哪些区间与给定区间相交，也支持点查询（Segment tree）</li>
<li>Range tree 存储点，查询哪些点落在了给定区间</li>
<li>Binary indexed tree 存储每个索引的项目数，查询索引 m 和 n 之间有多少个项目</li>
</ul>
<p>性能（k 是结果数）：</p>
<ul>
<li>Segment tree O(n logn) 预处理时间，O(k+logn) 查询，O(n logn) 空间</li>
<li>Interval tree O(n logn) 预处理时间，O(k+logn) 查询，O(n) 空间</li>
<li>Range tree O(n logn) 预处理时间，O(k+logn) 查询，O(n) 空间</li>
<li>Binary indexed tree O(n logn) 预处理时间，O(logn) 查询，O(n) 空间</li>
</ul>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>segment</tag>
        <tag>interval</tag>
        <tag>range</tag>
      </tags>
  </entry>
  <entry>
    <title>终于发现了素数的一种用途</title>
    <url>/2019/10/21/%E7%BB%88%E4%BA%8E%E5%8F%91%E7%8E%B0%E4%BA%86%E7%B4%A0%E6%95%B0%E7%9A%84%E4%B8%80%E7%A7%8D%E7%94%A8%E9%80%94/</url>
    <content><![CDATA[<p>以前只知道素数的定义：<code>质数又称素数。一个大于 1 的自然数，除了 1 和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数</code>。今天在学习<a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/Readme.md">《编程之法》(github) </a>时，第一章第二节 <a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/01.02.md">“字符串包含”</a>，其提到的一种算法用到了素数，在此仅摘取原文部分内容作为记录。<strong>需要注意的是，这种算法并不是这个问题的最优解</strong>，具体请查看原文。</p>
<p>以下为原文摘录：</p>
<hr>
<p><strong>字符串包含</strong></p>
<p>题目描述：<br>给定两个分别由字母组成的字符串 A 和字符串 B，字符串 B 的长度比字符串 A 短。请问，如何最快地判断字符串 B 中所有字母是否都在字符串 A 里？</p>
<p>为了简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数 <code>bool StringContains(string &amp;A, string &amp;B)</code></p>
<p>比如，如果是下面两个字符串：</p>
<p>String 1：ABCD</p>
<p>String 2：BAD</p>
<p>答案是 true，即 String2 里的字母在 String1 里也都有，或者说 String2 是 String1 的真子集。</p>
<p>如果是下面两个字符串：</p>
<p>String 1：ABCD</p>
<p>String 2：BCE</p>
<p>答案是 false，因为字符串 String2 里的 E 字母不在字符串 String1 里。</p>
<p>同时，如果 string1：ABCD，string 2：AA，同样返回 true。</p>
<p>……此处省略部分内容……</p>
<p><strong>解法三</strong></p>
<p>有没有比快速排序更好的方法呢？</p>
<p>我们换一种角度思考本问题：</p>
<p>假设有一个仅由字母组成字串，让每个字母与一个素数对应，从 2 开始，往后类推，A 对应 2，B 对应 3，C 对应 5，……。遍历第一个字串，把每个字母对应素数相乘。最终会得到一个整数。</p>
<p>利用上面字母和素数的对应关系，对应第二个字符串中的字母，然后轮询，用每个字母对应的素数除前面得到的整数。如果结果有余数，说明结果为 false。如果整个过程中没有余数，则说明第二个字符串是第一个的子集了（判断是不是真子集，可以比较两个字符串对应的素数乘积，若相等则不是真子集）。</p>
<p>思路总结如下：</p>
<ol>
<li>按照从小到大的顺序，用26个素数分别与字符’A’到’Z’一一对应。</li>
<li>遍历长字符串，求得每个字符对应素数的乘积。</li>
<li>遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。</li>
<li>输出结果。</li>
</ol>
<p>如前所述，算法的时间复杂度为 O(m+n) 的最好的情况为 O(n)（遍历短的字符串的第一个数，与长字符串素数的乘积相除，即出现余数，便可退出程序，返回 false），n 为长字串的长度，空间复杂度为O(1)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;此方法只有理论意义，因为整数乘积很大，有溢出风险</span><br><span class="line">bool StringContain(string &amp;a,string &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    const int p[26] &#x3D; &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,61, 67, 71, 73, 79, 83, 89, 97, 101&#125;;</span><br><span class="line">    int f &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; a.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int x &#x3D; p[a[i] - &#39;A&#39;];</span><br><span class="line">        if (f % x)</span><br><span class="line">        &#123;</span><br><span class="line">            f *&#x3D; x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; b.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int x &#x3D; p[b[i] - &#39;A&#39;];</span><br><span class="line">        if (f % x)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此种素数相乘的方法看似完美，但缺点是素数相乘的结果容易导致整数溢出。</p>
<p>……此处省略部分内容……</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>素数</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义bash终端提示符</title>
    <url>/2016/05/04/%E8%87%AA%E5%AE%9A%E4%B9%89bash%E7%BB%88%E7%AB%AF%E6%8F%90%E7%A4%BA%E7%AC%A6/</url>
    <content><![CDATA[<blockquote>
<p>新增第三种，推荐使用</p>
</blockquote>
<h1 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h1><p>可以提示上一条命令是否出错，如果出错，最左边绿色的笑脸就会变成红色的哭脸，可以显示当前所在路径，当切换到root用户时用户名变为红色，如图所示:</p>
<p><img src="shell.png" alt="shell"></p>
<p>使用方法，将下面的代码，复制粘贴到~/.bashrc中:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bash prompt by listenerri</span></span><br><span class="line">PS1=<span class="string">&quot;\$(if [[ \$? == 0 ]]; then echo \&quot;\[\e[1;32m\] :)\&quot;; else echo \&quot;\[\e[1;31m\] :(\&quot;; fi) <span class="subst">$(if [[ $&#123;EUID&#125; == 0 ]]; then echo <span class="string">&quot;\[\e[1;31m\]\u \[\e[1;32m\]\w \[\e[1;33m\]# &gt; &quot;</span>; else echo <span class="string">&quot;\[\e[1;36m\]\u \[\e[1;32m\]\w \[\e[1;33m\]$ &gt; &quot;</span>; fi)</span>\[\e[0m\]&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h1><p>与第一种不同的是去掉了最右边的箭头，并且’$’和’#’号会随着用户名的颜色变化(root时为红色)</p>
<ul>
<li>新增提示git仓库分支名称:</li>
<li>如果当前目录是git仓库的根目录，则以黄色的文字显示当前仓库的分支，否则不显示</li>
</ul>
<p>如图所示:<br><img src="prompt.png" alt="prompt"></p>
<p>使用方法，将下面的代码，复制粘贴到~/.bashrc中:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bash prompt by listenerri</span></span><br><span class="line">PS1=<span class="string">&#x27;$(if [[ $? == 0 ]]; then echo &quot;\[\e[1;32m\]:) &quot;; else echo &quot;\[\e[1;31m\]:( &quot;; fi)$(if [[ $&#123;EUID&#125; == 0 ]]; then echo &quot;\[\e[1;31m\]\u &quot;; else echo &quot;\[\e[1;36m\]\u &quot;; fi)$(echo &quot;\[\e[1;32m\]\w &quot;)$(if [[ -d .git ]]; then echo &quot;\[\e[1;33m\](`git status | head -n 1 | grep -o &quot;\b\S*$&quot;`) &quot;; fi)$(if [[ $&#123;EUID&#125; == 0 ]]; then echo &quot;\[\e[1;31m\]\$ &quot;; else echo &quot;\[\e[1;36m\]\$ &quot;; fi)\[\e[0m\]&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>arch wiki自定义教程链接：<br><a href="https://wiki.archlinux.org/index.php/Color_Bash_Prompt">https://wiki.archlinux.org/index.php/Color_Bash_Prompt</a></p>
</blockquote>
<h1 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h1><p>时隔两年再次有了新需求，第二种 git 提示获取的方法会导致卡顿，另外还想在提示符上显示时间，但是这样一来就会导致提示符过长，因此有了下面这种换行的：</p>
<p><img src="third.png" alt="third"></p>
<p>使用方法，首先在终端中执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type __git_ps1</span><br></pre></td></tr></table></figure>

<p>如果没有任何输出，或者输出内容不是一个 shell 函数，那么需要下载这个脚本：<a href="https://raw.githubusercontent.com/listenerri/dotfiles/master/git-prompt.sh">https://raw.githubusercontent.com/listenerri/dotfiles/master/git-prompt.sh</a>，例如将其放在 HOME 目录下：<code>~/git-prompt.sh</code>，然后在 ~/.bashrc 中添加以下内容执行此脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;git-prompt.sh</span><br></pre></td></tr></table></figure>

<p><code>__git_ps1</code> 是一个 git 新版提供的函数，旧版本的 git 没有，因此需要下载并加载上面这个脚本，这个脚本是我从系统中提取出来的，未做任何修改。</p>
<p>接着将下面的代码，复制粘贴到 ~/.bashrc 中，并且要在上面那行之后，如果你不需要执行第二部下载那个脚本，则下面的内容放在哪里都行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GIT_PS1_SHOWDIRTYSTATE&#x3D;1</span><br><span class="line">export GIT_PS1_SHOWUNTRACKEDFILES&#x3D;1</span><br><span class="line">PS1&#x3D;&#39;$(</span><br><span class="line">if [[ $? &#x3D;&#x3D; 0 ]]; then</span><br><span class="line">    echo -n &quot;\[\e[1;32m\]:)&quot;;</span><br><span class="line">else</span><br><span class="line">    echo -n &quot;\[\e[1;31m\]:(&quot;;</span><br><span class="line">fi</span><br><span class="line">) \u@\H \D&#123;(%c)&#125;\n\[\e[1;36m\]\w\[\e[1;33m\]$(__git_ps1 &quot; (%s)&quot;) $(</span><br><span class="line">if [[ $&#123;EUID&#125; &#x3D;&#x3D; 0 ]]; then</span><br><span class="line">    echo -n &quot;\[\e[1;31m\]&quot;;</span><br><span class="line">else</span><br><span class="line">    echo -n &quot;\[\e[1;36m\]&quot;;</span><br><span class="line">fi</span><br><span class="line">)\$ \[\e[0m\]&#39;</span><br></pre></td></tr></table></figure>

<p>另外需要启用 bash-completion 即 bash 的补全功能，这个一般都会启用的。</p>
<p>推荐下我的 dotfiles 项目：<a href="https://github.com/listenerri/dotfiles">https://github.com/listenerri/dotfiles</a>，里面或许有能让你有其他灵感的内容。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>提示符</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 gradle 下载不下来</title>
    <url>/2021/08/13/%E8%A7%A3%E5%86%B3-gradle-%E4%B8%8B%E8%BD%BD%E4%B8%8D%E4%B8%8B%E6%9D%A5/</url>
    <content><![CDATA[<p>有时候由于网络问题，会发现 android-studio 或 idea 下载不懂 gradle，可以修改 <code>gradle-wrapper.properties</code> 配置文件中的 <code>distributionUrl</code> 选项来解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">distributionUrl&#x3D;https\:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;gradle&#x2F;gradle-5.1.1-all.zip</span><br></pre></td></tr></table></figure>

<p>这个选项表示从腾讯提供的 gradle 镜像服务下载数据，注意替换上面示例链接末尾的具体文件名。</p>
<p>可以访问此链接查看有哪些版本的 gradle 可以下载：<a href="https://mirrors.cloud.tencent.com/gradle/">https://mirrors.cloud.tencent.com/gradle/</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>android-studio</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>解决安卓屏幕旋转所带来的问题</title>
    <url>/2016/06/30/%E8%A7%A3%E5%86%B3%E5%AE%89%E5%8D%93%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="为什么屏幕旋转会带来问题"><a href="#为什么屏幕旋转会带来问题" class="headerlink" title="为什么屏幕旋转会带来问题"></a>为什么屏幕旋转会带来问题</h1><p>在屏幕旋转时,系统会销毁当前活动的activity,并在旋转后重新创建一个新的activity,<br>那么旋转前activity中的一些数据就会丢失.所以只要找到一个方法能实现旋转前保存某些数据,<br>并在新创建的activity中可以取出之前保存的数据,也就解决了这个问题.</p>
<p>然而保存数据并不是万能的,有些操作是不能中断的,比如播放音乐,这就要用到另一种方法.</p>
<h1 id="两个不同的例子"><a href="#两个不同的例子" class="headerlink" title="两个不同的例子"></a>两个不同的例子</h1><h2 id="场景一-答题"><a href="#场景一-答题" class="headerlink" title="场景一:答题"></a>场景一:答题</h2><p>当用户正在回答一些题目,每回答完一道题就保存用户填写的信息到文件中并切换出下一道题的view,此时如果旋转了屏幕,<br>那么旋转后标志用户正在填写哪一道题的对象就会丢失,而不得不从第一题重来.<br>这种场景适合使用<code>OnSaveInstanceState(Bundle savedInstanceState)</code>方式来解决,使用方法很简单,<br>只需要在activity中重写上述方法即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSaveInstanceState</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这一句应该保留,因为这个方法默认是有一些行为的</span></span><br><span class="line">    <span class="keyword">super</span>.OnSaveInstanceState(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是我们重写新增的需要保存的数据</span></span><br><span class="line">    <span class="comment">//使用Bundle的savedInstanceState对象来存数数据</span></span><br><span class="line">    <span class="comment">//比如上述场景需要保存一个标志题号的数据:&quot;index&quot;</span></span><br><span class="line">    savedInstanceState.putInt(<span class="string">&quot;index&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//也就是以键值对的形式保存int型数据`5`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后在<code>onCreate</code>方法中取出这个保存的数据即可.</p>
<blockquote>
<p>需要注意的是我们在Bundle中保存的只能是基本数据类型以及可以实现Serializable接口的对象,<br>也就是说如果需要保存一个类的对象时,需要让这个类实现Serializable接口.</p>
</blockquote>
<h2 id="场景二-播放音乐"><a href="#场景二-播放音乐" class="headerlink" title="场景二:播放音乐"></a>场景二:播放音乐</h2><p>上面那个重写<code>OnSaveInstanceState(Bundle savedInstanceState)</code>的解决方法即使用于activity也适用于fragment,<br>虽然能恢复旋转前的数据,但由于被销毁了,终究是会中断一段时间的,如果当前activity或fragment的作用是<br>播放音乐,即便可以实现旋转后恢复播放进度,但仍就会停顿一下,这太影响用户体验了.<br>所以也就有了这个场景二,这个方法<font color=red>只适用于fragment</font>,这个方法使得这个fragment在屏幕旋转时<br>被保留下来,不会销毁它,那么这个fragment的一些成员变量就都不会丢失了,并且在屏幕旋转期间依旧继续工作.<br>在本例中保留这个fragment就可以使得它的成员变量MediaPlayer的实例一直存在并正常工作.<br>要想保留一个fragment只需要在fragment的onCreate方法中添加一行代码即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setRetainInstance(true);</span><br></pre></td></tr></table></figure>
<p>默认情况下上述方法的参数为false,也就是说默认情况下fragment会被销毁并重建.<br>保留的fragment利用了这样一个事实:<br><strong>可以销毁和重建fragment的视图,但无需销毁fragment自身</strong><br>fragment都是由fragmentManager管理的,在设备旋转时fragmentManager总是销毁fragment的视图,<br>因为需要根据设备的属性重新配置视图,但在尝试销毁fragment前会检测上述方法的参数,<br>如果为true则不销毁这个fragment,当托管这个fragment的activity重建后fragmentManager就找到未消毁的fragment<br>并为它生成新的视图;反之销毁,并重建视图和fragment.<br>也就是说这个fragment有一段时间是没有任何activity来托管它的,<br>需要注意的是<strong>这段时间非常短暂!</strong>,而且如果在这段时间内,系统需要回收内存那么就会销毁掉这个fragment.</p>
<h1 id="两种方法的主要区别"><a href="#两种方法的主要区别" class="headerlink" title="两种方法的主要区别"></a>两种方法的主要区别</h1><blockquote>
<p>第一种方法: OnSaveInstanceState(Bundle savedInstanceState)<br>第二种方法: setRetainInstance(true)</p>
</blockquote>
<ul>
<li><p>第一种方法</p>
<ul>
<li>既可以用于activity,也可以用于fragment</li>
<li>主要用于保存和恢复应用的UI状态</li>
<li>只能存储基本类型数据或以实现Serializable接口的类</li>
</ul>
</li>
<li><p>第二种方法</p>
<ul>
<li>只能用于fragment</li>
<li>数据保存较时间第一种方法短,并且有可能被系统回收内存时销毁</li>
<li>由于保存对象时fragment所以无需关心fragment中数据的类型和某个类是否实现了Serializable接口</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>fragment</tag>
        <tag>屏幕旋转</tag>
      </tags>
  </entry>
  <entry>
    <title>通过ip地址连接virtualbox虚拟机android-x86</title>
    <url>/2016/05/04/%E9%80%9A%E8%BF%87ip%E5%9C%B0%E5%9D%80%E8%BF%9E%E6%8E%A5virtualbox%E8%99%9A%E6%8B%9F%E6%9C%BAandroid-x86/</url>
    <content><![CDATA[<p>只要能通过ip地址找到虚拟机中的系统，那么就可以干很多事，比如：<br>adb调试，或者使用nc命令传输一些文件或文件夹，等等。。<br>下面以adb连接virtualbox中的android-x86进行调试为例：</p>
<h1 id="安装android-x86"><a href="#安装android-x86" class="headerlink" title="安装android-x86"></a>安装android-x86</h1><p>首先你要安装好android-x86，这个就不多说了，网上很多教程<br>不过值得一提的是，在安装好之后，进入系统时，如果没有点技巧会卡在欢迎界面，安装时没有截图，就不上图了<br>解决方法是：在欢迎界面，状态栏下面开始，依次：<br>左上-右上-右下-左下<br>用鼠标点击一遍，就会自动跳过欢迎界面了</p>
<h1 id="查看android-x86的ip地址"><a href="#查看android-x86的ip地址" class="headerlink" title="查看android-x86的ip地址"></a>查看android-x86的ip地址</h1><p>本例中使用的是virtualbox默认的网络配置<br>进入android-x86系统，打开终端模拟器<br>接着输入“su”命令获取root权限，会弹出提示，自己看着选<br>获取root后，终端提示符会变成”#“<br>输入”netstat“命令，会打印出一些网络配置和ip地址信息，本例中的android-x86的ip地址为：”10.0.2.15”<br><font color=red>记住这个ip，后面会用到</font></p>
<h1 id="配置虚拟机系统的网络的端口转发功能"><a href="#配置虚拟机系统的网络的端口转发功能" class="headerlink" title="配置虚拟机系统的网络的端口转发功能"></a>配置虚拟机系统的网络的端口转发功能</h1><p>在vbox中在要配置的系统：android-x86上右键，选择设置<br>在出现的设置窗口的左侧菜单组中点击网络项，其他的不用管，直接接着点击端口转发按钮：<br>接着在新窗口中点击右侧”+“按钮，添加一条规则：</p>
<p><img src="guize.png" alt="guize"></p>
<p>其中主机ip最好填本机host，端口随便，不过如果是adb连接的话，最好用5555，因为adb connect默认是5555端口<br>子系统ip，就填第二步中使用netstat得到的ip地址，端口随意</p>
<p>配置好之后点确定，重启虚拟机中的android-x86</p>
<h1 id="adb连接android-x86系统"><a href="#adb连接android-x86系统" class="headerlink" title="adb连接android-x86系统"></a>adb连接android-x86系统</h1><p>启动你的android-x86后，打开终端模拟器，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">setprop service.adb.tcp.port 5555</span><br><span class="line">stop adbd</span><br><span class="line">start adbd</span><br></pre></td></tr></table></figure>
<p>命令解释：<br>su：获取root权限，要执行下面的命令必须要root身份，否则无效<br>setprop…：设置一个安卓系统的adb配置，即使用网络进行adb调试<br>stop adbd和start adbd：重启adb服务</p>
<p>这样android-x86就配置ok了，在你的主机(非虚拟机)中，打开一个命令行(cmd/terminal)，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb connect 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>连接成功时会提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">connected to 127.0.0.1:5555</span><br></pre></td></tr></table></figure>
<p>接着输入adb devices查看已连接设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">List of devices attached </span><br><span class="line">127.0.0.1:5555    device</span><br></pre></td></tr></table></figure>
<p>注意”127.0.0.1:5555“后面的提示，如果是device，则是链接成功，否则如果是offline就是没有连接上</p>
<p>最终输入：adb shell<br>进入android-x86终端控制，这条命令成功就意味着绝对是成功了<br>下面是这几步的图：</p>
<p><img src="shell.png" alt="shell"></p>
<blockquote>
<p>总结：<br>主要使用了virtualbox的端口转发功能，这个功能会把所有访问本机的某个设定好的端口的数据全部重定向到虚拟机系统的设置好的端口<br>这样就实现了对本机5555端口(本例)的访问，其实访问的是android-x86的5555端口</p>
</blockquote>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>virtualbox</tag>
        <tag>adb</tag>
        <tag>android-x86</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>通过打DSDT补丁让黑苹果显示电池状态信息</title>
    <url>/2019/10/11/%E9%80%9A%E8%BF%87%E6%89%93DSDT%E8%A1%A5%E4%B8%81%E8%AE%A9%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%98%BE%E7%A4%BA%E7%94%B5%E6%B1%A0%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<blockquote>
<p>翻译自：<a href="https://www.tonymacx86.com/threads/guide-how-to-patch-dsdt-for-working-battery-status.116102/">https://www.tonymacx86.com/threads/guide-how-to-patch-dsdt-for-working-battery-status.116102/</a></p>
</blockquote>
<blockquote>
<p>转载请注明出处</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为电脑中的电池硬件与苹果的 SMbus 硬件不兼容，所以在笔记本电脑上运行 OS X 时，我们使用 ACPI 来访问电池状态。一般来说，我建议你使用 <code>ACPIBatteryManager.kext</code>，可在这里找到: <a href="https://github.com/RehabMan/OS-X-ACPI-Battery-Driver">https://github.com/RehabMan/OS-X-ACPI-Battery-Driver</a></p>
<p>AppleACPIPlatform 的更高版本无法正确访问 EC（嵌入式控制器）中的字段。由于各种 ACPI 方法（_BIF，_STA，_BST等）失效，这会导致 ACPIBatteryManager 获取电池数据出现问题。尽管可以使用较旧版本的 AppleACPIPlatform（来自 Snow Leopard），但还是希望使用最新版本的AppleACPIPlatform，因为对于具有 Ivy Bridge CPU 的计算机，它可以为这些计算机启用本机电源管理。要使用最新版本，必须更改 DSDT 以符合 Apple 的 AppleACPIPlatform 的限制。</p>
<p>特别是，EC 中大于 8 位的任何字段都必须更改为 8 位。 这包括 16、32、64 甚至更大的字段。</p>
<p>你应该先熟悉 DSDT/SSDT 打补丁的基本知识： <a href="http://www.tonymacx86.com/yosemite-laptop-support/152573-guide-patching-laptop-dsdt-ssdts.html">http://www.tonymacx86.com/yosemite-laptop-support/152573-guide-patching-laptop-dsdt-ssdts.html</a></p>
<h1 id="已存在的补丁"><a href="#已存在的补丁" class="headerlink" title="已存在的补丁"></a>已存在的补丁</h1><p>首先，你的笔记本电脑可能已经有补丁了。请看我的补丁仓库: <a href="https://github.com/RehabMan/Laptop-DSDT-Patch">https://github.com/RehabMan/Laptop-DSDT-Patch</a></p>
<p>为了使 DSDT 与补丁程序匹配，通常首先需要了解补丁程序的制作方式，以便你知道在 DSDT 中要查找的内容，并且可以将所看到的内容与现有补丁程序进行匹配。补丁集的更改比率很高，不会产生错误，并且似乎在补丁所有需要补丁的字段，这很可能是匹配的（本句原文：A patch set that has a high ratio of changes to patches, creates no errors, and appears to patch all fields that need to be patched is likely a match）。</p>
<p>更多信息: <a href="https://www.tonymacx86.com/threads/guide-how-to-patch-dsdt-for-working-battery-status.116102/page-333#post-1360697">https://www.tonymacx86.com/threads/guide-how-to-patch-dsdt-for-working-battery-status.116102/page-333#post-1360697</a></p>
<p>** 注意不要使用除 <code>MaciASL</code> 以外的任何其他程序，包括 <code>DSDT Editor</code>，我只在 <code>MaciASL</code> 中测试了我的补丁 **</p>
<h1 id="其他相关-DSDT-补丁"><a href="#其他相关-DSDT-补丁" class="headerlink" title="其他相关 DSDT 补丁"></a>其他相关 DSDT 补丁</h1><p>除了多字节 EC 字段外，还有一些其他 DSDT 问题可能会影响电池状态。这些特定问题并非特定于电池状态，但通常在尝试实现电池状态时首次注意到。</p>
<p>电池代码可能取决于将 Windows 的公认版本用作主机 OS。 要解决此问题，请从 <code>laptop DSDT patch repository</code> 中应用 “OS Check Fix” 补丁。 这将导致 DSDT 采取与运行 “Windows 2006” 时相同的操作。你可以更改补丁以实现不同的选择（例如”Windows 2012”）。</p>
<p>另一个常见的问题是，OS X 的 ACPI 实现很难处理使用非零 SyncLevel 声明的 Mutex 对象（有关更多信息，请阅读ACPI规范）。要解决此问题，请从 <code>laptop DSDT patch repository</code> 中应用 “Fix Mutex with non-zero SyncLevel” 补丁。</p>
<h1 id="技能要求"><a href="#技能要求" class="headerlink" title="技能要求"></a>技能要求</h1><p>DSDT 是一个“程序”。 因此，在进行修改时具有一些编程/计算机技能会很有帮助。同样，DSDT 补丁本身也具有自己的语言（在 MaciASL Wiki 中进行了简要说明，可在此处找到：<a href="http://sourceforge.net/projects/maciasl/">http://sourceforge.net/projects/maciasl/</a> ）。最后，补丁本身基本上是正则表达式的搜索/替换，因此理解正则表达式（regex）会有帮助。熟悉编译器、编译器错误、有能力确定编译器报告的有关代码错误也很有用。</p>
<p>另外，熟悉 ACPI 也是一个好注意。可以在此处下载规范：<a href="https://www.acpica.org/">https://www.acpica.org/</a></p>
<p>本指南的目的不是教你基本的编程技巧，正则表达式或 ACPI 语言。</p>
<h1 id="打补丁的步骤"><a href="#打补丁的步骤" class="headerlink" title="打补丁的步骤"></a>打补丁的步骤</h1><p>我使用了一种相当“机械”的过程来打 DSDT 补丁。我只是寻找那些 OS X 无法处理的部分并机械地转换它。我不会太努力地确定代码的哪些部分实际上将要执行，我只是转换了所有看到的内容。</p>
<p>要继续学习，请从本文中下载示例 DSDT。此特定的 DSDT 示例适用于 HP Envy14。最终的完整补丁可从我的补丁库中以获取 “HP Envy 14”。</p>
<p>首先确定 DSDT 中看起来需要修改的结构。加载 DSDT 文件到 MaciASL 并搜索 <code>EmbeddedControl</code>。单个 DSDT 中可以有多个 EmbeddedControl 部分，每个部分都附加了字段声明。</p>
<p>因此，我总是从寻找 embeddedcontrol 开始以找到这种声明。</p>
<p>在示例 DSDT 中，您将找到以下单个 EC 域：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OperationRegion (ECF2, EmbeddedControl, Zero, 0xFF)</span><br></pre></td></tr></table></figure>
<p>上面的代码声明了一个 255 字节的 EC 域。</p>
<p>这个域被称为 <code>ECF2</code>，所以现在我们要搜索 <code>&#39;Field (ECF2&#39;</code>。正如在示例 DSDT 中可以看到的，只有一个结构定义（译者注：下面的代码块）引用了这个域，在其他的 DSDT 中可能有很多。</p>
<p>结构的定义描述了这个 255 字节 EC 域。它们是有关联的，因为这个结构体定义引用了 <code>ECF2</code> 这个名字（本句原文：You can tell it is related because the name ECF2 is referred to by the Field.）。可以将其视为 EC 中的一种结构（C程序员的结构）（译者注：可以将上面的代码块看作是声明，下面的代码块看作是定义，这样可能更容易理解一些）。</p>
<p>下一步是检查结构定义中的字段，找到大于 8 位的字段。例如，声明的第一个字段是 <code>BDN0</code>，大小为 56 位：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Field (ECF2, ByteAcc, Lock, Preserve)</span><br><span class="line">&#123;</span><br><span class="line">    Offset (0x10),</span><br><span class="line">    BDN0,   56,</span><br></pre></td></tr></table></figure>
<p>这是一个大于 8 位的（56 位）字段, 如果这个字段在 DSDT 中的其他位置被访问，则所有出现这个字段的代码都要修改，如果继续搜索 <code>&quot;BDN0&quot;</code> 会找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Store (BDN0, BDN)</span><br></pre></td></tr></table></figure>
<p>这是在（从结构 ECF2 中）将 BDN0 中的值存储到 BDN 中。当访问大于 32 位的字段时，它们以 Buffer 类型访问。32 位或以下的字段作为整数访问。在更改代码时，这一点很重要。Buffer 还有一些其他工作要做。同样，需要注意到此代码是从 ECF2 中读取的。从 ECF2 中读取和写入这两种操作必须以不同的方式处理。</p>
<p>因此，针对这行代码，我们的目的是一次读 8 位读 7 次将这个 56 位的元素读取到缓冲区，以便将所得缓冲区存储到 BDN 中。我们一会儿再回来看如何修改，现在让我们探索 ECF2 结构定义中的其他字段。</p>
<p>回到 ECF2 的定义的位置，查看 ECF2 定义的其余部分，查找所有大于 8 位的字段，然后针对每个字段搜索 DSDT 的其余部分，以查看它们是否在其他地方被访问。通常对于那些没有被其他地方访问的字段，我们无需执行任何操作。 因此，我们看到的下一个字段是BMN0：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BMN0,   32,</span><br></pre></td></tr></table></figure>
<p>如果我们在 DSDT 中搜索 <code>BMN0</code>，则只会找到此声明，因此它没有在其他地方被访问，我们可以忽略它。<code>BMN4</code> 也可以被忽略。而 <code>BCT0</code> 是128位并且在其他地方被访问，就像最初的 <code>BDN0</code> 一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Store (BCT0, CTN)</span><br></pre></td></tr></table></figure>
<p>进一步的搜索将得到以下列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                        BDN0,   56,</span><br><span class="line">                        BCT0,   128,</span><br><span class="line">                        BDN1,   56,</span><br><span class="line">                        BCT1,   128,</span><br><span class="line">...</span><br><span class="line">                        BDC0,   16,</span><br><span class="line">                        BDC1,   16,</span><br><span class="line">                        BFC0,   16,</span><br><span class="line">                        BFC1,   16,</span><br><span class="line">...</span><br><span class="line">                        BDV0,   16,</span><br><span class="line">                        BDV1,   16,</span><br><span class="line">...</span><br><span class="line">                        BPR0,   16,</span><br><span class="line">                        BPR1,   16,</span><br><span class="line"></span><br><span class="line">                        BRC0,   16,</span><br><span class="line">                        BRC1,   16,</span><br><span class="line">                        BCC0,   16,</span><br><span class="line">                        BCC1,   16,</span><br><span class="line">                        CV01,   16,</span><br><span class="line">                        CV02,   16,</span><br><span class="line">                        CV03,   16,</span><br><span class="line">                        CV04,   16,</span><br><span class="line">                        CV11,   16,</span><br><span class="line">                        CV12,   16,</span><br><span class="line">                        CV13,   16,</span><br><span class="line">                        CV14,   16,</span><br><span class="line">...</span><br><span class="line">                        BMD0,   16,</span><br><span class="line">                        BMD1,   16,</span><br><span class="line">                        BPV0,   16,</span><br><span class="line">                        BPV1,   16,</span><br><span class="line">                        BSN0,   16,</span><br><span class="line">                        BSN1,   16,</span><br><span class="line">                        BCV0,   16,</span><br><span class="line">                        BCV1,   16,</span><br><span class="line">                        CRG0,   16,</span><br><span class="line">                        CRG1,   16,</span><br><span class="line">                        BTY0,   32,</span><br><span class="line">                        BTY1,   32,</span><br><span class="line">...</span><br><span class="line">                        CBT0,   16,</span><br><span class="line">                        CBT1,   16,</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，此 DSDT 中有很多字段需要处理，并且大小各异，16位，32位，56位和128位。</p>
<h1 id="大小为16位和32位的字段"><a href="#大小为16位和32位的字段" class="headerlink" title="大小为16位和32位的字段"></a>大小为16位和32位的字段</h1><p>16位和32位的字段最容易处理，所以让我们从这里开始。让我们以上面列表中的第一个16位字段 <code>BDC0</code> 为例。我们要做的是更改此字段，以便将其分为两个部分（低字节，高字节）。为此，我们需要提供一个 4 个字符的名称，该名称不得与 <code>DSDT</code> 中的任何其他名称冲突，这通常很容易只需删除第一个字母并使用后三个字母。（译者注：把一个大小为 16 的变量，拆分两个大小为 8 的变量，并使用不同的变量名）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 之前是: BDC0, 16</span><br><span class="line">DC00, 8,</span><br><span class="line">DC01, 8,</span><br></pre></td></tr></table></figure>
<p>针对它的补丁可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">into device label H_EC code_regex BDC0,\s+16, replace_matched begin DC00,8,DC01,8, end;</span><br></pre></td></tr></table></figure>
<p>这个补丁的意思是：在名为 <code>H_EC</code> 的 <code>device</code> 段中，查找 <code>BDC0,\s+16</code>（其中 <code>\s+</code> 表示一个或多个空白符号），如果找到了则将其替换为 <code>DC00,8,DC01,8,</code>，这有效的将一个字段分成了两个。如果你应用这个补丁，并尝试编译修改后的 DSDT 文件，会发现一些错误，因为依然有代码在引用/访问 <code>BDC0</code>（译者注：<code>BDC0</code> 已经不存在了，因为被拆成了 <code>DC00</code> 和 <code>DC01</code>），这些错误实际上在帮助我们找到有哪地方需要修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Store (BDC0, Index (DerefOf (Index (Local0, 0x02)), Zero))</span><br><span class="line">Store (ShiftRight (BDC0, 0x08), Index (DerefOf (Index (Local0, 0x02)), One))</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，这段代码依然在读取已经不存在的、被拆成两部分的 <code>BDC0</code>。为了使补丁更容易编写，我们使用了一个名叫 <code>B1B2</code> 的工具函数，使用如下补丁来定义这个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">into method label B1B2 remove_entry;</span><br><span class="line">into definitionblock code_regex . insert</span><br><span class="line">begin</span><br><span class="line">Method (B1B2, 2, NotSerialized) &#123; Return(Or(Arg0, ShiftLeft(Arg1, 8))) &#125;\n</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>这个函数接收两个参数：低字节和高字节，并返回一个包含这两个参数的 16 位的值。（译者注：这个函数的作用是我们可以用这个函数来替换代码中所有对 <code>BDC0</code> 的引用）</p>
<p>针对上面的代码（译者注：注意是代码，不是补丁），我们想要将它转换成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Store (B1B2(DC00,DC01), Index (DerefOf (Index (Local0, 0x02)), Zero))</span><br><span class="line">Store (ShiftRight (B1B2(DC00,DC01), 0x08), Index (DerefOf (Index (Local0, 0x02)), One))</span><br></pre></td></tr></table></figure>
<p>构建一个补丁来自动执行这个转换，并且其他 16 位字段的补丁也将被应用相同的模式：<br>（译者注：注意这里使用的是 <code>replaceall_matched</code>，而上面使用的是 <code>replace_matched</code>，它们的区别从字面及原作者的语义来看前者将对 DSDT 文件中的所有匹配做替换操作，后者只替换一个）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">into method label GBTI code_regex \(BDC0, replaceall_matched begin (B1B2(DC00,DC01), end;</span><br></pre></td></tr></table></figure>
<p>敏锐的读者会注意到，可以对以下代码进行优化（译者注：这里没看懂，估计要结合示例 DSDT 文件内容来看才能理解）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Store (DC00, Index (DerefOf (Index (Local0, 0x02)), Zero))</span><br><span class="line">Store (DC01, Index (DerefOf (Index (Local0, 0x02)), One))</span><br></pre></td></tr></table></figure>
<p>这种优化只能通过手动进行，通常这是不值得的。这里的目标是提出一种修复此代码的自动化方法，而不是试图过多地手动修改，因为如果我们进行过多的手动更改，我们可能会在代码中引入错误。另外，这种代码很少见（在我修改过的 20 多个 DSDT 中仅在两个 DSDT 中看到了它）。</p>
<p>既然你了解了如何处理 16 位的字段，那么将它们全部转换可能是最简单的。这是针对 16 位 EC 字段的综合补丁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 16-bit registers</span><br><span class="line">into device label H_EC code_regex BDC0,\s+16 replace_matched begin DC00,8,DC01,8 end;</span><br><span class="line">into device label H_EC code_regex BDC1,\s+16 replace_matched begin DC10,8,DC11,8 end;</span><br><span class="line">into device label H_EC code_regex BFC0,\s+16 replace_matched begin FC00,8,FC01,8 end;</span><br><span class="line">into device label H_EC code_regex BFC1,\s+16 replace_matched begin FC10,8,FC11,8 end;</span><br><span class="line">into device label H_EC code_regex BDV0,\s+16 replace_matched begin DV00,8,DV01,8 end;</span><br><span class="line">into device label H_EC code_regex BDV1,\s+16 replace_matched begin DV10,8,DV11,8 end;</span><br><span class="line">into device label H_EC code_regex BPR0,\s+16 replace_matched begin PR00,8,PR01,8 end;</span><br><span class="line">into device label H_EC code_regex BPR1,\s+16 replace_matched begin PR10,8,PR11,8 end;</span><br><span class="line">into device label H_EC code_regex BRC0,\s+16 replace_matched begin RC00,8,RC01,8 end;</span><br><span class="line">into device label H_EC code_regex BRC1,\s+16 replace_matched begin RC10,8,RC11,8 end;</span><br><span class="line">into device label H_EC code_regex BCC0,\s+16 replace_matched begin CC00,8,CC01,8 end;</span><br><span class="line">into device label H_EC code_regex BCC1,\s+16 replace_matched begin CC10,8,CC11,8 end;</span><br><span class="line">into device label H_EC code_regex CV01,\s+16 replace_matched begin CV10,8,CV11,8 end;</span><br><span class="line">into device label H_EC code_regex CV02,\s+16 replace_matched begin CV20,8,CV21,8 end;</span><br><span class="line">into device label H_EC code_regex CV03,\s+16 replace_matched begin CV30,8,CV31,8 end;</span><br><span class="line">into device label H_EC code_regex CV04,\s+16 replace_matched begin CV40,8,CV41,8 end;</span><br><span class="line">into device label H_EC code_regex CV11,\s+16 replace_matched begin CV50,8,CV51,8 end;</span><br><span class="line">into device label H_EC code_regex CV12,\s+16 replace_matched begin CV60,8,CV61,8 end;</span><br><span class="line">into device label H_EC code_regex CV13,\s+16 replace_matched begin CV70,8,CV71,8 end;</span><br><span class="line">into device label H_EC code_regex CV14,\s+16 replace_matched begin CV80,8,CV81,8 end;</span><br><span class="line">into device label H_EC code_regex HPBA,\s+16 replace_matched begin PBA0,8,PBA1,8 end;</span><br><span class="line">into device label H_EC code_regex HPBB,\s+16 replace_matched begin PBB0,8,PBB1,8 end;</span><br><span class="line">into device label H_EC code_regex BMD0,\s+16 replace_matched begin MD00,8,MD01,8 end;</span><br><span class="line">into device label H_EC code_regex BMD1,\s+16 replace_matched begin MD10,8,MD11,8 end;</span><br><span class="line">into device label H_EC code_regex BPV0,\s+16 replace_matched begin PV00,8,PV01,8 end;</span><br><span class="line">into device label H_EC code_regex BPV1,\s+16 replace_matched begin PV10,8,PV11,8 end;</span><br><span class="line">into device label H_EC code_regex BSN0,\s+16 replace_matched begin SN00,8,SN01,8 end;</span><br><span class="line">into device label H_EC code_regex BSN1,\s+16 replace_matched begin SN10,8,SN11,8 end;</span><br><span class="line">into device label H_EC code_regex BCV0,\s+16 replace_matched begin BV00,8,BV01,8 end;</span><br><span class="line">into device label H_EC code_regex BCV1,\s+16 replace_matched begin BV10,8,BV11,8 end;</span><br><span class="line">into device label H_EC code_regex CRG0,\s+16 replace_matched begin RG00,8,RG01,8 end;</span><br><span class="line">into device label H_EC code_regex CRG1,\s+16 replace_matched begin RG10,8,RG11,8 end;</span><br><span class="line">into device label H_EC code_regex CBT0,\s+16 replace_matched begin BT00,8,BT01,8 end;</span><br><span class="line">into device label H_EC code_regex CBT1,\s+16 replace_matched begin BT10,8,BT11,8 end;</span><br></pre></td></tr></table></figure>
<p>并且访问这些字段的所有代码都必须修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># fix 16-bit methods</span><br><span class="line">into method label GBTI code_regex \(BDC0, replaceall_matched begin (B1B2(DC00,DC01), end;</span><br><span class="line">into method label GBTI code_regex \(BDC1, replaceall_matched begin (B1B2(DC10,DC11), end;</span><br><span class="line">into method label GBTI code_regex \(BFC0, replaceall_matched begin (B1B2(FC00,FC01), end;</span><br><span class="line">into method label GBTI code_regex \(BFC1, replaceall_matched begin (B1B2(FC10,FC11), end;</span><br><span class="line">into method label BTIF code_regex \(BFC0, replaceall_matched begin (B1B2(FC00,FC01), end;</span><br><span class="line">into method label BTIF code_regex \(BFC1, replaceall_matched begin (B1B2(FC10,FC11), end;</span><br><span class="line">into method label ITLB code_regex \(BFC1, replaceall_matched begin (B1B2(FC10,FC11), end;</span><br><span class="line">into method label ITLB code_regex \sBFC0, replaceall_matched begin B1B2(FC00,FC01), end;</span><br><span class="line">into method label _Q09 code_regex \(BRC0, replaceall_matched begin (B1B2(RC00,RC01), end;</span><br><span class="line">into method label _Q09 code_regex \sBFC0\) replaceall_matched begin B1B2(FC00,FC01)) end;</span><br><span class="line">into method label GBTI code_regex \(BDV0, replaceall_matched begin (B1B2(DV00,DV01), end;</span><br><span class="line">into method label GBTI code_regex \(BDV1, replaceall_matched begin (B1B2(DV10,DV11), end;</span><br><span class="line">into method label BTIF code_regex \(BDV0, replaceall_matched begin (B1B2(DV00,DV01), end;</span><br><span class="line">into method label BTIF code_regex \(BDV1, replaceall_matched begin (B1B2(DV10,DV11), end;</span><br><span class="line">into method label GBTI code_regex \(BPR0, replaceall_matched begin (B1B2(PR00,PR01), end;</span><br><span class="line">into method label GBTI code_regex \(BPR1, replaceall_matched begin (B1B2(PR10,PR11), end;</span><br><span class="line">into method label BTST code_regex \sBPR0, replaceall_matched begin B1B2(PR00,PR01), end;</span><br><span class="line">into method label BTST code_regex \sBPR1, replaceall_matched begin B1B2(PR10,PR11), end;</span><br><span class="line">into method label BTST code_regex \(BPR0, replaceall_matched begin (B1B2(PR00,PR01), end;</span><br><span class="line">into method label BTST code_regex \(BPR1, replaceall_matched begin (B1B2(PR10,PR11), end;</span><br><span class="line">into method label BTST code_regex \(BRC0, replaceall_matched begin (B1B2(RC00,RC01), end;</span><br><span class="line">into method label BTST code_regex \(BRC1, replaceall_matched begin (B1B2(RC10,RC11), end;</span><br><span class="line">into method label GBTI code_regex \(BRC0, replaceall_matched begin (B1B2(RC00,RC01), end;</span><br><span class="line">into method label GBTI code_regex \(BRC1, replaceall_matched begin (B1B2(RC10,RC11), end;</span><br><span class="line">into method label _Q09 code_regex \(BRC0, replaceall_matched begin (B1B2(RC00,RC01), end;</span><br><span class="line">into method label GBTI code_regex \(BCC0, replaceall_matched begin (B1B2(CC00,CC01), end;</span><br><span class="line">into method label GBTI code_regex \(BCC1, replaceall_matched begin (B1B2(CC10,CC11), end;</span><br><span class="line">into method label GBTI code_regex \(CV01, replaceall_matched begin (B1B2(CV10,CV11), end;</span><br><span class="line">into method label GBTI code_regex \(CV02, replaceall_matched begin (B1B2(CV20,CV21), end;</span><br><span class="line">into method label GBTI code_regex \(CV03, replaceall_matched begin (B1B2(CV30,CV31), end;</span><br><span class="line">into method label GBTI code_regex \(CV04, replaceall_matched begin (B1B2(CV40,CV41), end;</span><br><span class="line">into method label GBTI code_regex \(CV11, replaceall_matched begin (B1B2(CV50,CV51), end;</span><br><span class="line">into method label GBTI code_regex \(CV12, replaceall_matched begin (B1B2(CV60,CV61), end;</span><br><span class="line">into method label GBTI code_regex \(CV13, replaceall_matched begin (B1B2(CV70,CV71), end;</span><br><span class="line">into method label GBTI code_regex \(CV14, replaceall_matched begin (B1B2(CV80,CV81), end;</span><br><span class="line">into method label BTIF code_regex \(BMD0, replaceall_matched begin (B1B2(MD00,MD01), end;</span><br><span class="line">into method label BTIF code_regex \(BMD1, replaceall_matched begin (B1B2(MD10,MD11), end;</span><br><span class="line">into method label GBTI code_regex \sBMD0\) replaceall_matched begin B1B2(MD00,MD01)) end;</span><br><span class="line">into method label GBTI code_regex \(BMD0, replaceall_matched begin (B1B2(MD00,MD01), end;</span><br><span class="line">into method label GBTI code_regex \sBMD1\) replaceall_matched begin B1B2(MD10,MD11)) end;</span><br><span class="line">into method label GBTI code_regex \(BMD1, replaceall_matched begin (B1B2(MD10,MD11), end;</span><br><span class="line">into method label BTST code_regex \(BPV0, replaceall_matched begin (B1B2(PV00,PV01), end;</span><br><span class="line">into method label BTST code_regex \(BPV1, replaceall_matched begin (B1B2(PV10,PV11), end;</span><br><span class="line">into method label GBTI code_regex \(BPV0, replaceall_matched begin (B1B2(PV00,PV01), end;</span><br><span class="line">into method label GBTI code_regex \(BPV1, replaceall_matched begin (B1B2(PV10,PV11), end;</span><br><span class="line">into method label BTIF code_regex \(BSN0, replaceall_matched begin (B1B2(SN00,SN01), end;</span><br><span class="line">into method label BTIF code_regex \(BSN1, replaceall_matched begin (B1B2(SN10,SN11), end;</span><br><span class="line">into method label GBTI code_regex \(BSN0, replaceall_matched begin (B1B2(SN00,SN01), end;</span><br><span class="line">into method label GBTI code_regex \(BSN1, replaceall_matched begin (B1B2(SN10,SN11), end;</span><br><span class="line">into method label GBTI code_regex \(BCV0, replaceall_matched begin (B1B2(BV00,BV01), end;</span><br><span class="line">into method label GBTI code_regex \(BCV1, replaceall_matched begin (B1B2(BV10,BV11), end;</span><br><span class="line">into method label GBTI code_regex \(CRG0, replaceall_matched begin (B1B2(RG00,RG01), end;</span><br><span class="line">into method label GBTI code_regex \(CRG1, replaceall_matched begin (B1B2(RG10,RG11), end;</span><br><span class="line">into method label GBTI code_regex \(CBT0, replaceall_matched begin (B1B2(BT00,BT01), end;</span><br><span class="line">into method label GBTI code_regex \(CBT1, replaceall_matched begin (B1B2(BT10,BT11), end;</span><br></pre></td></tr></table></figure>

<p>现在那些 32 位的字段如 BTY0 和 BTY1 如何处理呢？ 它们与 16 位的字段处理方式差不多，除了我们需要再声明一个名为 B1B4 的函数，它能从四个 8 位的参数中构造出一个 32 位的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">into method label B1B4 remove_entry;</span><br><span class="line">into definitionblock code_regex . insert</span><br><span class="line">begin</span><br><span class="line">Method (B1B4, 4, NotSerialized)\n</span><br><span class="line">&#123;\n</span><br><span class="line">    Store(Arg3, Local0)\n</span><br><span class="line">    Or(Arg2, ShiftLeft(Local0, 8), Local0)\n</span><br><span class="line">    Or(Arg1, ShiftLeft(Local0, 8), Local0)\n</span><br><span class="line">    Or(Arg0, ShiftLeft(Local0, 8), Local0)\n</span><br><span class="line">    Return(Local0)\n</span><br><span class="line">&#125;\n</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>然后我们需要将 BTY0 和 BTY1 转换成 4 个 8 位的字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 32-bit registers</span><br><span class="line">into device label H_EC code_regex BTY0,\s+32 replace_matched begin TY00,8,TY01,8,TY02,8,TY03,8 end;</span><br><span class="line">into device label H_EC code_regex BTY1,\s+32 replace_matched begin TY10,8,TY11,8,TY12,8,TY13,8 end;</span><br></pre></td></tr></table></figure>
<p>下面这些在 GBTI 函数中的代码需要修改，因为它们引用了 BTY0 和 BYT1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Store (BTY0, BTY)</span><br><span class="line">...</span><br><span class="line">   Store (BTY1, BTYB)</span><br></pre></td></tr></table></figure>
<p>很像针对 16 位字段所做的补丁，但使用的是 <code>B1B4</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># fix 32-bit methods</span><br><span class="line">into method label GBTI code_regex \(BTY0, replaceall_matched begin (B1B4(TY00,TY01,TY02,TY03), end;</span><br><span class="line">into method label GBTI code_regex \(BTY1, replaceall_matched begin (B1B4(TY10,TY11,TY12,TY13), end;</span><br></pre></td></tr></table></figure>
<p>这个补丁将会把上面的代码修改成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Store (B1B4(TY00,TY01,TY02,TY03), BTY)</span><br><span class="line">...</span><br><span class="line">   Store (B1B4(TY10,TY11,TY12,TY13), BTYB)</span><br></pre></td></tr></table></figure>

<h1 id="缓冲字段（大于-32-位的字段）"><a href="#缓冲字段（大于-32-位的字段）" class="headerlink" title="缓冲字段（大于 32 位的字段）"></a>缓冲字段（大于 32 位的字段）</h1><p>回到我们最初对大于8位的字段的搜索结果，发现我们有这些大于32位的字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BDN0,   56,</span><br><span class="line">BCT0,   128,</span><br><span class="line">BDN1,   56,</span><br><span class="line">BCT1,   128,</span><br></pre></td></tr></table></figure>
<p>要一次以 8 位访问这些字段很繁琐，因此我喜欢通过 offset（偏移量） 来访问它们，并确保没有现有的代码直接访问它们，我们使用如下补丁将其重命名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">into device label H_EC code_regex (BDN0,)\s+(56) replace_matched begin BDNX,%2,&#x2F;&#x2F;%1%2 end;</span><br><span class="line">into device label H_EC code_regex (BDN1,)\s+(56) replace_matched begin BDNY,%2,&#x2F;&#x2F;%1%2 end;</span><br><span class="line">into device label H_EC code_regex (BCT0,)\s+(128) replace_matched begin BCTX,%2,&#x2F;&#x2F;%1%2 end;</span><br><span class="line">into device label H_EC code_regex (BCT1,)\s+(128) replace_matched begin BCTY,%2,&#x2F;&#x2F;%1%2 end;</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要确定这些字段在结构体 ECF2 内的偏移量。<strong>请记住，大小以位为单位，但偏移量以字节为单位（译者注：这里需要记住）</strong>。我在下面的注释中使用的偏移量以十六进制表示。你可以看看是否能计算出相同的数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Field (ECF2, ByteAcc, Lock, Preserve)</span><br><span class="line">&#123;</span><br><span class="line">         Offset (0x10),</span><br><span class="line">    BDN0,   56,     &#x2F;&#x2F;!!0x10</span><br><span class="line">         Offset (0x18),</span><br><span class="line">    BME0,   8,</span><br><span class="line">         Offset (0x20),</span><br><span class="line">    BMN0,   32,     &#x2F;&#x2F;0x20</span><br><span class="line">    BMN2,   8,     &#x2F;&#x2F;0x24</span><br><span class="line">    BMN4,   88,    &#x2F;&#x2F;0x25</span><br><span class="line">    BCT0,   128,     &#x2F;&#x2F;!! 0x30</span><br><span class="line">    BDN1,   56,     &#x2F;&#x2F;!! 0x40</span><br><span class="line">         Offset (0x48),</span><br><span class="line">    BME1,   8,</span><br><span class="line">         Offset (0x50),</span><br><span class="line">    BMN1,   32,     &#x2F;&#x2F;0x50</span><br><span class="line">    BMN3,   8,     &#x2F;&#x2F;0x54</span><br><span class="line">    BMN5,   88,     &#x2F;&#x2F;0x55</span><br><span class="line">    BCT1,   128,     &#x2F;&#x2F;!!0x60</span><br></pre></td></tr></table></figure>
<p>一旦你运行了上面的补丁并编译，编译器会告诉你哪些地方需要被注意（译者注：编译报错的地方即需要被修改的地方）。在这个例子中，我们会看到下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">   Store (BCT0, CTN)</span><br><span class="line">...</span><br><span class="line">   Store (BDN0, BDN)</span><br><span class="line">...</span><br><span class="line">   Store (BCT1, CTNB)</span><br><span class="line">...</span><br><span class="line">   Store (BDN1, BDNB)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>出现这些错误是因为 BCT0, BDN0, BCT1, BDN1 这些字段被我们改了名字。</p>
<p>正如你所看到的，代码在从这些缓冲字段读取并将它们存储在其他位置。为了一次读取这些缓冲字段 8 位数据，我们需要定义其他函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># utility methods to read&#x2F;write buffers from&#x2F;to EC</span><br><span class="line">into method label RE1B parent_label H_EC remove_entry;</span><br><span class="line">into method label RECB parent_label H_EC remove_entry;</span><br><span class="line">into device label H_EC insert</span><br><span class="line">begin</span><br><span class="line">Method (RE1B, 1, NotSerialized)\n</span><br><span class="line">&#123;\n</span><br><span class="line">    OperationRegion(ERAM, EmbeddedControl, Arg0, 1)\n</span><br><span class="line">    Field(ERAM, ByteAcc, NoLock, Preserve) &#123; BYTE, 8 &#125;\n</span><br><span class="line">    Return(BYTE)\n</span><br><span class="line">&#125;\n</span><br><span class="line">Method (RECB, 2, Serialized)\n</span><br><span class="line">&#x2F;&#x2F; Arg0 - offset in bytes from zero-based EC\n</span><br><span class="line">&#x2F;&#x2F; Arg1 - size of buffer in bits\n</span><br><span class="line">&#123;\n</span><br><span class="line">    ShiftRight(Add(Arg1,7), 3, Arg1)\n</span><br><span class="line">    Name(TEMP, Buffer(Arg1) &#123; &#125;)\n</span><br><span class="line">    Add(Arg0, Arg1, Arg1)\n</span><br><span class="line">    Store(0, Local0)\n</span><br><span class="line">    While (LLess(Arg0, Arg1))\n</span><br><span class="line">    &#123;\n</span><br><span class="line">        Store(RE1B(Arg0), Index(TEMP, Local0))\n</span><br><span class="line">        Increment(Arg0)\n</span><br><span class="line">        Increment(Local0)\n</span><br><span class="line">    &#125;\n</span><br><span class="line">    Return(TEMP)\n</span><br><span class="line">&#125;\n</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>“RECB” 代表 “读 EC 缓冲区”。它接受两个参数，指示 EC 中的偏移量和希望读取的字段的位大小。以位为单位的大小必须是 8 的倍数。注意，函数中没有检查这个参数。</p>
<p>在此 DSDT 中，比如在名为 H_EC 的 EC 设备（译者注：代码段）中定义这些辅助方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Device (H_EC)</span><br><span class="line">&#123;</span><br><span class="line">    Name (_HID, EisaId (&quot;PNP0C09&quot;))</span><br></pre></td></tr></table></figure>
<p>如果你的 EC 设备（译者注：代码段）名称不同（译者注：不叫 H_EC），则需要更改上面创建 RECB/RE1B 这两个函数的补丁。通常名称为 EC，EC0，在本例中为 H_EC。</p>
<p>为了处理 BCT0 的第一种情况，我们希望修改成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Store(RECB(0x30,128), CTN)</span><br></pre></td></tr></table></figure>
<p><code>0x30</code> 是 BTC0 字段（现在称为 BCTX）的偏移量，而 128 是位数。</p>
<p>这些可以通过以下补丁来完成修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">into method label GBTI code_regex \(BCT0, replaceall_matched begin (RECB(0x30,128), end;</span><br><span class="line">into method label GBTI code_regex \(BCT1, replaceall_matched begin (RECB(0x60,128), end;</span><br><span class="line">into method label GBTI code_regex \(BDN0, replaceall_matched begin (RECB(0x10,56), end;</span><br><span class="line">into method label GBTI code_regex \(BDN1, replaceall_matched begin (RECB(0x40,56), end;</span><br></pre></td></tr></table></figure>
<p>此 DSDT 没有对 EC 缓冲字段的任何写操作，但如果有，则下面的函数非常有用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">into method label WE1B parent_label H_EC remove_entry;</span><br><span class="line">into method label WECB parent_label H_EC remove_entry;</span><br><span class="line">into device label H_EC insert</span><br><span class="line">begin</span><br><span class="line">Method (WE1B, 2, NotSerialized)\n</span><br><span class="line">&#123;\n</span><br><span class="line">    OperationRegion(ERAM, EmbeddedControl, Arg0, 1)\n</span><br><span class="line">    Field(ERAM, ByteAcc, NoLock, Preserve) &#123; BYTE, 8 &#125;\n</span><br><span class="line">    Store(Arg1, BYTE)\n</span><br><span class="line">&#125;\n</span><br><span class="line">Method (WECB, 3, Serialized)\n</span><br><span class="line">&#x2F;&#x2F; Arg0 - offset in bytes from zero-based EC\n</span><br><span class="line">&#x2F;&#x2F; Arg1 - size of buffer in bits\n</span><br><span class="line">&#x2F;&#x2F; Arg2 - value to write\n</span><br><span class="line">&#123;\n</span><br><span class="line">    ShiftRight(Add(Arg1,7), 3, Arg1)\n</span><br><span class="line">    Name(TEMP, Buffer(Arg1) &#123; &#125;)\n</span><br><span class="line">    Store(Arg2, TEMP)\n</span><br><span class="line">    Add(Arg0, Arg1, Arg1)\n</span><br><span class="line">    Store(0, Local0)\n</span><br><span class="line">    While (LLess(Arg0, Arg1))\n</span><br><span class="line">    &#123;\n</span><br><span class="line">        WE1B(Arg0, DerefOf(Index(TEMP, Local0)))\n</span><br><span class="line">        Increment(Arg0)\n</span><br><span class="line">        Increment(Local0)\n</span><br><span class="line">    &#125;\n</span><br><span class="line">&#125;\n</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>假设写入 BCT0 的代码是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Store(Local0, BCT0)</span><br></pre></td></tr></table></figure>
<p>在这种情况下，不能用对 RECB 的调用来代替对 BCT0 的访问。因为这是写操作，而不是读操作。必须使用上面新创建的函数 WECB。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WECB(0x30,128, Local0)</span><br></pre></td></tr></table></figure>
<p>WECB 函数的前两个参数与 RECB 相同（EC字段的偏移量和大小）。第三个参数（Arg2）是应写入 EC 字段的值。在这个例子中，是从 Local0 读取数据写入到第一个参数指定的偏移量里。</p>
<p><code>Store</code> 并不是唯一可以执行写操作的 AML 操作码。<code>Store</code> 也不是唯一可以执行读操作的 AML 操作码。 例如 <code>Add</code> 操作码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Add(X, Y, Z)</span><br></pre></td></tr></table></figure>
<p>上面的示例从X读取，从Y读取，执行加法…并将结果写入Z。</p>
<p>当不确定 AML 操作码的用途时，请阅读 ACPI 规范。在那里有完整的文档，但不在本文讨论范围之内。</p>
<p>文字开头给出的 github 仓库是示例和学习的良好来源。仓库中的现有修补程序中有许多 WECB/RECB 示例。</p>
<h1 id="充电-放电状态的逻辑错误-充电器检测"><a href="#充电-放电状态的逻辑错误-充电器检测" class="headerlink" title="充电/放电状态的逻辑错误(充电器检测)"></a>充电/放电状态的逻辑错误(充电器检测)</h1><p>某些 DSDT 存在逻辑错误，在这种情况下，容量达到 100％（电池充满电）时，<code>_BST</code> 返回了错误的状态。这主要影响某些华硕笔记本电脑，但也影响其他一些笔记本电脑。</p>
<p>这是解决此问题的补丁程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">into method label FBST code_regex If\s\(CHGS\s\(Zero\)\)[\s]+\&#123;[\s]+Store\s\(0x02,\sLocal0\)[\s]+\&#125;[\s]+Else[\s]+\&#123;[\s]+Store\s\(One,\sLocal0\)[\s]+\&#125; replaceall_matched begin</span><br><span class="line">If (CHGS (Zero))\n</span><br><span class="line">&#123;\n</span><br><span class="line">     Store (0x02, Local0)\n</span><br><span class="line">&#125;\n</span><br><span class="line">Else\n</span><br><span class="line">&#123;\n</span><br><span class="line">     Store (Zero, Local0)\n</span><br><span class="line">&#125;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h1 id="错误报告"><a href="#错误报告" class="headerlink" title="错误报告"></a>错误报告</h1><p>下载 patchmatic: <a href="https://bitbucket.org/RehabMan/os-x-maciasl-patchmatic/downloads/RehabMan-patchmatic-2015-0107.zip">https://bitbucket.org/RehabMan/os-x-maciasl-patchmatic/downloads/RehabMan-patchmatic-2015-0107.zip</a></p>
<p>从 zip 中解压出 ‘patchmatic’ 二进制文件. 复制到 <code>/usr/bin</code>, 即最终的文件位置是：<code>/usr/bin/patchmatic</code>.</p>
<p>在终端中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ -d ~&#x2F;Downloads&#x2F;RehabMan ]; then rm -R ~&#x2F;Downloads&#x2F;RehabMan; fi</span><br><span class="line">mkdir ~&#x2F;Downloads&#x2F;RehabMan</span><br><span class="line">cd ~&#x2F;Downloads&#x2F;RehabMan</span><br><span class="line">patchmatic -extract</span><br></pre></td></tr></table></figure>
<p>注意：如果使用复制/粘贴而不是手动键入命令，会更容易。</p>
<p>将 <code>~/Downloads/RehabMan</code> 目录打包成 zip 文件。</p>
<p>另外将 <code>ioreg</code> 也打包成 zip：<a href="http://www.tonymacx86.com/audio/58368-guide-how-make-copy-ioreg.html">http://www.tonymacx86.com/audio/58368-guide-how-make-copy-ioreg.html</a>. 注意要用帖子中提到的 <code>IORegistryExplorer v2.1</code>！不要使用其他版本的 <code>IORegistryExplorer.app</code>。</p>
<p>还有以下命令的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kextstat|grep -y acpiplat</span><br><span class="line">kextstat|grep -y appleintelcpu</span><br><span class="line">kextstat|grep -y applelpc</span><br></pre></td></tr></table></figure>
<p>还有打包成 zip 的 <code>EFI/Clover</code> 目录（在打包前先在 Clover 界面按一下 F4）。注意要删除 ‘themes’ 目录，尤其是如果你安装了很多主题，还有只需要提供 <code>EFI/Clover</code> 而不是整个 <code>EFI</code> 目录。</p>
<p>还有以下命令的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo touch &#x2F;System&#x2F;Library&#x2F;Extensions &amp;&amp; sudo kextcache -u &#x2F;</span><br></pre></td></tr></table></figure>
<p>再把上面提到的所有内容打包成一个大的 zip 文件并发布到帖子里。不要使用外部链接，使用编辑帖子时的上传文件功能。</p>
<h1 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h1><p>如果你确实完成了给你的电池方法打补丁，建议你将你的补丁和你的电脑信息共享出来，让其他与你是同样配置的人也能使用你的补丁，我可以将你的补丁程序添加到上面提到的 github 仓库中。请同时提供包含补丁和本机 DSDT 的文本文件（以便我能够根据本机 DSDT 查看补丁程序）。只有可以将补丁应用到本机 DSDT上时，我才会将这个补丁添加到仓库中。</p>
<p>译者注：示例 DSDT 文件请从原文中下载。</p>
]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>osx</tag>
        <tag>hackintosh</tag>
        <tag>dsdt</tag>
        <tag>电池</tag>
      </tags>
  </entry>
</search>
